{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-28T00:05:44.027862+00:00",
  "repo": "oauth-wg/oauth-browser-based-apps",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUzODI0NjQ1MTI=",
      "title": "Add security considerations for refresh tokens",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/1",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/mail-archive/web/oauth/current/msg18518.html\r\n\r\n> > > First of all the AS decides whether it issues refresh tokens or not. Having the ability does not mean the AS must do it. If you feel it\u2019s safer to not do it. Fine. \r\n> > \r\n> > Sure, and this should be mentioned then somewhere (either in the threats doc or in this proposed best practice doc). Not all end developers using these protocols fully understand the ramifications. \r\n> \r\n> Aaron: I suggest this goes to the SPA BCP since this is client specific.\r\n",
      "createdAt": "2018-11-20T01:47:07Z",
      "updatedAt": "2018-12-09T20:19:07Z",
      "closedAt": "2018-12-09T20:19:07Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Added in 5cd12e9d5f7e58d614073ef5b073c40ae1ad5091",
          "createdAt": "2018-12-09T20:19:07Z",
          "updatedAt": "2018-12-09T20:19:07Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NTA4OTE2NTY=",
      "title": "Add a section about storing tokens in JS",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/2",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* storing tokens available to JS opens up new XSS attack vectors\r\n* LocalStorage and IndexedDB are protected by the [same origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) so at least third party scripts can't access data there",
      "createdAt": "2020-01-16T15:45:44Z",
      "updatedAt": "2022-12-01T00:51:02Z",
      "closedAt": "2022-12-01T00:51:02Z",
      "comments": [
        {
          "author": "eZanmoto",
          "authorAssociation": "NONE",
          "body": "I think it would be good to have such a section to promote such best practices in a concrete way, but I see a problem in having it be too reliant on existing technologies since it can go out of date so quickly. I don't keep up to date with browser developments too much, but it seems like the recommendation has gone from keeping tokens solely in memory (possible with silent renew), to keeping tokens in the storage mechanisms you mentioned, to possibly keeping them in WebWorkers (pending investigation). We may even see this change again if browsers support a secure local storage system, or once the WebID proposal makes it, etc. Because of these, it might make more sense to have the section detail the desired properties that tokens would be stored with, and like you mentioned, the different attack vectors that we know are associated with each. For example:\r\n\r\n* Access tokens should ideally be:\r\n  * Stored in memory only, and not saved to persistent storage. This prevents malicious third-party scripts included in the first party application (e.g. NPM dependencies) from retrieving the token from the persistent storage.\r\n  * Stored in WebWorkers, if in-memory storage isn't possible. (Reasons)\r\n  * Stored in LocalStorage or IndexedDB, if WebWorkers storage isn't possible. (Reasons)\r\n  * Stored in a closure variable, as opposed to an object property. This prevents malicious third-party scripts included in the first party application (e.g. NPM dependencies) from accessing the variable via reflection. (NOTE Does marking a property as `private` achieve this behaviour?)\r\n  * Managed by a \"token manager\" class, which only provides access to the access token (in the case where the token manager also handles refresh tokens). The \"token manager\" class should only have one, non-global instance, which should only be accessible by a service class, which uses the access tokens directly in service calls. Having a token manager class allows for separation of concerns in the codebase, and reducing the number of objects that can use this manager be limited to a single service instance reduces the possibility of an access token being retrieved by an object that doesn't require it.\r\n* Refresh tokens should follow the same storage precautions as access tokens, but should additionally be:\r\n  * Not returned to the frontend. (Reasons)\r\n  * Managed by WebWorkers, if handled on the frontend. (Reasons)\r\n\r\nNote that JS isn't my speciality so take these suggestions with a pinch of salt.",
          "createdAt": "2020-07-28T08:30:22Z",
          "updatedAt": "2020-07-28T08:30:22Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Alright, this is a lot, but I finally put together the start to this section. I'm definitely open to suggestions and corrections. Here's the link to the current draft:\r\n\r\nhttps://drafts.oauth.net/oauth-browser-based-apps/draft-ietf-oauth-browser-based-apps.html#name-token-storage-in-the-browse\r\n\r\nIt's kind of a wall of text right now, so probably could use some help breaking it up into different sub-headers.",
          "createdAt": "2022-11-29T02:59:21Z",
          "updatedAt": "2022-11-29T02:59:21Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This now has section headers and is a lot more readable. I also added a new section about sender-constrained tokens as well as a reference to DPoP.",
          "createdAt": "2022-12-01T00:51:01Z",
          "updatedAt": "2022-12-01T00:51:01Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU3MTM5NTI0Nzk=",
      "title": "Add architectural pattern of using a Service Worker as the OAuth client",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/3",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "keeps the access token and refresh token out of the DOM-accessible JS, only accessible from within the Service Worker\r\n\r\nhttps://gitlab.com/jimdigriz/oauth2-worker\r\n",
      "createdAt": "2020-10-02T23:31:15Z",
      "updatedAt": "2022-11-07T10:13:06Z",
      "closedAt": "2022-09-06T18:08:32Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Done in #19 ",
          "createdAt": "2022-09-06T18:08:31Z",
          "updatedAt": "2022-09-06T18:08:31Z"
        },
        {
          "author": "jimdigriz",
          "authorAssociation": "NONE",
          "body": "> https://gitlab.com/jimdigriz/oauth2-worker\r\n\r\nFor the history books, now at https://github.com/jimdigriz/oauth2-worker",
          "createdAt": "2022-11-07T10:13:06Z",
          "updatedAt": "2022-11-07T10:13:06Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU3MTM5NTMwNTg=",
      "title": "Clarify \"JS apps with a backend\"",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/4",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> When differentiating between the 3 \u201cApplication Architecture Patterns\u201d, it would be very helpful if an example is given for each pattern so that readers better understand which pattern applies to them. For example, in 6.2, when it says \u201cJavaScript Applications with a Backend\u201d, it is possible to interpret that as the \u201cbackend\u201d meaning the application\u2019s API.",
      "createdAt": "2020-10-02T23:33:28Z",
      "updatedAt": "2022-03-07T23:08:17Z",
      "closedAt": "2022-03-07T23:08:17Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU4ODY4NzQ2OTI=",
      "title": "Update draft to cover latest changes of the security BCP",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/6",
      "state": "CLOSED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## PR #7:\r\n\r\n- [x] Mix-up mitigations\r\n- [x] Updated references to security BCP\r\n\r\n## Todo:\r\n\r\n- [x] Implicit grant: Is not forbidden in security BCP.\r\n[Security BCP](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-2.1.2-3): `clients SHOULD NOT use the implicit grant`\r\n[Draft](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-9.8): `Authorization servers MUST NOT issue access tokens in the authorization response` (Section )\r\n\r\n- [x] Refresh tokens: Different guidance on expiration.\r\n[Security BCP](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-2.1.2-3): `Refresh tokens SHOULD expire if the client has been inactive for some time, i.e., the refresh token has not been used to obtain fresh access tokens for some time. The expiration time is at the discretion of the authorization server.`\r\n[Draft](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-2.1.2-3): `[AS] MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time`\r\nAlso the security BCP does not say anything about this part: `MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token`\r\n\r\n- [x] Refresh token rotation: Security BCP requires PoP RTs or using RT rotation. Draft recommends RT rotation.\r\n[Security BCP](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-4.13.2-4): `Authorization server MUST utilize one of these methods [...] Sender-constrained refresh tokens [...] Refresh token rotation`\r\n[Draft](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-2.1.2-3): `SHOULD rotate refresh tokens on each use`\r\n\r\n- [x] Update [Overview](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-4) section after all other updates are finished\r\n- [x] Update [Server Support Checklist](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#appendix-A) in appendix after all other updates are finished\r\n\r\nMaybe the first three points should be discussed on the mailing list.",
      "createdAt": "2021-05-11T10:54:49Z",
      "updatedAt": "2022-11-29T03:00:12Z",
      "closedAt": "2022-11-29T03:00:12Z",
      "comments": [
        {
          "author": "kmzs",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For sender-constraining refresh tokens the security BCP only mentions mTLS and Token Binding in [Section 4.13.2](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-4.13.2-5.1.1). It should also mention DPoP there as DPoP is mentioned in [Section 4.9.1.1.2](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-18.html#section-4.9.1.1.2-5.2.1) for `sender-constraining for access and refresh tokens`.\r\n\r\nThis draft should mention sender-constraining RTs using DPoP as an alternative for RT rotation.",
          "createdAt": "2021-05-11T11:19:05Z",
          "updatedAt": "2021-05-11T11:27:08Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I went ahead and updated the refresh token rotation issue to match the security BCP. For some reason draft 07 changed it from \"MUST\" to \"SHOULD\", but I can't find any notes in the meeting minutes or mailing list that motivated that change. So instead I updated it to match the current security BCP text: MUST either use refresh token rotation or sender-constrained refresh tokens.",
          "createdAt": "2021-05-18T01:04:06Z",
          "updatedAt": "2021-05-18T01:04:06Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I believe it was intentional to have the refresh token expiration be more strict in this draft compared to the security BCP. I've added the sentence about not extending the refresh token lifetime.",
          "createdAt": "2021-05-18T01:06:33Z",
          "updatedAt": "2021-05-18T01:06:33Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Same with the implicit grant, it was intentional that the browser-based app spec is more strict than the Security BCP in that instance.",
          "createdAt": "2021-05-18T01:11:02Z",
          "updatedAt": "2021-05-18T01:11:02Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This should be caught up now. Will probably have to do one more pass once the Security BCP is finished but I'll close this for now.",
          "createdAt": "2022-11-29T03:00:12Z",
          "updatedAt": "2022-11-29T03:00:12Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOCUe3lM5Ok9S1",
      "title": "Add reference to TMI BFF as an additional variation on the BFF pattern",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/14",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-bertocci-oauth2-tmi-bff/\r\n",
      "createdAt": "2022-07-26T14:15:47Z",
      "updatedAt": "2022-09-12T21:52:19Z",
      "closedAt": "2022-09-12T21:52:19Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Discussed in the side meeting: we'll start by describing the pattern (without defining the endpoints, and without actually referencing the expired draft), bring that to the next meeting, and see if there is further interest.",
          "createdAt": "2022-07-28T18:51:08Z",
          "updatedAt": "2022-07-28T18:51:08Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOCUe3lM5YSqlS",
      "title": "BFF proxy storing access tokens in browser as `HttpOnly` cookies",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/22",
      "state": "CLOSED",
      "author": "johakoch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In some cases, the BFF proxy itself may not be able to store access tokens, e.g. if it is a load-balanced gateway without a centralized persistence layer. However, the BFF proxy can make the browser store the tokens as `HttpOnly` cookies (with a configurable `Path`) by adding a `Set-Cookie` response header.\r\n\r\nWhat do you think?",
      "createdAt": "2022-12-07T08:07:42Z",
      "updatedAt": "2023-06-29T23:19:38Z",
      "closedAt": "2023-06-29T23:19:38Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Sounds like a reasonable middle ground, noting that you do lose out on some protections of avoiding the tokens ever hitting the browser.",
          "createdAt": "2023-03-13T19:02:15Z",
          "updatedAt": "2023-03-13T19:02:15Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Now that I think about it, a better option would be to encrypt the tokens with a key known only to the proxies, that way the token value itself is never available to the browser. \r\n\r\nI don't know if this needs to be called out specifically, since this type of \"encrypted-cookie-as-stateless-storage\" pattern is pretty commonplace.",
          "createdAt": "2023-03-13T19:06:31Z",
          "updatedAt": "2023-03-13T19:06:31Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOCUe3lM50tMuk",
      "title": "6.1.4.3 Suggestion: change text and remove significant burden ",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/25",
      "state": "CLOSED",
      "author": "damienbod",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "6.1.4.3. \r\n\r\n_Additionally, this pattern requires all interactions between the JavaScript application and the resource servers to be proxied by the BFF, which puts a significant burden on the server-side component._\r\n\r\nI usually use the BFF architecture without requiring a downstream API or a resource server and thus no proxy is required.  My server logic is deployed as part of the BFF server application.  \r\n",
      "createdAt": "2023-10-23T20:53:23Z",
      "updatedAt": "2024-02-22T17:26:47Z",
      "closedAt": "2024-02-22T17:26:46Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "That sounds like that falls under the \"Not Using OAuth\" model: https://www.ietf.org/archive/id/draft-ietf-oauth-browser-based-apps-15.html#name-single-domain-browser-based",
          "createdAt": "2023-10-23T20:57:24Z",
          "updatedAt": "2023-10-23T20:57:24Z"
        },
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @aaronpk yes it does sound like this, but I'm a bit confused because this is in the \"Discouraged and Deprecated Architecture Patterns\"  I still use OIDC (Confidential client Code flow with PKCE)\r\n\r\nThis is in effect the BFF without a downstream API. If I need a downstream API, then I add a proxy and request the scope when required. I see the proxy, downstream API as an add-on to the BFF. ",
          "createdAt": "2023-10-23T21:16:16Z",
          "updatedAt": "2023-10-23T21:19:49Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Can you elaborate on that? Are you using OIDC only for user authentication, e.g. no access tokens involved then? I'm trying to figure out how your use of OIDC/OAuth fits in when there is no API.",
          "createdAt": "2023-10-23T21:20:28Z",
          "updatedAt": "2023-10-23T21:20:28Z"
        },
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. The UI and the backend are authenticated as one using OIDC against any third party IDP etc. The session is stored in the form of a cookie as described in the doc. The APIs uses cookie authentication like the BFF. The backend APIs implement the business logic directly and there is no need for further API calls to different domains. Authz still needs a solution. If I need to use separate APIs on different domains, then I implement OAuth and add new scopes as required. At this point I would add the proxy, or just implement a Http Client. I don't always require a delegated user access token for the downstream APIs. I usually get an AT back from the OIDC server and can persist the claims to the cookie session as required. \r\n\r\nSo this is the BFF pattern described in section 6.1.1. The resource server part is not separated \"always\" from the BFF part, only when required.\r\n\r\nThis removes the  \"significant burden on the server-side component\"\r\n\r\nSection **6.1.2.4.  Deployment Scenarios** already mentions this pattern as well:\r\n\r\n_Serving the static JavaScript code is a separate responsibility from handling OAuth tokens and proxying requests. In the diagram presented above, the BFF and static web host are shown as two separate entities. In real-world deployment scenarios, these components can be deployed as a single service (i.e., the BFF serving the static JS code), as two separate services (i.e., a CDN and a BFF)_",
          "createdAt": "2023-10-23T21:32:57Z",
          "updatedAt": "2023-10-23T22:03:59Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk This discussion is related to our discussion when we restructured the document. The \"no oauth\" model is indeed valid and would just rely on a session between the frontend and the \"API\" to keep track of user's authentication state.\n\nBack then, we weren't sure if this was discouraged, but agreed that it is not a core pattern of this spec, since it focuses on API-access with access tokens.\n\nTwo options: Either we rename this entire section (not my favorite), or we move the \"no oauth\" pattern upwards to section 4.\n\nLet me know what you think",
          "createdAt": "2023-11-21T16:15:07Z",
          "updatedAt": "2023-11-21T16:15:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This sounds like what's described [in 6.1.2.4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.1.2.4)\r\n\r\n> an application relying on both internal and external resource servers can choose to host the internal resource server alongside the BFF. In that scenario, requests to the internal resource server are handled directly at the BFF, without the need to proxy requests over the network.\r\n\r\nThe intent of the \"significant burden\" line is to capture the difficulty in deploying this pattern at scale. Perhaps there is a better way to phrase it. The same difficulty applies whether the resource server is internal to the backend or if it calls external resources. The point is you have to deal with either more network traffic or doing things like geographically distributing your databases. ",
          "createdAt": "2024-02-13T18:52:22Z",
          "updatedAt": "2024-02-13T18:52:22Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have [proposed](https://github.com/oauth-wg/oauth-browser-based-apps/pull/36)  a slight rewording to resolve this issue according to comments made by @aaronpk and @damienbod ",
          "createdAt": "2024-02-18T10:19:17Z",
          "updatedAt": "2024-02-18T10:19:17Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you, closing as PR #36 resolves this.",
          "createdAt": "2024-02-22T17:26:46Z",
          "updatedAt": "2024-02-22T17:26:46Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOCUe3lM50td4Y",
      "title": "Suggestion: add new section 6.1.3.3.3. Use Anti-forgery cookies",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/26",
      "state": "CLOSED",
      "author": "damienbod",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Because the UI and the backend APIs can be hosted from the same backend application, Anti-forgery tokens can also be used to protect against CSRF.",
      "createdAt": "2023-10-23T21:46:41Z",
      "updatedAt": "2024-02-21T21:36:20Z",
      "closedAt": "2024-02-21T21:36:20Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are indeed various CSRF defenses that could be used in this architecture. The two options discussed in the current document explicitly focus on defenses that are part of the core web platform, and require minimal effort from the developer to implement. \n\nThe use of anti-forgery cookies requires code on both the frontend and the backend to guarantee their effectiveness.\n\nAre there benefits to using anti-forgery cookies over samesite cookies/CORS that we're missing?\n",
          "createdAt": "2023-11-21T16:11:35Z",
          "updatedAt": "2023-11-21T16:11:35Z"
        },
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought it would be good to add this as it is per default supported in some tech stacks and so easy to use. People reading the doc might read it as only the mentioned ways protect against CSRF. Adding this would make the recommendations more complete.\r\n\r\n\u201cAre there benefits to using anti-forgery cookies over samesite cookies/CORS that we're missing?\u201d\r\n\r\nIn my opinion, there are no benefits compared with the other two options, just another option. Samesite cookies/ anti-forgery cookies are also a viable option. If the used tech stack has this already supported per default, then there is less to do as a developer. This would make it an option.\r\n",
          "createdAt": "2023-11-21T18:40:16Z",
          "updatedAt": "2023-11-21T18:40:16Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@damienbod  I am open to listing out this option as well for the scenario you mention. Do you have text you could suggest that captures this?",
          "createdAt": "2024-02-13T18:54:10Z",
          "updatedAt": "2024-02-13T18:54:10Z"
        },
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @aaronpk I'll write something\r\n\r\nKind regards Damien",
          "createdAt": "2024-02-17T07:23:04Z",
          "updatedAt": "2024-02-17T07:23:04Z"
        },
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk @philippederyck \r\n\r\nI created a PR with an initial draft. I don't think we should explain how it works because this is not the scope of this doc. \r\n\r\nkind regards Damien",
          "createdAt": "2024-02-18T07:24:25Z",
          "updatedAt": "2024-02-18T07:24:25Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOCUe3lM50tf5f",
      "title": "security advantage BFF makes nonce based CSP possible",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/27",
      "state": "CLOSED",
      "author": "damienbod",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure where this belongs, but I think it would be good to add it. \r\n\r\nBecause the BFF APIs and the UI can be hosted in the same application, it is easy  to implement a nonce based CSP for the UI scripts and styles. Modern JS framework now support this. This is very easy to implement when using BFF security architecture where the same application is used to host the APIs and the UI .",
      "createdAt": "2023-10-23T21:53:55Z",
      "updatedAt": "2023-11-21T18:40:37Z",
      "closedAt": "2023-11-21T18:40:37Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The use of CSP nonces requires the ability to insert a fresh nonce on every page load. \n\nWhile this is indeed possible by hosting the HTML page of the frontend application (SPA) on the BFF, it is not required to deploy a frontend this way. It is a perfectly valid pattern to deploy the SPA on a CDN and have it call the dynamic BFF component. In that case, nonces would not work, but hashes might.\n\nGiven that this advice is highly specific for CSP and less related to the BFF pattern, I'd opt to not go into these details in this spec.",
          "createdAt": "2023-11-21T16:04:06Z",
          "updatedAt": "2023-11-21T16:04:06Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOCUe3lM5-gK-_",
      "title": "6.1.3.2 Question: benefits of encrypting cookie contents in BFF security",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/31",
      "state": "CLOSED",
      "author": "nike61",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I was unable to find an explanation for the following point:\r\n_Additionally, the BFF SHOULD encrypt its cookie contents, to ensure that tokens stored in cookies are never written to disk in plaintext format. This security measure helps to ensure protection of the access token against malware that actively scans the user's hard drive to extract sensitive browser artifacts, such as cookies and locally stored data (see Section 8)._\r\n\r\nWhat is the advantage of encrypting cookies? If a malicious actor steals the cookie as plain text, couldn't they just send the entire cookie in a request?",
      "createdAt": "2024-02-07T07:30:57Z",
      "updatedAt": "2024-02-13T22:51:55Z",
      "closedAt": "2024-02-13T22:51:55Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "emphasis mine:\r\n\r\n> Additionally, the BFF SHOULD encrypt its cookie contents, to ensure that **tokens stored in cookies** are never written to disk in plaintext format. This security measure helps to ensure protection of the **access token** against malware...\r\n\r\nI believe this is meant to be an additional layer of security when the cookie actually contains the access token. While someone who steals the cookie can use the cookie regardless of whether the contents are encrypted, they can only use it at the BFF, whereas the access token itself might be able to be used elsewhere. I will add some text to clarify this.",
          "createdAt": "2024-02-13T21:46:53Z",
          "updatedAt": "2024-02-13T21:46:53Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOCUe3lM5_KnbF",
      "title": "DPoP",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/32",
      "state": "CLOSED",
      "author": "criztovyl",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> The application can use DPoP to ensure its access tokens are bound to non-exportable key linked to the browser.\r\n\r\nthis reads strange, not sure, but is there an \"a\" or \"s\" missing?\r\n\r\n> [...] bound to ***a*** non-exportable key linked to the browser.\r\n\r\n> [...] bound to non-exportable key***s*** linked to the browser.\r\n\r\nhttps://github.com/oauth-wg/oauth-browser-based-apps/blob/11ee6bc7997b3226c140fca219b9bcb629188089/draft-ietf-oauth-browser-based-apps.md?plain=1#L322",
      "createdAt": "2024-02-14T03:45:23Z",
      "updatedAt": "2024-02-17T00:21:44Z",
      "closedAt": "2024-02-17T00:21:44Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Good catch, thanks",
          "createdAt": "2024-02-17T00:16:22Z",
          "updatedAt": "2024-02-17T00:16:22Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Fixed in c593337de1055185b9d41783bf3e16ac922f9231",
          "createdAt": "2024-02-17T00:21:44Z",
          "updatedAt": "2024-02-17T00:21:44Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOCUe3lM5_m5mK",
      "title": "Follow up on review for merged PR",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/35",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PR #30 merges a bunch of changes suggested by @panva. After merging, I have added [a couple of notes](https://github.com/oauth-wg/oauth-browser-based-apps/pull/30#pullrequestreview-1887186225) that require following up. This issue is to keep track of that work.",
      "createdAt": "2024-02-18T10:09:29Z",
      "updatedAt": "2024-02-28T23:05:43Z",
      "closedAt": "2024-02-28T23:05:43Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you!",
          "createdAt": "2024-02-28T23:05:43Z",
          "updatedAt": "2024-02-28T23:05:43Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOCUe3lM6DYVBb",
      "title": "Consistently use *applications* or *apps*",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/42",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In his review, Justin Richer pointed out that the spec inconsistently uses both the term *applications* and *apps* in the title and the document. It makes sense to settle for one and be consistent about it. \r\n\r\nMy vote goes to *applications*, which is most common in the context of web applications. *Apps* is more related to native/mobile apps. \r\n\r\nA quick Google search on *Angular apps* vs *Angular applications* or *js apps* vs *js applications* also indicates that applications is more common. \r\n\r\nWhen not updating, include *applications* vs *apps* in the terminology section.",
      "createdAt": "2024-03-24T05:47:29Z",
      "updatedAt": "2024-04-11T04:52:25Z",
      "closedAt": "2024-04-11T04:52:25Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "+1 for \"applications\"",
          "createdAt": "2024-03-26T00:20:25Z",
          "updatedAt": "2024-03-26T00:20:25Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOCUe3lM6DYZrC",
      "title": "Properly render sublists",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/43",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5.1.2 contains a sublist, but it is not rendered properly\r\n\r\n```\r\n### Persistent Token Theft {#payload-persistent-theft}\r\n\r\nThis attack scenario is a more advanced variation on the Single-Execution Token Theft scenario ({{payload-single-theft}}). Instead of immediately stealing tokens upon the execution of the malicious payload, the attacker sets up the necessary handlers to steal the application's tokens on a continuous basis. This scenario consists of the following steps:\r\n\r\n- Execute malicious JS code\r\n- Setup a continuous token theft mechanism (e.g., on a 10-second time interval)\r\n\t  - Obtain tokens from the application's preferred storage mechanism (See {{token-storage}})\r\n\t  - Send the tokens to a server controlled by the attacker\r\n\t  - Store the tokens\r\n- Wait until the opportune moment to abuse the latest version of the stolen tokens\r\n\r\nThe crucial difference in this scenario is that the attacker always has access to the latest tokens used by the application. This slight variation in the payload already suffices to counter typical defenses against token theft, such as short lifetimes or refresh token rotation.\r\n\r\nFor access tokens, the attacker now obtains the latest acce\r\n```",
      "createdAt": "2024-03-24T06:54:28Z",
      "updatedAt": "2024-05-01T17:10:56Z",
      "closedAt": "2024-05-01T17:10:56Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk I don't know where to find an updated draft from #45, so I cannot check if this now renders correctly. It should though ...",
          "createdAt": "2024-04-11T05:09:12Z",
          "updatedAt": "2024-04-11T16:03:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Yep looks good now \r\n<img width=\"647\" alt=\"image\" src=\"https://github.com/oauth-wg/oauth-browser-based-apps/assets/113001/e453c98c-11c1-4db7-b75b-b1d2f0c22344\">\r\n",
          "createdAt": "2024-05-01T17:10:56Z",
          "updatedAt": "2024-05-01T17:10:56Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOCUe3lM6DYnD2",
      "title": "Address outstanding comments from Justin Richer",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/44",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Issues from Justin Richer's review that need to be addressed\r\n\r\n### Details\r\n\r\n> \u00a75 is the bold formatting really necessary to make this point?\r\n\r\n__Comment__: Leave it for now, see what happens during review\r\n\r\n\r\n> \u00a76.1 what does \"Payload\" refer to here? The sections above are not referred to as \"Payloads\" in the titles\r\n\r\n- [x] Update refs \"Payload Section XXX\" to the name of the actual attack scenario with a simple reference to the section (Without any text content)\r\n- [x] Refer to them as \"attack scenarios\" instead of payloads throughout the document\r\n- [x] Also look for \"attack scenarios\" and make them consistent\r\n\r\n\r\n\r\n> diagram nit: suggest using aasvg or similar tooling instead of plain ASCII\r\n\r\n- [x] Create an issue for Aaron\r\n\r\n\r\n> \u00a76.1 diagram nit: this might read better as a vertical time sequence diagram, with concise labels on the arrows\r\n\r\n__Comment:__ The diagrams show the deployment quite well, so we decided to keep them as is.\r\n\r\n\r\n> \u00a76.1.2.1 are these items \"recommended\" or \"RECOMMENDED\"? ie, is this intentionally informative?\r\n\r\n- [x] Refer to 4.14 from the security bcp\r\n- [x] Rephrase to avoid giving a recommendation on refresh tokens\r\n- [x] Apply the same changes to 6.2.2.1.\r\n\r\n\r\n\r\n> \u00a76.1.3.2 \r\n> Why is AEAD the only encryption method called out here? What's particularly special about this algorithm? \r\n> \r\n> There are no requirements for key management. It's obvious to a seasoned developer or security engineer that the BFF holds the decryption keys and doesn't give them out but that's never talked about. Are there any other considerations? Like, is it OK for the BFF to use the same encryption keys with each client? Does the key need to be identified? \r\n\r\n- [x] Avoid the algo language\r\n- [x] Update language to make clear cookie is not being prevented from being extracted\r\n- [x] Also mention that the stolen cookie can still be used\r\n\r\n\r\n> \u00a76.1.3.3.2  \u00b66 it is considered bad practice to create `X-` header field names, and probably even worse practice to recommend making up an unregistered and ignored header field name just to force CORS. I don't think this is good and actionable advice and will likely run afoul of the HTTP directorate review during publication. If this actually does need to be kept, perhaps seek out advice from HTTP WG?\r\n\r\n- [x] Add language that states the BFF has to check the static header\r\n- [x] Rename the custom header to `My-Static-Header` and make very clear this is just an example\r\n\r\n\r\n> \u00a76.2.1 question, is the \"Editor's note\" intended to survive to the full RFC? it seems useful reference if sufficiently caveated\r\n\r\n- [x] Keep it in, but rephrase this as \"an early draft documenting this concept\"\r\n\r\n\r\n> \u00a76.2.4.3.1 this \"note\" is pretty serious and deserves more than a note in terms of attention\r\n\r\nI have reworded this slightly, but this is quite inherent to the nature of the pattern. Not sure how to put more emphasis on it and whether it is needed.\r\n\r\n- [x] Add more language to make explicit that the malicious JS code can get it from the endpoint. This should be the same language as for a browser-basaed app with a new flow\r\n\r\n\r\n> the advice on refresh token expiration seems confusing at first read, particularly if my lifetime is based on use in the first place. What is this advice in the last bullet trying to prevent?\r\n\r\nDo you think this sentence needs rewording: \"when issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the original refresh token if the refresh token has a preestablished expiration time\"?\r\n\r\n- [x] There should be an implementation details (6.3.2)\r\n- [x] First sentence of 6.3.2.1 moves up as the intro. The rest of 6.3.2.1 is removed (but not the subsections)\r\n- [x] CSRF and RT go to implementation details\r\n- [x] Security considerations become 6.3.2.3, 6.3.2.4, 6.3.2.5, CORS\r\n- [x] Move the sentence with \"limiting the overall...\" above the example in the text\r\n\r\n\r\n> \u00a76.3.2.2\r\n> again this restriction to public clients predates several specs that remove it and the advice shouldn't be parroted here. better to say that they usually are going to be public because of the problem of registering a client ID and storing a secret of any kind at configuration time associated with that client ID.\r\n\r\n- [x] Drop 6.3.2.2\r\n\r\n> \u00a76.3.2.7 \r\n> aren't these the same requirements as above in \u00a76.3.2.1? Does it need to be listed as requirements in both places? Are they identical?\r\n\r\n__Comment:__ Addressed by the restructuring above\r\n\r\n> \u00a76.3.2.8\r\n> \u00b62 what is a \"proper CORS configuration\" as per this spec? I don't think we have quite enough details to require that as such.\r\n\r\n- [x] Replace \"proper\" with \"necessary\"\r\n- [x] Replace \"allows\" with \"enable\"\r\n\r\n> \u00a79 security considerations sections should be about \"why\" and really shouldn't have normative requirements, please remove them from the subsequent sections\r\n\r\n- [x] Everything is fine, except for mixup attacks. Only keep first and last sentence with the ref to the BCP and we are good\r\n\r\n\r\n> \u00a7A it feels wrong to have normative requirements in an appendix (point 7), and points 2 and 3 both have a weird uppercase NOT which isn't a keyword\r\n\r\n- [x] Drop appendix A\r\n\r\n\r\n> \u00a79+ this draft should add privacy considerations, particularly for BFF pattern's proxy architecture.e\r\n> I think it does warrant mentioning, because the main assumptions about an spa are that everything goes from the browser to the api itself. It might be surprising to a user or even a naive developer that every request goes through another party as a black box. Even if it's all first party abd deployed together, that model should be called out by the draft as an assumption for privacy. After all, this section is for considerations - things you should think about that might not be obvious. \r\n\r\n- [x] Add a new item under security considerations of the BFF to discuss prviacy considerations. Mainly relevant for off the shelf BFF libraries / components (e.g. offered by Cloudlfare) that may now see all customer data. A third party could observe all the data",
      "createdAt": "2024-03-24T09:39:43Z",
      "updatedAt": "2024-04-11T16:02:27Z",
      "closedAt": "2024-04-11T16:02:26Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All resolved in #45 ",
          "createdAt": "2024-04-11T16:02:26Z",
          "updatedAt": "2024-04-11T16:02:26Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOCUe3lM6FVTXP",
      "title": "Add BCP references to the normative section",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/48",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding BCP references by including the items below in the list of normative references breaks the build. \r\n\r\n```\r\n-  BCP14:\r\n-  BCP212:\r\n```\r\n\r\n### Tasks to solve this issue\r\n\r\n- [ ] Add the references in the normative section the right way\r\n- [ ] Re-add the references in the text (search for BCP14/BCP212 and add a reference)\r\n",
      "createdAt": "2024-04-11T05:44:03Z",
      "updatedAt": "2025-01-17T02:46:32Z",
      "closedAt": "2025-01-17T02:46:31Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This is fixed in 639b69dc9e0dd98890da3b03d3bd209c6bc2f7f7 by using `RFC2119 RFC8174` instead of `BCP14`, and `RFC8252` instead of `BCP212`",
          "createdAt": "2025-01-17T02:46:31Z",
          "updatedAt": "2025-01-17T02:46:31Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOCUe3lM6FX1eA",
      "title": "Draw diagrams with tools instead of raw ASCII",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/49",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Use `aasvg` or similar tooling instead of plain ASCII for diagrams",
      "createdAt": "2024-04-11T12:30:34Z",
      "updatedAt": "2024-05-01T17:09:49Z",
      "closedAt": "2024-05-01T17:09:49Z",
      "comments": []
    },
    {
      "number": 51,
      "id": "I_kwDOCUe3lM6HshJ2",
      "title": "Working Group Last Call",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/51",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder issue for working group last call comments. If you have any minor comments, feel free to add them below. If you have reviewed the draft and have no comments, please note below that you are happy with the current draft! If you have any substantial comments, feel free to open them as a new issue.",
      "createdAt": "2024-05-02T22:15:55Z",
      "updatedAt": "2024-12-17T23:03:49Z",
      "closedAt": "2024-12-17T23:03:49Z",
      "comments": [
        {
          "author": "rossajmcd",
          "authorAssociation": "NONE",
          "body": "Looks good to me, thanks for all the hard work.",
          "createdAt": "2024-05-03T07:36:20Z",
          "updatedAt": "2024-05-03T07:36:20Z"
        },
        {
          "author": "sdesen",
          "authorAssociation": "NONE",
          "body": "Looks good to me! Great work.",
          "createdAt": "2024-05-09T21:45:34Z",
          "updatedAt": "2024-05-09T21:45:34Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks, closing this as the Working Group Last Call has finished, and the shepherd writeup is now in progress",
          "createdAt": "2024-12-17T23:03:49Z",
          "updatedAt": "2024-12-17T23:03:49Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOCUe3lM6IAiJv",
      "title": "Fragments, performance, and historic notes.",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/52",
      "state": "CLOSED",
      "author": "will-bartlett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 7.2.1, \"historic note\", the current draft says:\r\n\r\n> Historically, the Implicit grant type provided an advantage to browser-based applications since JavaScript could always arbitrarily read and manipulate the fragment portion of the URL without triggering a page reload. This was necessary in order to remove the access token from the URL after it was obtained by the app.\r\n\r\n> [...] Modern browsers now have the Session History API [...] which provides a mechanism to modify the path and query string component of the URL without triggering a page reload.\r\n\r\nThe historic note is missing some context. Had RFC 6749 recommended query responses for browser-based apps, there would have been the additional page load AND an additional app download. Additionally, the document as a whole makes no mention of `response_type=fragment`. \r\n\r\nConsider the following sequence of requests (\"the authorization code flow\"):\r\n 1. User navigates to https://contoso.com/\r\n 2. Contoso redirects the user to the OAuth provider https://oauth.example/authorize?parameters.\r\n 3. The OAuth provider navigates back to Contoso with https://contoso.com?code=foobar\r\n 4. Contoso clears the code from the URL bar, navigating to https://contoso.com\r\n\r\nWhen RFC 6749 was published, this flow would have included:\r\n - Three navigations (1=>2, 2=>3, 3=>4)\r\n - Two downloads of the browser-based application (1 and 3) - 4 would have hit the cache entry created by 1.\r\n\r\nCompare to the implicit flow:\r\n 1. User navigates to https://contoso.com/\r\n 2. Contoso redirects the user to the OAuth provider https://oauth.example/authorize?parameters.\r\n 3. The OAuth provider navigates back to Contoso with https://contoso.com#token=foobar\r\n 4. Contoso clears the code from the URL bar, navigating to https://contoso.com\r\n\r\nWhen RFC 6749 was published, this flow would have included:\r\n - Two navigations (1=>2, 2=>3)\r\n - One download of the browser-based application (1) - 3 would have hit the cache entry created by 1, and 4 does not create a network request.\r\n\r\nThe document as it currently stands seems to recommend the authorization code flow as described by RFC 6749 (with query response). In today's world, that flow includes:\r\n - Two navigations (1=>2, 2=>3)\r\n - Two downloads of the browser-based application (1 and 3) - 4 does not make a network request.\r\n\r\nMicrosoft Entra (and other OpenID Connect providers) rely on the [OAuth 2.0 Multiple Response Type Encoding Practices\r\n](https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html) standard and use the authorization code flow in combination with response_mode=fragment. That looks like this:\r\n 1. User navigates to https://contoso.com/\r\n 2. Contoso redirects the user to the OAuth provider https://oauth.example/authorize?parameters.\r\n 3. The OAuth provider navigates back to Contoso with https://contoso.com#code=foobar\r\n 4. Contoso clears the code from the URL bar, navigating to https://contoso.com\r\n\r\nThis flow includes:\r\n - Two navigations (1=>2, 2=>3)\r\n - One download of the browser-based application (1) - 3 would have hit the cache entry created by 1, and 4 does not create a network request.\r\n\r\nProblem summary:\r\n 1. The document as it currently stands (without mention of response_mode=fragment) recommends a version of OAuth for browser-based apps that is less performant than the implicit flow recommended by RFC 6749.\r\n 2. The historic note only mentions one of the two reasons RFC 6479 recommended the implicit flow for browser based apps. Those two reasons are: reduced navigations AND reduced downloading.\r\n\r\nSuggestions:\r\n - The document should definitely mention response_mode=fragment. The document should probably either recommend or recommend against response_mode=fragment (I think: recommend).\r\n - The historic note should explain both the motivations for the implicit flow and why neither applies (session history AND response_mode=fragment). ",
      "createdAt": "2024-05-06T21:48:50Z",
      "updatedAt": "2025-01-17T02:47:57Z",
      "closedAt": "2025-01-17T02:47:57Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the details.\r\n\r\nJust to note, `response_mode=fragment` only applies to the third architectural pattern ([section 6.3](https://drafts.oauth.net/oauth-browser-based-apps/draft-ietf-oauth-browser-based-apps.html#section-6.3)), since the other two are server backend flows.\r\n\r\n> The document should definitely mention response_mode=fragment. The document should probably either recommend or recommend against response_mode=fragment (I think: recommend).\r\n\r\nIt seems like your suggestion on https://github.com/oauthstuff/draft-ietf-oauth-security-topics/issues/97 was to include a mention that this response mode is also susceptible to one of the attacks on the implicit flow. Did you mean to say that the Browser BCP should also not recommend response_mode=fragment then?\r\n\r\n> The historic note should explain both the motivations for the implicit flow and why neither applies (session history AND response_mode=fragment).\r\n\r\nCan you suggest a sentence to include that describes why response_mode=fragment doesn't apply anymore?\r\n\r\n",
          "createdAt": "2024-05-11T00:40:52Z",
          "updatedAt": "2024-05-11T00:41:50Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Hi @will-bartlett just wanted to check on this again",
          "createdAt": "2024-05-20T15:14:02Z",
          "updatedAt": "2024-05-20T15:14:02Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Closing due to lack of a response and since this is in \"Submitted to IESG for Publication\" status",
          "createdAt": "2025-01-17T02:47:57Z",
          "updatedAt": "2025-01-17T02:47:57Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOCUe3lM6KnLp5",
      "title": "Discussing the usage of localStorage/sessionStorage for session management",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/53",
      "state": "CLOSED",
      "author": "randomstuff",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The BFF and the Token Mediating pattern assume that *cookies* are used for user session tracking:\r\n\r\n> The BFF relies on traditional browser cookies to keep track of the user's session, which is used to access the user's tokens.\r\n\r\n> Similar to the BFF, the token-mediating backend relies on traditional browser cookies to keep track of the user's session.\r\n\r\nSome applications (SPAs) might want to rely on storing a session token in `localStorage`/`sessionStorage` and use `Authorization: Bearer` for passing the session token to the backend. Should some wording discussing this be included?\r\n\r\nThis is only discussed in the context of the storage of the access/refresh tokens in the browser (for the token mediating backed and browser-based OAuth 2.0 client patterns).",
      "createdAt": "2024-05-30T12:11:26Z",
      "updatedAt": "2024-12-18T20:49:08Z",
      "closedAt": "2024-12-18T20:49:08Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Only by using cookies as discussed in the document can you get the security guarantees offered by the BFF. Making the BFF session data accessible to JavaScript would negate the majority of the security benefits of the BFF. There would also be little to no technical reason to do this, since cookies are universally supported by browsers and do not require any code. ",
          "createdAt": "2024-05-30T15:40:19Z",
          "updatedAt": "2024-05-30T15:40:19Z"
        },
        {
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "body": "> Only by using cookies as discussed in the document can you get the security guarantees offered by the BFF.\r\n\r\n> The BFF interacts with the authorization server as a confidential OAuth client\r\n\r\nThe client credentials are still not exposed to the user agent and the client.\r\n\r\n> The BFF manages OAuth access and refresh tokens in the context of a cookie-based session, avoiding the direct exposure of any tokens to the JavaScript application\r\n\r\nYou still wouldn't expose the OAuth access/refresh tokens which would otherwise be visible by the frontend (i.e. by the frontend code and by the actual end user).\r\n\r\n> There would also be little to no technical reason to do this, since cookies are universally supported by browsers and do not require any code.\r\n\r\nHttpOnly cookies are isolated from frontend JavaScript and therefore protected from exfiltration through XSS. However, they are are (still) not origin-bound which makes them vulnerable from cross-origin/same-domain injection (such as session fixation).\r\n\r\n* You can use `__Host-` cookies to protect against cross-origin/same-domain cookie injection but this is very rarely used in practice <del>and would not work if the frontend and the backend are in different origins</del>.\r\n* You can use `__Secure-` cookies to protect against cookie injection from non-secured origins in the same domain.\r\n\r\nlocalStorage is origin-bound and is inherently protected from these things.\r\n\r\nI'm not sure that this would really negate the majority of the security benefits of the BFF.",
          "createdAt": "2024-05-30T16:43:07Z",
          "updatedAt": "2024-05-30T21:00:15Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The client credentials are still not exposed to the user agent and the client.\r\n> \r\n> You still wouldn't expose the OAuth access/refresh tokens which would otherwise be visible by the frontend (i.e. by the frontend code and by the actual end user).\r\n\r\nYes, that's true, but the security properties are still worse than having a cookie-based BFF solution. As described in the spec, the BFF reduces the attack surface to a *client hijacking* attack (in an __online__ fashion, where the attack only works as long as the application is active). By having the session accessible to the frontend (and thus malicious JS), you would enable a scenario that is best described as __offline__ client hijacking. The attacker would be able to steal the BFF's session data and abuse it for as long as the session is active, even after the user has closed the application (but not logged out).\r\n\r\nI would even say that the security properties of this setup are worse than using the Token Mediating Backend, since the BFF session is likely longer-lived than the access tokens in a Token Mediating Backend solution. \r\n\r\nConcretely, I don't think this pattern improves anything or warrants a recommendation.\r\n\r\n\r\n> > There would also be little to no technical reason to do this, since cookies are universally supported by browsers and do not require any code.\r\n> \r\n> HttpOnly cookies are isolated from frontend JavaScript and therefore protected from exfiltration through XSS. However, they are are (still) not origin-bound which makes them vulnerable from cross-origin/same-domain injection (such as session fixation).\r\n> \r\n> * You can use `__Host-` cookies to protect against cross-origin/same-domain cookie injection but this is very rarely used in practice ~and would not work if the frontend and the backend are in different origins~.\r\n> * You can use `__Secure-` cookies to protect against cookie injection from non-secured origins in the same domain.\r\n> \r\n> localStorage is origin-bound and is inherently protected from these things.\r\n> \r\n> I'm not sure that this would really negate the majority of the security benefits of the BFF.\r\n\r\nI don't think these statements help prove your point. I will list a couple of reasons below:\r\n\r\n- The `__Host-` prefix is explicitly recommended by the spec. The fact that it is not often used does not impact its security properties.\r\n- The `__Host-` prefix explicitly prevents setting a cookie from a different domain (i.e., it neutralizes the `Domain` attribute and effectively prevents subdomain-based session fixation)\r\n- Nothing prevents the use of the `__Host-` prefix from being used between two different origins or even domains. The SameSite flag can affect this, and so does third-party cookie blocking, but not the `__Host-` prefix.\r\n- A cookie configured with `__Host-` also requires the `Secure` flag, making them mostly origin-bound (to be precise: ports are part of the origin and are not taken into account with this prefix, but most real-world deployments rely on default ports anyway)\r\n\r\nIf you are not convinced that I am right, I encourage you to try this out in an actual deployment, to help you understand the precise browser behavior. \r\n",
          "createdAt": "2024-05-31T04:20:04Z",
          "updatedAt": "2024-05-31T04:20:04Z"
        },
        {
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "body": "> Concretely, I don't think this pattern improves anything or warrants a recommendation.\r\n\r\nNote that stating this explicitly would actually count as \"discussing the usage of localStorage/sessionStorage for session management\" :) I mean, people will wonder about this and will want to try to implement these patterns using localStorage instead of cookies. It might be a good idea to mention these arguments in a short paragraph (?).\r\n\r\n> If you are not convinced that I am right, I encourage you to try this out in an actual deployment, to help you understand the precise browser behavior.\r\n\r\nYes agreed.\r\n",
          "createdAt": "2024-05-31T07:24:44Z",
          "updatedAt": "2024-05-31T07:24:44Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I definitely agree that these two patterns rely on the security properties of HTTP-only cookies over anything accessible to JavaScript. \r\n\r\nI reviewed the intros to the sections ([Section 6.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-19#section-6.1) and [Section 6.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-19#name-token-mediating-backend)) and I can see how it could be helpful to be even more explicit. Currently these talk about using cookies, but they don't actually describe _why_ until the threat analysis.\r\n\r\nPerhaps adding a sentence to the intro of these sections would help, pointing out that these security properties only apply because of the properties of HTTP-only cookies.",
          "createdAt": "2024-12-17T22:52:14Z",
          "updatedAt": "2024-12-17T22:52:14Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOCUe3lM6jHaNJ",
      "title": "Proposed flow for using DPoP with token mediating backend",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/54",
      "state": "CLOSED",
      "author": "vivshankar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thank you for proposing the OAuth Browser Based Apps spec. I have been thinking specifically about the token mediating backend and wanted to propose a method to use DPoP to secure the token usage.\r\n\r\n## Goal\r\n\r\n- Use DPoP as a mechanism to provide proof of possession when making use of the access token exposed on the untrusted user agent.\r\n\r\n- Prevent an attacker who is able to inject JS in the browser to leverage a SSO session and use their own key-pair to present a DPoP proof to obtain a token.\r\n\r\n\r\n\r\n## Possible approach\r\n\r\n**New session and no token**\r\n\r\n1. `Frontend client` generates a DPoP proof.\r\n\r\n2. `Frontend client` requests for a new token from the `Token Mediating Backend` (also called Token Mediator below). As part of this, the DPoP proof is included as a dpop header.\r\n\r\n3. `Token Mediator` checks that there is no existing session for this browser, so it kicks off a new authcode flow. Auth code flow kicked off with PKCE.\r\n\r\n4. Browser is redirected to the authorize endpoint. User performs authentication and consent. The authcode is generated and included in the redirect back to Token Mediator callback endpoint.\r\n\r\n5. `Token Mediator` calls the token endpoint with the authcode, DPoP proof (provided by the front-end), and a strong client auth method like private_key_jwt.\r\n\r\n6. `Token mediator` recieves and stores the refresh token in a session-bound cache, _along with the the jkt associated with the DPoP proof (effectively binding the client to the session)_. The access token is returned to the Frontend client.\r\n\r\n7. `Frontend client` uses the access token as needed. It will need to include a signed DPoP proof when calling the resource endpoints.\r\n\r\n\r\n**Expired token**\r\n\r\n1. Frontend client generates a DPoP proof signed using the same private key that is used when establishing the token mediator session.\r\n\r\n2. Frontend client calls the get-token API on the Token Mediator with the DPoP proof.\r\n\r\n3. Token Mediator validates that the jkt matches the one in the session.\r\n\r\n4. Token Mediator kicks off a refresh token flow or a new auth code flow (if the refresh token has expired).\r\n\r\n\r\n**Threat model**\r\n\r\nBy binding the jkt associated with the DPoP proof to the session, the session is \u201cbound\u201d to the client. Possible threats:\r\n\r\n1. Attacker injects JS on a client with no session and uses a generated key-pair for the DPoP proof: This leads the user through an authentication, authorization and consent flow, which can be used to mitigate this attack vector. However, there is no real way to prevent this attack if the JS executes before the app requests for the token. In this scenario, when the app does request the token, the flow will fail and the user will see an error message, indicating a possible compromise. Appropriate remediation action can be taken at this point to, for example, log the user out with an appropriate message.\r\n\r\n2. Attacker injects JS after the client has established a session with the mediating backend: Since the session is bound to the jkt of the key used to sign the DPoP proof, this attack will fail.\r\n\r\n\r\nI was hoping to get some thoughts on this proposed approach. This is specifically to solicit opinions for a plausible implementation to address https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.2.4.3.2.",
      "createdAt": "2024-12-12T18:37:15Z",
      "updatedAt": "2024-12-19T02:15:16Z",
      "closedAt": "2024-12-18T20:50:03Z",
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This scenario gives you the benefits of DPoP by having a sender-constrained access token. However, I don't see anything here that significantly changes the security properties of a Token Mediating Backend scenario. \r\n\r\n\r\n> 2. Attacker injects JS after the client has established a session with the mediating backend: Since the session is bound to the jkt of the key used to sign the DPoP proof, this attack will fail.\r\n\r\nWhen this happens, the attacker's code runs in the same execution environment as the frontend's code. So if the frontend has a way to obtain a new access token from the backend, so does the attacker (just like with a BFF, an attacker could send requests to the BFF).\r\n\r\nIn your specific scenario, the attacker would re-use the existing session between the browser and the backend to request a token associated with the initial DPoP proof. It also implies that the attacker can only abuse that token with valid DPoP proofs, which can be obtained through the so-called \"online attack\".\r\n\r\nBased on some wordings (binding a client to a session), it seems that at least part of the attack vector is a session hijacking attack, which is not the same as running malicious JS in the application's execution context in the victim's browser.",
          "createdAt": "2024-12-13T07:45:52Z",
          "updatedAt": "2024-12-13T07:45:52Z"
        },
        {
          "author": "vivshankar",
          "authorAssociation": "NONE",
          "body": "Thanks @philippederyck . The attacker wouldn't have access to the same key-pair used to sign the DPoP proof? This assumes the use of appropriate security best practices to maintain a non-exportable private key. If the attacker were to generate their own key-pair, that won't work given the original jkt is associated with the session.",
          "createdAt": "2024-12-13T16:14:31Z",
          "updatedAt": "2024-12-13T16:15:58Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The private key would indeed be non-exportable, which means neither the frontend nor the attacker has access to it. However, the frontend has a way to obtain a signed DPoP proof to make API calls. Once the attacker gains a foothold, they can now use that exact same mechanism to request a DPoP proof for a malicious API call.",
          "createdAt": "2024-12-15T07:08:38Z",
          "updatedAt": "2024-12-15T07:08:38Z"
        },
        {
          "author": "vivshankar",
          "authorAssociation": "NONE",
          "body": "My proposal is banking on needing user interaction (in the form of authentication and consent) to obtain a session on the token mediating backend. Given the first invocation records the jkt in the session (possibly mapped to the client_id), the attacker using their own jkt on the same browser session will result in a failure. So, session hijacking is covered with this approach. Similarly subsequent token requests are covered as well.",
          "createdAt": "2024-12-16T06:27:09Z",
          "updatedAt": "2024-12-16T06:27:09Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are missing the point. There is no session hijacking (i.e., extracting the user's session), but the attacker takes control of the existing client (i.e., executing malicious code within the client within the victim's browser).\r\n\r\nAs explained in the intro of [section 5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#name-the-threat-of-malicious-jav), the attacker's code has the same privileges as the legitimate frontend client. So when you write `Frontend client generates a DPoP proof signed using the same private key that is used when establishing the token mediator session.`, you have to assume that the attacker can perform those exact same steps. \r\n\r\nThis type of attack is also explicitly covered in [the DPoP spec](https://datatracker.ietf.org/doc/html/rfc9449#name-untrusted-code-in-the-clien).\r\n\r\n",
          "createdAt": "2024-12-16T07:06:02Z",
          "updatedAt": "2024-12-16T07:06:02Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I believe that section 5 and the DPoP spec are sufficient to demonstrate why this proposal doesn't change anything about the security properties.",
          "createdAt": "2024-12-17T22:55:08Z",
          "updatedAt": "2024-12-17T22:55:08Z"
        },
        {
          "author": "vivshankar",
          "authorAssociation": "NONE",
          "body": "@aaronpk @philippederyck Thanks for taking the time.\r\n\r\nThe purpose of my post was to ask if the approach laid out in this proposal is an acceptable implementation pattern for [section 6.2.4.3.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.2.4.3.2). I realize we went a bit afield to that original goal, mostly because of how I phrased the threat model.\r\n\r\nMy proposal is weird in the sense that the party producing the DPoP proof is not the OAuth client (which lives in the token mediating backend) but the token is ultimately used by the party to call into resource APis. Do you see any concerns with the approach that I have put here?",
          "createdAt": "2024-12-19T02:15:15Z",
          "updatedAt": "2024-12-19T02:15:15Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOCUe3lM6jLb_0",
      "title": "Clarify why a BFF belongs to a frontend",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/55",
      "state": "CLOSED",
      "author": "PhilippeDeRyck-Xenit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sometimes, people are not sure why a BFF is not an api gateway. The differentatior is that the BFF is the oauth client, so it belongs to the frontend that represents the client.\r\n\r\nAdding a single line somewhere should help clear this up. This can be assigned to me.",
      "createdAt": "2024-12-13T07:44:26Z",
      "updatedAt": "2024-12-13T07:44:37Z",
      "closedAt": "2024-12-13T07:44:37Z",
      "comments": []
    },
    {
      "number": 56,
      "id": "I_kwDOCUe3lM6jLcxx",
      "title": "Clarify why a BFF belongs to a BFF",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/56",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Sometimes, people are not sure why a BFF is not an api gateway. The differentiator is that the BFF is the oauth client, so it belongs to the frontend that represents the client.\r\n\r\nAdding a single line somewhere should help clear this up. This can be assigned to me.",
      "createdAt": "2024-12-13T07:46:33Z",
      "updatedAt": "2024-12-17T23:05:10Z",
      "closedAt": "2024-12-17T23:05:10Z",
      "comments": []
    },
    {
      "number": 58,
      "id": "I_kwDOCUe3lM6jj5-m",
      "title": "Remove reference to TMI-BFF draft",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/58",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rifaat Shekh-Yusef mentioned the following in a review (mail 13/11/2024):\r\n\r\n> Section 6.2.1\r\n> \u201cNote that an early draft ([tmi-bff]) already documented this concept, although the draft is is currently expired and has not been proposed for adoption to the OAuth Working Group.\u201d\r\n> Is this paragraph really needed? How would that help the implementer?\r\n",
      "createdAt": "2024-12-17T07:02:49Z",
      "updatedAt": "2025-01-17T02:49:17Z",
      "closedAt": "2025-01-17T02:49:16Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I believe this came out of the discussions at IETF 114. After that meeting, we added the TMI-BFF pattern to the draft, and left this reference to a concrete proposal for implementing the pattern. While this draft was not developed further, it could be picked up again in the future, in which case leaving this reference here would give someone the breadcrumb trail to find.",
          "createdAt": "2024-12-17T22:42:17Z",
          "updatedAt": "2024-12-17T22:42:17Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This reference was removed in f1365ae987038e3681c56a9671af60895cb328a0 and replaced by the document replacing tmi-bff in datatracker.",
          "createdAt": "2025-01-17T02:49:16Z",
          "updatedAt": "2025-01-17T02:49:16Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOCUe3lM6jj6a4",
      "title": "Discussing ID tokens in the Implicit flow deprecation section",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/59",
      "state": "CLOSED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rifaat Shekh-Yusef mentioned the following in a review (mail 13/11/2024):\r\n\r\n> Section 7.2.4\r\n> \u201cPerforming OpenID Connect using the Authorization Code grant type provides the benefit of the client not needing to verify the JWT signature, \u2026\u201d\r\n> With all kinds of middle boxes being used these days, should we encourage people to verify the JWT signature even if it was obtained over an HTTPS channel?\r\n\r\nGood question, but it has me wondering why are we talking about OIDC in this spec at all? I would recommend to drop this paragraph.",
      "createdAt": "2024-12-17T07:04:04Z",
      "updatedAt": "2024-12-18T20:49:37Z",
      "closedAt": "2024-12-18T20:49:37Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "There are several other mentions of OpenID Connect in the document, but this is the only one that gets in to the specifics of OIDC, so I agree we should just drop this paragraph. ",
          "createdAt": "2024-12-17T23:02:57Z",
          "updatedAt": "2024-12-17T23:02:57Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOCUe3lM6k1dAp",
      "title": "Using Web Workers to refresh access tokens adds implementation complexity for marginal security benefit",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/62",
      "state": "CLOSED",
      "author": "micolous",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[Section 6.3.4.2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.3.4.2.1) (Browser-Based OAuth Applications - Secure Token Storage) discourages using \"universally accessible storage areas\" such as Local Storage, and suggests a pattern of using a Web Worker to \"isolate the refresh token, and provide the application with the access token to make requests\".\r\n\r\n[Section 8.3 (Token Storage in a Web Worker) paragraphs 3 and 4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-8.3-3) describe using Web Workers to isolate the refresh token, like what is proposed in Section 6.3.4.2.1.\r\n\r\nBut [Section 8.3 paragraph 2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-8.3-2) notes:\r\n\r\n> The security properties of using a Web Worker are identical to using Service Workers. When tokens are exposed to the application, they become vulnerable. When tokens need to be used, the operation that relies on them has to be carried out by the Web Worker.\r\n\r\nThis would seem to *discourage* the pattern proposed in Section 6.3.4.2.1, where a Web Worker provides the access token for the application to make requests directly.\r\n\r\nSection 8.3 paragraph 2 proposes a pattern similar to that in [Section 7.4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-7.4) (Discouraged and Deprecated Architecture Patterns - Handling the OAuth Flow in a Service Worker). [Section 7.4.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-7.4.1.1) (Attacking the Service Worker) notes several security shortcomings with the pattern, and that there is significant complexity to implementing, registering and maintaining a Service Worker.\r\n\r\nI believe that the shortcomings identified in Section 7.4.1.1 *also* apply to using a Web Worker to isolate the refresh token alone. Using a (shared) Web Worker is still a source of complexity \u2013 even if that worker doesn't need to do quite as much.\r\n\r\nAs a result, I don't think there is a significant *security* benefit to using Web Workers to store the refresh token over using Local Storage. An attacker who can execute arbitrary JavaScript within the context of the application (ie: via XSS) to access Local Storage can also send messages to Web Workers (to acquire a short-term access token) or [bypass them](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3) (to acquire a new, longer-lived refresh token), and so [it's still pretty much game over for a Browser-Based OAuth Application](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.3.4.3).\r\n\r\nOne potential benefit to using *Shared* Web Workers for refresh tokens is that the Worker could block requests for the access token on completion of any in-flight refresh request, thus preventing the application from attempting to use a single refresh token multiple times.\r\n\r\nHowever, it'd also be possible to do that with Local Storage and the [Web Locks API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API).\r\n\r\n## Related issues\r\n\r\n* https://github.com/oauth-wg/oauth-browser-based-apps/issues/3\r\n* https://github.com/oauth-wg/oauth-browser-based-apps/pull/19\r\n* https://github.com/oauth-wg/oauth-browser-based-apps/pull/24 \r\n\r\n**Edit (2024-01-06)**: noted that web workers don't stop [acquiring new tokens](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3).\r\n",
      "createdAt": "2025-01-02T05:46:28Z",
      "updatedAt": "2025-01-21T07:19:34Z",
      "closedAt": "2025-01-17T22:51:54Z",
      "comments": [
        {
          "author": "pavinduLakshan",
          "authorAssociation": "NONE",
          "body": "> An attacker who can execute arbitrary JavaScript within the context of the application (ie: via XSS) to access Local Storage can also send messages to Web Workers, and so [it's still pretty much game over for a Browser-Based OAuth Application](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.3.4.3).\r\n\r\nAs long as the web worker does not provide a mechanism to expose the refresh token externally, the likelihood of this occurring remains minimal.\r\n\r\nIn the [Asgardeo React SDK](https://github.com/asgardeo/asgardeo-auth-react-sdk), we use a web worker to handle access token refreshes. Since the refresh token is securely confined within the web worker, it is inaccessible to external JavaScript.",
          "createdAt": "2025-01-06T04:47:03Z",
          "updatedAt": "2025-01-06T04:47:03Z"
        },
        {
          "author": "micolous",
          "authorAssociation": "NONE",
          "body": " > Since the refresh token is securely confined within the web worker, it is inaccessible to external JavaScript.\r\n\r\nYes, *that* refresh token is not accessible, but the malicious code could [do the whole Authorisation Code process itself](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3), and get a new token. I've edited that part of my post to link to [Section 5.1.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3).\r\n\r\nThis is similar to the attack described in [Section 7.4.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-7.4.1.1) against Service Workers, but because Web Workers can't intercept XHR/`fetch()`, there's no need to unregister a Web Worker first.\r\n\r\nThere are some mitigations that an IdP could do, like strictly controlling the `redirect_uri` to a specific registered handler URI (so an attacker would need XSS on the `redirect_uri`, rather than any URI on the same origin) and using a CSP to prevent embedding as an `<iframe>` (so an attacker would need some persistent XSS).\r\n\r\nXSS can always leak access tokens though... and while they're much shorter lifetime, they can still be useful for an attacker who implements some basic automation, particularly if it gives access to some API which allows more credentials to be registered or changes to access controls.",
          "createdAt": "2025-01-06T05:46:09Z",
          "updatedAt": "2025-01-06T05:46:09Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Since the refresh token is securely confined within the web worker, it is inaccessible to external JavaScript.\r\n> \r\n> Yes, _that_ refresh token is not accessible, but the malicious code could [do the whole Authorisation Code process itself](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3), and get a new token. I've edited that part of my post to link to [Section 5.1.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-5.1.3).\r\n\r\nThis is indeed the correct observation. An attacker running malicious JS code can run a new flow to obtain an independent set of tokens. This attack vector is often overlooked and poses a major threat to frontend Oauth clients (hence the elaborate updates to the spec).\r\n\r\n\r\n> This is similar to the attack described in [Section 7.4.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-7.4.1.1) against Service Workers, but because Web Workers can't intercept XHR/`fetch()`, there's no need to unregister a Web Worker first.\r\n> \r\n> There are some mitigations that an IdP could do, like strictly controlling the `redirect_uri` to a specific registered handler URI (so an attacker would need XSS on the `redirect_uri`, rather than any URI on the same origin) and using a CSP to prevent embedding as an `<iframe>` (so an attacker would need some persistent XSS).\r\n\r\nThese mitigations typically do not work, for a couple of reasons. \r\n\r\nTight restrictions on the `redirect_uri` do not matter, as long as it is same-origin with the compromised application. The attacker does not need to run code at the `redirect_uri` endpoint, but merely reads the code from the `redirect_uri` loaded in the iframe. Reading URLs in iframes is restricted by the Same-Origin Policy, so running code within the same origin suffices. Similarly, some authorization servers use web messaging to send the code from the frame to main application context, which is also origin-based.\r\n\r\nAs for restricting the loading of iframes with CSP. Blocking this behavior also means that the legitimate application cannot rely on this pattern. Since frontends typically run a silent iframe-based flow upon load time, this would break silent authentication flows. And enabling this pattern also makes it available to the attacker. Additionally, I believe an attacker would be able to run a similar attack using a popup window instead of an iframe.\r\n\r\n\r\nFinally, a remark on the initial issue that started this thread. I believe the observation @micolous makes is indeed correct. There is only a very limited security benefit to using a web worker to handle refresh tokens. However, using a pattern like this makes it significantly harder to obtain refresh tokens (but not access tokens). It also forces the attacker to run a new flow to obtain one, which makes the interaction more visible. The recommendation to use a web worker is mostly aiming for \"the best you can do in a shitty situation\".",
          "createdAt": "2025-01-06T06:30:32Z",
          "updatedAt": "2025-01-06T06:30:32Z"
        },
        {
          "author": "micolous",
          "authorAssociation": "NONE",
          "body": "> Reading URLs in iframes is restricted by the Same-Origin Policy, so running code within the same origin suffices. Similarly, some authorization servers use web messaging to send the code from the frame to main application context, which is also origin-based.\r\n\r\nAh, good point.\r\n\r\n> Additionally, I believe an attacker would be able to run a similar attack using a popup window instead of an iframe.\r\n\r\nIf the IdP is served with [COOP: `same-origin`](https://xsleaks.dev/docs/defenses/opt-in/coop/), it sounds like that would prevent code running in the application's origin from getting a `Window` handle back from a `window.open()` call to the IdP's URI. Though:\r\n\r\n* I don't think this would apply to a `window.open()` call to a URI in the application's Origin, which then redirects to the IdP\r\n* It's unclear whether that separation would continue if the pop-up navigated back to the application's Origin\r\n\r\nIf the application is served with [COOP: `noopener-allow-popups`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy), it sounds that would prevent any code running in its Origin from ever getting a `Window` handle back from `window.open()` calls to any URI. But the caveat is that [mode is still experimental, and not available in all browsers at present](https://caniuse.com/mdn-http_headers_cross-origin-opener-policy_noopener-allow-popups).\r\n\r\nAnd yes, all of this would completely break silent re-authentication flows... but the more I think about it, the more I think silent re-authentication may be a security risk anyway.\r\n\r\n> However, using a pattern like this makes it significantly harder to obtain refresh tokens (but not access tokens). It also forces the attacker to run a new flow to obtain one, which makes the interaction more visible.\r\n\r\nI agree it makes it harder for an attacker to acquire a refresh token, but both the visibility and the utility of that visibility is debatable:\r\n\r\n* If the IdP allows iframing for silent re-authentication flows, then the attacker can completely obscure the re-authentication flow.\r\n\r\n  If the IdP *also* supports [`prompt=none`](https://openid.net/specs/openid-connect-basic-1_0.html#RequestParameters), then a malicious script could avoid triggering any browser UI indicative of a re-authentication flow (such as prompting for a password, security key or triggering a platform-level identity provider intent handler), and retry silently in the background.\r\n\r\n* If the IdP prevents iframing and the application has no [COOP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy), then you're relying on the user:\r\n\r\n  1. identifying that a pop-up window (or request for pop-up window) as abnormal behaviour\r\n  2. understanding that it *is* because of a successful XSS attack against their browser\r\n  3. being able to address or mitigate the issue\r\n\r\n  An attacker could disguise it with some UI like \"your session has expired, allow this pop-up to log in again\", which wouldn't be out of character for many modern web apps.\r\n\r\n> The recommendation to use a web worker is mostly aiming for \"the best you can do in a shitty situation\".\r\n\r\nI agree it's a shitty situation.\r\n\r\nLike with all web apps (whether they're browser-based apps or not), you need to throw a lot of tools at them to lock them down (eg: CSP, CORP, COEP, COOP), which also limits which UI frameworks you can use and the application's UI.\r\n\r\nMy concern is that the implementation complexity of a Web Worker mostly impacts those *developing and deploying* an application, rather than someone attacking it.\r\n",
          "createdAt": "2025-01-07T01:00:29Z",
          "updatedAt": "2025-01-07T01:00:29Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In essence, it all boils down to the fact that a frontend client is a public client, with no authentication involved. The only security measure in the flow is restricting the `redirect_uri`, which is insufficient when an attacker has taken control of the origin. \r\n\r\nYou are correct that using COOP could help in preventing the popup-based scenario. However, that again would imply that legitimate popup-based scenarios might break because of this.\r\n\r\nEither way, using OAuth in the browser effectively increases the attack surface of the application (as explained in the spec), and adding additional security measures does not remediate this situation. Things like CSP etc. can definitely help and should be used, but are not a definitive defense against XSS (which is only one way malicious JS can end up in the app).\r\n\r\n\r\n> My concern is that the implementation complexity of a Web Worker mostly impacts those developing and deploying an application, rather than someone attacking it.\r\n\r\nI do want to revisit this. You have mentioned this earlier, but I don't really see the complexity issue you are referring to. Web workers are not shared across browsing contexts, and are simply a piece of code running in a separate context. The complexity is no more than running a silent flow in an iframe for example. This pattern is also actively used, for example in the Auth0 SDK (https://github.com/auth0/auth0-spa-js/blob/main/src/worker/token.worker.ts).\r\n\r\nSo instead of redeeming the authorization code in the main execution context, the application forwards it to the worker, which exchanges it for tokens. There is a one-on-one relationship between the main execution context and the worker. If the main execution context reloads, so does the worker (hence the need for the silent flow to obtain fresh tokens).\r\n\r\nAlso note that the use of a Web Worker is an implementation suggestion, not a normative requirement of the spec.",
          "createdAt": "2025-01-07T07:10:00Z",
          "updatedAt": "2025-01-07T07:10:00Z"
        },
        {
          "author": "micolous",
          "authorAssociation": "NONE",
          "body": "> I don't really see the complexity issue you are referring to. Web workers are not shared across browsing contexts, and are simply a piece of code running in a separate context. The complexity is no more than running a silent flow in an iframe for example. \r\n\r\nThe main source of complexity is Web Workers require a separate JS module served at a separate URL, and implementing an RPC interface with JSON-serialisable objects. For a JS/TS application, that also requires that your framework's build process/bundler emitting separate modules like this. For WASM-based applications, that means setting up another build target for the authentication process, which is complicated, and crossing the JS-WASM boundary in more places.\r\n\r\nComparing to the alternative: storing the `access_token` and `refresh_token` in LocalStorage:\r\n\r\n* When the main execution context reloads, it doesn't need to spawn a `Worker` \u2013 it can acquire and refresh those values directly.\r\n\r\n* You call your OAuth2 implementation the same way as all your other code, without needing to worry about indirection, serialisation and deserialisation through an RPC interface.\r\n\r\n* There's no need for your framework, bundler or build process to support Web Workers at all. You also don't need to build a separate content security policy for the worker.\r\n\r\n* For WASM applications, token access and updates cross the JS-WASM boundary only once.\r\n\r\nFor non-shared Web Workers and Local Storage based token storage, you'd also want to have a Lock around the token to ensure that only one of them tries to mutate the token (ie: refresh it if expired) at any time, and have some mechanism to allow the user to explicitly override it (eg: \"we're trying to log you in again already from another tab, but you can log in here instead\") for non-silent flows.\r\n\r\n> This pattern is also actively used, for example in the Auth0 SDK (https://github.com/auth0/auth0-spa-js/blob/main/src/worker/token.worker.ts).\r\n> \r\n> So instead of redeeming the authorization code in the main execution context, the application forwards it to the worker, which exchanges it for tokens. There is a one-on-one relationship between the main execution context and the worker. If the main execution context reloads, so does the worker (hence the need for the silent flow to obtain fresh tokens).\r\n\r\nI already had a look at the Auth0 JS SPA SDK before making that assertion. When configured to use a Web Worker with storage in memory, it appears to roughly:\r\n\r\n1. When the `access_token` is expired, the main context messages the worker with a `response_type=refresh_token` request\r\n2. If it is a `response_type=refresh_token` request, the worker adds in any `refresh_token` from its closure (memory)\r\n3. The worker then sends the request to the IdP\r\n4. When the IdP responds, it stores the `refresh_token` in its closure (memory) and deletes it from the structure, before returning it to the main context.\r\n5. The main context stores the response in session storage or a cookie.\r\n6. When the `access_token` is missing or it can't be refreshed, the main context performs a `/authorize?response_type=code` request, and can attempt it in an iframe or with navigation (various conditions not relevant)\r\n7. When the IdP returns to the `redirect_uri` handler, the main context messages the worker with a `response_type=code` request to fetch the `access_token`.\r\n8. Worker sends the actual request to the IdP, caches the `refresh_token` from the response and strips it from the response passed back to the main context.\r\n9. Main context stores the response in session storage or a cookie.\r\n\r\nWith the Auth0 library, the main execution context is responsible for figuring out if a token has expired, and the worker is responsible for fetching any tokens, essentially proxying all (`/token`) requests.\r\n\r\nHowever, as above, there's nothing stopping a malicious script running in the main execution context from fetching the token directly, and caching it for itself. If the IdP allows silent flows (as it appears the Auth0 library may depend on), then this can all be done without the user noticing.\r\n\r\nI'm pretty sure I've found a weakness in the Auth0 worker implementation which would allow malicious code running in the main execution context to trick the worker into leaking the refresh token to a location other than the identity provider. I've emailed them privately about that. \ud83d\ude04 \r\n\r\nAs such, there's limited *benefit* to building it this way \u2013 possibly even none... and that complexity can end up introducing _more_ bugs in the process.\r\n\r\n> Also note that the use of a Web Worker is an implementation suggestion, not a normative requirement of the spec.\r\n\r\nUnderstood. I acknowledge that this is a hard problem, and it may not be possible to solve. \ud83d\ude04 \r\n",
          "createdAt": "2025-01-08T04:06:19Z",
          "updatedAt": "2025-01-08T05:38:22Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the discussion. It sounds like this has concluded with no suggested changes to the document. I'll close this issue shortly unless someone chimes in otherwise.",
          "createdAt": "2025-01-17T02:50:35Z",
          "updatedAt": "2025-01-17T02:50:35Z"
        },
        {
          "author": "micolous",
          "authorAssociation": "NONE",
          "body": "I think the discussion was useful, but there are things which could change (though this doesn't \"solve everything\"). There's a couple of ways to cut this:\n\n* **Larger change:** after [Section 7.4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-7.4), add a new section for the Web Worker pattern. Describe Web Workers in a similar level of detail to Service Workers (though refer to Section 7.4 where similar), and use that to replace [section 8.2 paragraphs 3 and 4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-8.3-3).\n\n* **Alternative smaller changes:**\n\n  * **Delete** [section 6.3.4.2.1 paragraph 2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-6.3.4.2.1-2):\n\n    > A practical implementation pattern can use a Web Worker [[WebWorker](https://html.spec.whatwg.org/commit-snapshots/b4233430fe410f67b7022ec8b28f55795dcc4110/#toc-workers)] to isolate the refresh token, and provide the application with the access token making requests to resource servers.\n\n    **Rationale:** paragraph 1 says section 8 describes different storage mechanisms in greater detail, and repeating one of the mechanisms here without extra context is problematic.\n  \n  * **Change** [section 8.2 paragraph 2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-8.3-2):\n\n    > The **token isolation** properties of using a Web Worker are identical to Service Workers. When tokens are exposed to the application, they become vulnerable. When tokens need to be used, the operation that relies on them has to be carried out by the Web Worker.\n\n    **Rationale:** the security properties are *weaker*, not identical, as you don't need to unregister a Web Worker to perform a new Auth Code flow. The token isolation properties are more similar.\n  \n  * **Change** [section 8.2 paragraph 3 and 4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps#section-8.3-3):\n  \n    > One common use of Web Workers is to isolate the **access and** refresh **tokens**. In such a scenario, the application runs an Authorization Code flow to obtain the authorization code. This **code, the Access Token Request URI and the Resource Server's URIs are** forwarded to a Web Worker, which exchanges **the code** for tokens. The Web Worker keeps the refresh token **and associated URIs** in memory, and **can make requests on the main application's behalf using the access token**. When the application needs to run a refresh token flow, it asks the Web Worker to do so, after which the **application's requests are sent with** a fresh access token.\n    >\n    > In this scenario, the application's existing **tokens are** effectively protected against **exfiltration or use with unintended hosts. However, this pattern adds significant implementation complexity, and** nothing would prevent an attacker from obtaining their own tokens by running a new Authorization Code flow **(Section 5.1.3)**.\n  \n    **Rationale:** while Web Workers can't prevent new Auth Code flows (paragraph 1), this prevents exfiltration of the access token as well, and providing a list of related URIs at set-up time ensures the Web Worker and main application will not leak tokens to *unintended* hosts. However, the trade-off is the extra setup, filtering, and potentially supporting multiple sessions and resource servers makes everything more complex.\n",
          "createdAt": "2025-01-21T07:05:54Z",
          "updatedAt": "2025-01-21T07:19:34Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOCUe3lM6mjoDw",
      "title": "When can the BFF ignore \"SHOULD encrypt its cookie contents\"?",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/63",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From the AD review:\n\n> Section 6.1.3.2, para 4: '...the BFF SHOULD encrypt its cookie contents.' Why not a MUST?  Under what circumstances would it be reasonable to ignore this SHOULD?\n\nWe should either change this to a MUST, or add a sentence justifying the SHOULD.",
      "createdAt": "2025-01-17T02:54:10Z",
      "updatedAt": "2025-01-17T22:50:59Z",
      "closedAt": "2025-01-17T22:50:59Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@philippederyck I'd appreciate your insights here",
          "createdAt": "2025-01-17T02:54:43Z",
          "updatedAt": "2025-01-17T02:54:43Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is written as a SHOULD because it is not strictly necessary to benefit from the use of a BFF. The spec focuses on an attacker model where the attacker can control the client. Malware is \"out of scope\", since an attacker controlling the user's machine can also circumvent all the other protections of the BFF. \n\nThat said, there appears to be this common case where the malware mainly steals credentials, and then encryption could be helpful (to hide the tokens, not to prevent session hijacking). Whether you want to implement this or not depends on the sensitivity of the application. \n\nMaking this a MUST will make the BFF pattern (slightly) harder to implement, and might cause people to shy away from it. \n\n\nDoes this modified text help?\n\n> Additionally, when using client-side sessions that contain access tokens, (as opposed to server-side sessions where the tokens only live on the server), the BFF SHOULD encrypt its cookie contents. __While the use of cookie encryption does not affect the security properties of the BFF pattern, it does ensure__ that tokens stored in cookies are never written to the user's hard drive in plaintext format. This security measure helps ensure the confidentiality of the tokens in case an attacker is able to read cookies from the hard drive. Such an attack can be launched through malware running on the victim's computer. Note that while encrypting the cookie contents prevents direct access to embedded tokens, it still allows the attacker to use the encrypted cookie in a session hijacking attack.\n",
          "createdAt": "2025-01-17T06:06:35Z",
          "updatedAt": "2025-01-17T06:06:35Z"
        },
        {
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "body": "> This security measure helps ensure the confidentiality of the tokens in case an attacker is able to read cookies from the hard drive. Such an attack can be launched through malware running on the victim's computer.\n\nThe attacker can be the user as well, bypassing any restriction on the protected resource requests imposed by the the client backend.\n\nAn alternative solution to client-side session encryption is to use sender(backend)-constrained tokens.\n",
          "createdAt": "2025-01-17T08:27:40Z",
          "updatedAt": "2025-01-17T08:27:40Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@randomstuff This is talking about storing tokens in cookies, not storing something like a user ID. The token should already be an opaque/signed/encrypted token that is resistant to user tampering. Besides, cookies can be signed instead of encrypted, and signed cookies are also protected against the user tampering with the cookie values intentionally.",
          "createdAt": "2025-01-17T22:25:00Z",
          "updatedAt": "2025-01-17T22:25:00Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@philippederyck thank you, I think that is a good addition, I'm going to add it now and respond to the AD review, thanks.",
          "createdAt": "2025-01-17T22:50:20Z",
          "updatedAt": "2025-01-17T22:50:20Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOCUe3lM6mjp1s",
      "title": "Address SEC AD review comments",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/issues/64",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "> General:  There are more than a couple of Normative references that are pointing to 'living documents'.  From my reading of the draft these include:  Cookie Prefixes, Fetch, Web-messaging, service-workers, webstorage. If at all possible, we need to find a way to specify a particular version via commit, snapshot, archive to make an immutable version.  Or find a way to make them Informative.  Basically this draft will be an RFC - immutable, yet a few of the Normative references are changeable.\n\nI was able to find links to snapshots of all the living documents referenced. All references now link to the stable URL versions.\n\n> BCP 14 boilerplate:  idnits (a little blue button '! Nits' on the line above the text of the draft on the main datatracker page). is throwing errors on the BCP14 boilerplate.  Ideally, I'd like these fixed before moving this along (it just eliminates problems down the road).\n\nIt looks like these nits fall into a few categories:\n\n* Date issue (will be fixed on publication of a new version)\n* Wrong RFC 2219 boilerplate (fixed)\n* Non-RFC references (will still be nits, but now reference stable versions)\n\n> Section 6.1.3.2, para 4: '...the BFF SHOULD encrypt its cookie contents.' Why not a MUST?  Under what circumstances would it be reasonable to ignore this SHOULD?\n\nWe added a sentence following this to clarify that the difference of encrypting the cookie contents doesn't affect the security properties of the BFF pattern.\n\n> Section 6.1.3.2, last para:  Add this to the (Informative) references.\n\nDone\n\n> Section 6.3.4.2.2, first para:  Add 'CrytoKeyPair' to the (Informative) references.\n\nDone\n\n> Section 7.4, first para, last sentence:  Nit:  'This restrictions' should either be 'these restrictions' or 'this restriction'.\n\nDone\n\n> Section 11:  RFC6819 is a normative reference, but it is Informational.  We need to call that out in the IETF Last Call, and I have to approve the downref (which I will do).\n\nMoved this to an informative reference\n",
      "createdAt": "2025-01-17T02:58:31Z",
      "updatedAt": "2025-01-17T23:00:13Z",
      "closedAt": "2025-01-17T23:00:11Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "All comments are addressed other than #63",
          "createdAt": "2025-01-17T02:58:56Z",
          "updatedAt": "2025-01-17T02:58:56Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I've published version 22 and sent an email to the list with the notes above:\n\nhttps://mailarchive.ietf.org/arch/msg/oauth/JMpMU-seAMSpMUs3-qIkIeCY3mg/\n\nhttps://www.ietf.org/archive/id/draft-ietf-oauth-browser-based-apps-22.html",
          "createdAt": "2025-01-17T23:00:11Z",
          "updatedAt": "2025-01-17T23:00:11Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwMDk3NDYx",
      "title": "Typos and minor fixes",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/5",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just some minor mistakes I stumbled upon while working through the draft.",
      "createdAt": "2021-05-11T10:40:04Z",
      "updatedAt": "2021-05-18T00:04:08Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "ef1bfb0bd48fbbf878a64086cadb080612bf01ab",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "typos-and-minor-fixes",
      "headRefOid": "6cb9f79ddf6290127d9e55d7117f12b627be9b8b",
      "closedAt": "2021-05-18T00:04:08Z",
      "mergedAt": "2021-05-18T00:04:08Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "5b62b2b701c752582663d2658115a47bd1c72e20"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxNTEwNTUx",
          "commit": {
            "abbreviatedOid": "956bf36"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-05-17T23:29:03Z",
          "updatedAt": "2021-05-17T23:29:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This one is actually correct not hyphenated. It should only be hyphenated when used as an adjective.",
              "createdAt": "2021-05-17T23:29:03Z",
              "updatedAt": "2021-05-17T23:29:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwMTM1NTY3",
      "title": "Security bcp update",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/7",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updates draft to cover some of the latest changes in the security (see #6)",
      "createdAt": "2021-05-11T10:55:00Z",
      "updatedAt": "2021-05-17T23:47:13Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "security-bcp-update",
      "headRefOid": "d5fd1d30723531f97b4e09833db1b1f29348ffbc",
      "closedAt": "2021-05-17T23:47:13Z",
      "mergedAt": "2021-05-17T23:47:13Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "8363ef58009a3f44a82fa3e065c71df82c14263b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwMjY1NjIw",
      "title": "Improve without backend",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/8",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Arrow C is referenced in the text \"[The code in the browser] obtains an access token via a POST request (C).\". The arrow should have an arrowhead on both ends as it symbolizes both the token request and token response.\r\n- \"The JavaScript app is then responsible for storing the access token (and optional refresh token) securely using appropriate browser APIs.\" I think this sentence was misleading, because as of today there is no way for the app to store tokens securely in the browser.\r\n- Arrow E was not referenced in the text.",
      "createdAt": "2021-05-11T11:46:03Z",
      "updatedAt": "2021-05-17T23:48:41Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "improve-without-backend",
      "headRefOid": "db91595c8ee9c9d44aa6f09baf43e2a8a91d70df",
      "closedAt": "2021-05-17T23:48:41Z",
      "mergedAt": "2021-05-17T23:48:41Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "896ab335e5f3b9de9844e4af66b663f41de8b54f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwMzQ0OTEz",
      "title": "Improve implicit flow",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/9",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T12:17:31Z",
      "updatedAt": "2021-05-17T23:56:30Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "improve-implicit-flow",
      "headRefOid": "95361a4122d92657ab48fc4c1527dafce720457c",
      "closedAt": "2021-05-17T23:56:30Z",
      "mergedAt": "2021-05-17T23:56:30Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7dd71d355d8ea83a5ce6b54da34adbebfd18b940"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwNDE0ODg1",
      "title": "Improve code flow",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/10",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T12:45:13Z",
      "updatedAt": "2021-05-17T23:57:02Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "improve-code-flow",
      "headRefOid": "02058d6ad96e2f83065d4ed263c8d51b23527678",
      "closedAt": "2021-05-17T23:57:02Z",
      "mergedAt": "2021-05-17T23:57:02Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "0fb4a1669ed666f002cb7475c8f2b5c50f5e7508"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwNDE1OTU2",
      "title": "Added note to use Secure cookie attribute to first architecture",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/11",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T12:45:39Z",
      "updatedAt": "2021-05-17T23:57:22Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "improve-first-architecture",
      "headRefOid": "6e970d0bf5a2e84ddb82cc47a4da00c46a4c6955",
      "closedAt": "2021-05-17T23:57:21Z",
      "mergedAt": "2021-05-17T23:57:21Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "8a27f409bffe6445e03dd6b152ac63d5faa94065"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQwNDE2Nzg5",
      "title": "Improve with backend",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/12",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-11T12:45:59Z",
      "updatedAt": "2021-05-17T23:59:03Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "107aa0519a2ca037da5ff8cf9b25b2002960555e",
      "headRepository": "kmzs/oauth-browser-based-apps",
      "headRefName": "improve-with-backend",
      "headRefOid": "ad9fd712c94b2ffeade913ac68882c5a9baa40aa",
      "closedAt": "2021-05-17T23:59:03Z",
      "mergedAt": "2021-05-17T23:59:03Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ef1bfb0bd48fbbf878a64086cadb080612bf01ab"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "PR_kwDOCUe3lM46Yyzp",
      "title": "Introducing Service Worker. Refactored section about architectural pa\u2026",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/13",
      "state": "CLOSED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Here is a very first version.\r\n\r\nI think all information is present. However, I'm still trying to find out where everything should go. I think we should consider having separate _security concerns_ for each flow. Or maybe splitting the document in a section describing the architectural patterns, and another one about their security concerns, along with attacks and their mitigations. Both have merits IMO.",
      "createdAt": "2022-06-27T05:09:57Z",
      "updatedAt": "2022-09-01T05:09:03Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "e9a9af82465ccec90d507b0afc92c5e6046d3a64",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "serviceworker",
      "headRefOid": "8968862383dee273cdcfc6d4a5ac29cf7ea1d958",
      "closedAt": "2022-09-01T05:09:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Refactored this in multiple PRs",
          "createdAt": "2022-09-01T05:09:03Z",
          "updatedAt": "2022-09-01T05:09:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM4-HuP3",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-18T17:18:00Z",
          "updatedAt": "2022-07-18T17:18:01Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Doesn't PKCE prevent this attack from succeeding?",
              "createdAt": "2022-07-18T17:18:00Z",
              "updatedAt": "2022-07-18T17:18:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-HunO",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-18T17:19:18Z",
          "updatedAt": "2022-07-18T17:19:19Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think we should avoid using the term \"stateful\" here since that's not actually a relevant property of this architecture. It's possible to make the BFF stateless and use encrypted cookies to store all the session data and things still work as described in this pattern. ",
              "createdAt": "2022-07-18T17:19:18Z",
              "updatedAt": "2022-07-18T17:19:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-HvPb",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-18T17:21:38Z",
          "updatedAt": "2022-07-18T17:21:39Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Similar to above, this isn't true when using PKCE",
              "createdAt": "2022-07-18T17:21:39Z",
              "updatedAt": "2022-07-18T17:21:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-HvW6",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-18T17:22:03Z",
          "updatedAt": "2022-07-18T17:22:04Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "This could use some clarification. In particular, what is being sanitized?",
              "createdAt": "2022-07-18T17:22:03Z",
              "updatedAt": "2022-07-18T17:22:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-YkkP",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T14:24:29Z",
          "updatedAt": "2022-07-21T14:24:30Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This attack will indeed only succeed if authorization flow is initiated from the browser. PKCE can protect against this IF that code is on the backend, and the code verifier is kept securely from the frontend. I'll rework that to make that clear.",
              "createdAt": "2022-07-21T14:24:30Z",
              "updatedAt": "2022-07-21T14:24:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-Ymgd",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T14:29:08Z",
          "updatedAt": "2022-07-21T14:29:09Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "The relevant property that I wanted to underline was the fact that some state needed to be kept, and that it needed to be inaccessible from the frontend. A kind of viewstate solution would indeed work too. \r\n\r\nMy point was that this wasn't just any backend: SPA with stateless backends are very common nowadays, in contrast to stateful backends or viewstate approaches. This makes big difference though: this implies some infrastructure requirements that just aren't needed in other solutions (local/session storage or service workers).\r\n\r\n I'll try to find some better wording.",
              "createdAt": "2022-07-21T14:29:08Z",
              "updatedAt": "2022-07-21T14:29:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-YpLS",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T14:35:34Z",
          "updatedAt": "2022-07-21T14:35:35Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I'll indeed remove the last sentence, as a well implemented oauth2 initiating BFF would indeed solve that too.",
              "createdAt": "2022-07-21T14:35:34Z",
              "updatedAt": "2022-07-21T14:35:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-YrNh",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T14:39:39Z",
          "updatedAt": "2022-07-21T14:39:39Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "I'll rework that part too. To keep the security principles of this architecture safe, it shouldn't be possible to get an authorization code or a token in the frontend, bypassing the safe storage in a service worker.",
              "createdAt": "2022-07-21T14:39:39Z",
              "updatedAt": "2022-07-21T14:39:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-Y4DA",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T15:04:24Z",
          "updatedAt": "2022-07-21T15:04:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "After some reflection: I tried to remove that \"stateful\" aspect, but I'm actually quite convinced that this property is indeed characteristic of this architecture: even if that state can be stored in the frontend (in cookies or otherwise), which typically helps for scaling across multiple backend nodes, there is still backend state that needs to be maintained.\r\n\r\nMy suggestion is to keep the \"stateful\" wording, maybe with a word of clarification.\r\n\r\nDo you have another proposal or view about how to describe the architecture in the best possible way?",
              "createdAt": "2022-07-21T15:04:24Z",
              "updatedAt": "2022-07-21T15:04:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-3Axw",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "dwaite",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-28T19:00:17Z",
          "updatedAt": "2022-07-28T19:00:17Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "While service workers cannot be invoked from a third party context calling the origin, XSS or some script injection into the origin can make API calls (which will have the access token automatically applied.)\r\n\r\nIt is probably worth calling this out, referencing the existing CSP section (and perhaps SRI, I don't remember if there was a reason SRI was not mentioned at this point).",
              "createdAt": "2022-07-28T19:00:17Z",
              "updatedAt": "2022-07-28T19:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-41eW",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-29T06:52:09Z",
          "updatedAt": "2022-07-29T06:52:10Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "XSS can indeed lead to spoofed calls to the resource server, and a token would automatically be added. That is true for all described architectures, though. An attacker can certainly add the token if it's stored in local/session storage or even browser memory (and it will typically be done automatically from an http interceptor). And BFFs are even worse in this case, as they not only make that a fact through XSS, but also open a bunch of CSRF issues which will lead to tokens being added automatically to any call, not only those originating from injected scripts.\r\n\r\nSo, should we rather, from a general section concerning all architectures, reference either a security section in this document or in another one (e.g. OAuth Security Topics 2.0)?",
              "createdAt": "2022-07-29T06:52:09Z",
              "updatedAt": "2022-07-29T06:52:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM4-6sqt",
          "commit": {
            "abbreviatedOid": "cc6d8d0"
          },
          "author": "dwaite",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-29T13:30:48Z",
          "updatedAt": "2022-07-29T13:30:48Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Absolutely should be a common section. There are subtle differences in some security actions - for instance,  I can reduce the accessible API surface via limiting accessing functions (in-memory), via BFF logic, or serviceworker rules. \r\n\r\nOnly BFF needs to think about SameSite cookies or other CSRF protections of the three AFAICT. ",
              "createdAt": "2022-07-29T13:30:48Z",
              "updatedAt": "2022-07-29T13:30:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOCUe3lM4-Bd2r",
      "title": "reworked some architectural patterns",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/15",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Refactoring some architectural patterns:\r\n- Single-Domain Browser-Based Apps (not using OAuth)\r\n- Backend For Frontend (BFF) Proxy",
      "createdAt": "2022-08-30T07:29:16Z",
      "updatedAt": "2022-09-01T05:16:17Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "0ee751f7660e29912366abcf11505bb192b32898",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "bffproxy",
      "headRefOid": "3bff1fe221d96e39df87f8a7d3be0e40f342a652",
      "closedAt": "2022-09-01T05:16:17Z",
      "mergedAt": "2022-09-01T05:16:16Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "e9c6fc1683e1a183932629f14a5364372ef96a3e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5BGkAR",
          "commit": {
            "abbreviatedOid": "023af4d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-08-31T17:13:51Z",
          "updatedAt": "2022-08-31T17:13:55Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Looks like an incomplete thought? We can just remove this for now to merge this in if you like.",
              "createdAt": "2022-08-31T17:13:51Z",
              "updatedAt": "2022-08-31T17:13:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BH3xu",
          "commit": {
            "abbreviatedOid": "023af4d"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-31T22:33:42Z",
          "updatedAt": "2022-08-31T22:33:42Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Indeed, removed for now.",
              "createdAt": "2022-08-31T22:33:42Z",
              "updatedAt": "2022-08-31T22:33:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOCUe3lM4-BxvY",
      "title": "refactor: js client",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/16",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "reworked some architectural patterns: Javascript applications accessing resource servers directly (js = oauth client)",
      "createdAt": "2022-08-30T08:38:27Z",
      "updatedAt": "2022-08-31T17:21:14Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "0ee751f7660e29912366abcf11505bb192b32898",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "javascript-oauth-client",
      "headRefOid": "a9667d1dab05deb43044290576d672838ae56b43",
      "closedAt": "2022-08-31T17:21:13Z",
      "mergedAt": "2022-08-31T17:21:13Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "c6f99e8e81fe39b37c28f3d9b29a94995fa4b081"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5BGlxg",
          "commit": {
            "abbreviatedOid": "a9667d1"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-31T17:20:06Z",
          "updatedAt": "2022-08-31T17:20:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOCUe3lM4-Bx6s",
      "title": "about storing tokens in local or session storage",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/17",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-30T08:38:51Z",
      "updatedAt": "2022-08-31T17:31:58Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "0ee751f7660e29912366abcf11505bb192b32898",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "localstorage",
      "headRefOid": "9783e9844eed712d711db9f81315d8bb89dbcd35",
      "closedAt": "2022-08-31T17:31:58Z",
      "mergedAt": "2022-08-31T17:31:58Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "18ad753f12d780ead52b6432f647ce664bda77d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5BGpMi",
          "commit": {
            "abbreviatedOid": "9783e98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-31T17:31:51Z",
          "updatedAt": "2022-08-31T17:31:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOCUe3lM4-ByUn",
      "title": "about constricting all authentication to a service worker",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/18",
      "state": "CLOSED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-30T08:40:05Z",
      "updatedAt": "2022-09-01T08:08:10Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "e9c6fc1683e1a183932629f14a5364372ef96a3e",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "serviceworker-only",
      "headRefOid": "297a79c40b339511140d712f77f0f379a3371258",
      "closedAt": "2022-09-01T08:08:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5BHGUZ",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-31T19:05:16Z",
          "updatedAt": "2022-08-31T19:05:17Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think this line needs to be broken into two steps, to show that the application is asking the service worker to initiate the authorization request.",
              "createdAt": "2022-08-31T19:05:16Z",
              "updatedAt": "2022-08-31T19:05:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BHGkk",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-31T19:06:11Z",
          "updatedAt": "2022-08-31T19:06:11Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "it's not clear whether this \"rest call\" label is associated with the return from the authorization server or is the application calling the service worker. If the latter, then I don't think calling that a \"rest call\" is correct. Maybe just leave this label off?",
              "createdAt": "2022-08-31T19:06:11Z",
              "updatedAt": "2022-08-31T19:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BHGwR",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-31T19:06:53Z",
          "updatedAt": "2022-08-31T19:06:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "let's leave off \"rest\" here since this isn't necessarily limited to REST architectures (and also because people have like 5 different definitions of what a REST API actually is and it's really not important)",
              "createdAt": "2022-08-31T19:06:53Z",
              "updatedAt": "2022-08-31T19:06:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BI-6l",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-01T07:08:37Z",
          "updatedAt": "2022-09-01T07:08:37Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Split it. Please keep in mind that the application doesn't  communicate with the service worker: it does that on its own whenever it is needed. It acts as an authenticating reverse proxy.\r\n\r\nI tried to improve the explanation in my last commit to reflect that better. It could also be further refined in another PR, if needed.",
              "createdAt": "2022-09-01T07:08:37Z",
              "updatedAt": "2022-09-01T07:08:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BJBY6",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-01T07:17:17Z",
          "updatedAt": "2022-09-01T07:17:18Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Replaced \"rest call\" with \"resource request\". Also added some further explanations.",
              "createdAt": "2022-09-01T07:17:17Z",
              "updatedAt": "2022-09-01T07:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5BJCN5",
          "commit": {
            "abbreviatedOid": "347219e"
          },
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-01T07:20:05Z",
          "updatedAt": "2022-09-01T07:20:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Indeed, this is too context-specific. Just replaced it as mentionned above, with some additional explanations.",
              "createdAt": "2022-09-01T07:20:06Z",
              "updatedAt": "2022-09-01T07:20:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOCUe3lM4-MKMA",
      "title": "about constricting all authentication to a service worker",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/19",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-01T08:17:22Z",
      "updatedAt": "2022-09-06T17:50:31Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "e9c6fc1683e1a183932629f14a5364372ef96a3e",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "serviceworker-only",
      "headRefOid": "921c35a4ceaeaf19b4902378a80f9161cb667d29",
      "closedAt": "2022-09-06T17:50:31Z",
      "mergedAt": "2022-09-06T17:50:31Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "e514a8d4b2a81d93e47d0e7ad168a1a76a5255ac"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This looks great. I'm going to merge this and make a few minor tweaks to it.",
          "createdAt": "2022-09-06T17:50:26Z",
          "updatedAt": "2022-09-06T17:50:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 20,
      "id": "PR_kwDOCUe3lM4-mC4S",
      "title": "review of latest feedbacks: restructuring, mitigating attack where a service worker is bypassed",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/20",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-08T12:35:40Z",
      "updatedAt": "2022-09-08T13:10:42Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "b45051375518a6e60474fe54ad182e2c19cc791e",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "after-draft10",
      "headRefOid": "e002298e239d1b1c2430a49b2a20ef44b482bfaa",
      "closedAt": "2022-09-08T13:10:41Z",
      "mergedAt": "2022-09-08T13:10:41Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7424feaa74b764633dc404392d9713d8d12613ea"
      },
      "comments": [
        {
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I moved the considerations about XSS to a general section: all architectures are concerned.\r\n\r\nI added some words about bypassing the Service Worker: this would need a very broad successful XSS, with a much broader attack surface than what is typically the case. This can be mitigated by making sure that registering the service worker is the very first thing happening. There is also no API for unregistering a SW, so it can't be removed after the fact.",
          "createdAt": "2022-09-08T12:42:31Z",
          "updatedAt": "2022-09-08T12:42:31Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I haven't dug too deep yet but isn't this an API to unregister a service worker? https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister",
          "createdAt": "2022-09-08T12:45:58Z",
          "updatedAt": "2022-09-08T12:45:58Z"
        },
        {
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed, this mitigation won't work. I oversaw the registration itself and focused on https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer . I'll rework this and focus on what can be guaranteed by specs.",
          "createdAt": "2022-09-08T13:00:58Z",
          "updatedAt": "2022-09-08T13:00:58Z"
        },
        {
          "author": "ymajoros",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I removed the part about service workers for now. I'll see if I can further improve it in another PR.",
          "createdAt": "2022-09-08T13:07:46Z",
          "updatedAt": "2022-09-08T13:07:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 21,
      "id": "PR_kwDOCUe3lM4-nPov",
      "title": "review feedback: mitigating unregistering SW",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/21",
      "state": "MERGED",
      "author": "ymajoros",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-08T15:34:08Z",
      "updatedAt": "2022-09-12T17:00:08Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "7424feaa74b764633dc404392d9713d8d12613ea",
      "headRepository": "ymajoros/oauth-browser-based-apps",
      "headRefName": "after-draft10-sw",
      "headRefOid": "d5db7507e742bcae798e49b6d2a55f11cb9cb59b",
      "closedAt": "2022-09-12T17:00:08Z",
      "mergedAt": "2022-09-12T17:00:07Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "41f98c94cddbe444c2623a61b27c7ff71a05b656"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "PR_kwDOCUe3lM5YdLu6",
      "title": "Restructured document",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/23",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Restructured the document and added a few TODOs following the discussion with Aaron Parecki at OSW2023.\r\n\r\n- Added more focus on best practices at the start of the document\r\n- Consolidated guidelines for public JS clients in a single section\r\n- Added a section on alternative architectures\r\n\r\nNote that this restructuring is just a first step, leaving the detailed text to be reworded for consistency",
      "createdAt": "2023-08-22T06:18:35Z",
      "updatedAt": "2023-09-01T14:40:11Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "deb248704f4a7911e90db0574df546772e0b8f86",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/restructuring",
      "headRefOid": "3f930e66851bb765f2b9c69009bbc78363899cda",
      "closedAt": "2023-09-01T14:40:11Z",
      "mergedAt": "2023-09-01T14:40:11Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ba0a5d287fa4bdeb62661f58da6debb7246f049b"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I like this for the most part. \r\n\r\nI am not sure I agree with moving the Implicit Flow section into the \"Alternative Architecture Patterns\" section, since that makes it look like a legitimate choice. The idea of including it in the \"Security Considerations\" section was to provide the historical context for it without making it look like a current recommendation. If you are thinking that it isn't appropriate in the Security Considerations section, then maybe we can include it as a new top-level section.",
          "createdAt": "2023-08-28T17:52:34Z",
          "updatedAt": "2023-08-28T17:52:34Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "FYI I pushed this to a branch to trigger the auto-build to review it in the final form, you can view it here:\r\n\r\nhttps://drafts.oauth.net/oauth-browser-based-apps/restructuring/draft-ietf-oauth-browser-based-apps.html",
          "createdAt": "2023-08-28T17:58:34Z",
          "updatedAt": "2023-08-28T17:58:34Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My bad for the delay, I glanced this thread before and assumed that your last comment implied it was being merged. Otherwise I would have given feedback sooner.\r\n\r\nI agree with your comment on the Implicit flow being a bad fit. How about the following changes:\r\n- Move or integrate 6.1 (single-domain apps) in section 4\r\n- Now section 6 only contains \"not relevant\" patterns, so we can rename it to \"Discouraged and Deprecated Architecture Patterns\", which sends a much clearer message",
          "createdAt": "2023-09-01T07:05:44Z",
          "updatedAt": "2023-09-01T07:05:44Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Yes that sounds good to me. I think we also need to rename the header \"First-Party Applications\" to \"Resource Owner Password Grant\" in that case.",
          "createdAt": "2023-09-01T14:07:11Z",
          "updatedAt": "2023-09-01T14:07:11Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I actually think we can keep the \"same-domain\" pattern in the \"discouraged\" section, since the point of that section was to demonstrate why you might want to use OAuth even in the same-domain situation. \r\n\r\nI just pushed a commit to this PR with the reworked headers, so I'll go ahead and merge this now!",
          "createdAt": "2023-09-01T14:39:59Z",
          "updatedAt": "2023-09-01T14:39:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOCUe3lM5ZT3kC",
      "title": "Added section on the threats of malicious JS",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/24",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR contains a major rewrite of this document to better reflect the security challenges of browser-based OAuth clients. The updated spec includes an in-depth analysis of attacks, consequences, and architecture patterns that can be used.\r\n\r\nConcrete changes in this document:\r\n- Added a section on threats of malicios JS (attack payloads and consequences)\r\n- Added a threat analysis to each of the major patterns\r\n- Expanded the three main patterns with relevant details\r\n- Added in-depth discussion of the limitations of Service Workers\r\n- Updated refresh token example (made lifetimes more relevant, clarified that the session is needed instead of the user presence)\r\n- Revisited and expanded the Token Storage section\r\n- Fixed inconsistent capitalization (authorization/resource server, Authorization Code flow)\r\n- Added references",
      "createdAt": "2023-09-01T07:13:07Z",
      "updatedAt": "2023-10-19T14:31:37Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "ab2b41cc24802e3bc575bd8a738dd85bd799adc4",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/threat-malicious-js",
      "headRefOid": "7dd3bc5c6f0b0d2abe424b91711df97e342084d3",
      "closedAt": "2023-10-19T14:31:37Z",
      "mergedAt": "2023-10-19T14:31:37Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "b1479a4c477a596c80ab234d5156a9ddf01a1090"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This is fantastic!",
          "createdAt": "2023-09-01T14:24:12Z",
          "updatedAt": "2023-09-01T14:24:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5fyXNV",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:13:07Z",
          "updatedAt": "2023-09-01T14:13:08Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I think we need another paragraph here to explain that the only countermeasure against this is to not allow flows that transparently redirect. Interrupting the flow and requiring the user to take manual action (e.g. full user authentication each time, or even just clicking \"yes I want to log in\") will prevent this attack. However, such measures are typically unacceptable from a user experience perspective.",
              "createdAt": "2023-09-01T14:13:07Z",
              "updatedAt": "2023-09-01T14:13:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyYPY",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:15:32Z",
          "updatedAt": "2023-09-01T14:15:32Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nThis attack scenario takes a different approach. Instead of abusing the application to obtain tokens, the attacker will send requests directly from within the OAuth client application running in the user's browser. The requests sent by the attacker are indistinguishable from requests sent by the legitimate application. This scenario consists of the following steps:\r\n```",
              "createdAt": "2023-09-01T14:15:32Z",
              "updatedAt": "2023-09-01T14:15:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyYkV",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:16:22Z",
          "updatedAt": "2023-09-01T14:16:22Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThis section presents several malicious scenarios that an attacker can execute once they have found a vulnerability that allows the execution of malicious JavaScript code. The attack scenarios range from extremely trivial ({{payload-single-theft}}) to highly sophisticated ({{payload-new-flow}}). Note that this enumeration is non-exhaustive and presented in no particular order.\r\n```",
              "createdAt": "2023-09-01T14:16:22Z",
              "updatedAt": "2023-09-01T14:16:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyZ1A",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:19:20Z",
          "updatedAt": "2023-09-01T14:19:20Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nThe attack ends when the access token expires, or when a token is revoked with the authorization server. In a typical browser-based OAuth client, access token lifetimes can be quite short, ranging from minutes to hours.\r\n```\r\n\r\n(it's possible to have revocation lists for JWT tokens, see [JWT and CWT status list](https://www.ietf.org/archive/id/draft-looker-oauth-jwt-cwt-status-list-01.html) for a mechanism that was discussed at the last IETF meeting)",
              "createdAt": "2023-09-01T14:19:20Z",
              "updatedAt": "2023-09-01T14:19:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyaAL",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:19:44Z",
          "updatedAt": "2023-09-01T14:19:45Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "```suggestion\r\nNote that the possession of the access token allows its unrestricted use by the attacker. The attacker can send arbitrary requests to resource servers, using any HTTP method, destination URL, header values, or body.\r\n```",
              "createdAt": "2023-09-01T14:19:44Z",
              "updatedAt": "2023-09-01T14:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fybqx",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:23:24Z",
          "updatedAt": "2023-09-01T14:23:24Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "This should include a paragraph discussing DPoP, to mention both:\r\n\r\n* DPoP does effectively prevent the attacker from using a stolen token (if bound to a nonexportable key), but\r\n* the attacker may be able to obtain their own DPoP-bound tokens as described in {{payload-new-flow}}",
              "createdAt": "2023-09-01T14:23:24Z",
              "updatedAt": "2023-09-01T14:23:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyodZ",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:46:19Z",
          "updatedAt": "2023-09-01T14:46:19Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "```suggestion\r\nThere are no security mechanisms for frontend applications that counter this attack scenario. Short access token lifetimes and refresh token rotation are ineffective, since the attacker has a fresh, independent set of tokens. Advanced security mechanism, such as DPoP ({{DPoP}}) are equally ineffective, since the attacker can use their own key pair to setup and use DPoP for the newly obtained tokens.\r\n```",
              "createdAt": "2023-09-01T14:46:19Z",
              "updatedAt": "2023-09-01T14:46:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5fyojL",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-01T14:46:33Z",
          "updatedAt": "2023-09-01T14:46:33Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nThis attack pattern is well-known and also occurs with traditional applications using HttpOnly session cookies. It is commonly accepted that this scenario cannot be stopped or prevented by application-level security measures. For example, the DPoP specification ({{DPoP}}) explicitly considers this attack scenario to be out of scope.\r\n```",
              "createdAt": "2023-09-01T14:46:33Z",
              "updatedAt": "2023-09-01T14:46:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5hHL2F",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T15:50:42Z",
          "updatedAt": "2023-09-15T15:50:42Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Fixed in upcoming commit",
              "createdAt": "2023-09-15T15:50:42Z",
              "updatedAt": "2023-09-15T15:50:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5hHL8P",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T15:50:56Z",
          "updatedAt": "2023-09-15T15:50:57Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Fixed in upcoming commit",
              "createdAt": "2023-09-15T15:50:57Z",
              "updatedAt": "2023-09-15T15:50:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5hHM5_",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T15:52:32Z",
          "updatedAt": "2023-09-15T15:52:32Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "cool, I did not know this. updated text.",
              "createdAt": "2023-09-15T15:52:32Z",
              "updatedAt": "2023-09-15T15:52:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5hHNGQ",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T15:52:54Z",
          "updatedAt": "2023-09-15T15:52:54Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Fixed",
              "createdAt": "2023-09-15T15:52:54Z",
              "updatedAt": "2023-09-15T15:52:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5hHQgZ",
          "commit": {
            "abbreviatedOid": "38ede31"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T16:01:21Z",
          "updatedAt": "2023-09-15T16:01:22Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Added in new commit",
              "createdAt": "2023-09-15T16:01:21Z",
              "updatedAt": "2023-09-15T16:01:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5kDt6Z",
          "commit": {
            "abbreviatedOid": "b00130c"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-15T06:38:24Z",
          "updatedAt": "2023-10-15T06:38:24Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The last sentence already covers this case: `Additionally, authorization server behavior that would force every authorization code flow to require user interaction would significantly impact widely-established patterns, such as silently bootstrapping an application with tokens, or Single Sign-On across multiple related applications.`. I have not changed this, but if you feel it warrants more explanation, we should look into that when finetuning everything.",
              "createdAt": "2023-10-15T06:38:24Z",
              "updatedAt": "2023-10-15T06:38:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5km3Re",
          "commit": {
            "abbreviatedOid": "7dd3bc5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T14:31:30Z",
          "updatedAt": "2023-10-19T14:31:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOCUe3lM5iA1_9",
      "title": "Fix minor editorial issues",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/28",
      "state": "MERGED",
      "author": "iphoneintosh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "* Remove doubled \"... section Section ...\"\r\n* Replace \"BFF\" with \"token-mediating backend\" in token-mediating backend section\r\n* Remote redundant \"In browser\" wording",
      "createdAt": "2023-12-14T15:09:44Z",
      "updatedAt": "2024-02-13T22:14:51Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "5d2a4cd84e8d4ce47ef3f0bfcf74404b5d22a3f8",
      "headRepository": "iphoneintosh/oauth-browser-based-apps",
      "headRefName": "fix-editorial-issues",
      "headRefOid": "48be6c1bcb6fc63fc6e75b51bf04bd6a0d3434eb",
      "closedAt": "2024-02-13T22:14:51Z",
      "mergedAt": "2024-02-13T22:14:51Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ba6c495f0f0ac5017543aa0936ec87a5d5537e1d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOCUe3lM5iluJO",
      "title": "Added section on the security of in-browser communication flows",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/29",
      "state": "MERGED",
      "author": "iphoneintosh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the OSW, this PR adds a small section with security considerations on the use of `postMessage` (a.k.a. \"web messaging\") to this draft. It makes reference to [Section 4.18 of the OAuth BCP](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24#name-attacks-on-in-browser-commu), which already discusses the security implications of in-browser communication flows in detail.\r\n\r\nSince (silent) iframe flows and popup flows are especially used in browser-based apps, we think that it makes sense to include security considerations of their in-browser communication into this draft. Please let us know what you think about this. We appreciate any feedback.",
      "createdAt": "2023-12-21T16:43:52Z",
      "updatedAt": "2024-02-17T00:14:52Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "5d2a4cd84e8d4ce47ef3f0bfcf74404b5d22a3f8",
      "headRepository": "iphoneintosh/oauth-browser-based-apps",
      "headRefName": "inbc-security-considerations",
      "headRefOid": "e1da28f8eb77ac158e145f4118b6723c236d5bbf",
      "closedAt": "2024-02-17T00:14:52Z",
      "mergedAt": "2024-02-17T00:14:52Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "de70195fda83a6a563ebfd4bd1342a346312b188"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Sounds good to me, thanks!",
          "createdAt": "2024-02-17T00:14:42Z",
          "updatedAt": "2024-02-17T00:14:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOCUe3lM5kP4yT",
      "title": "IETF 118 followup review",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/30",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A followup review with suggestions as requested at IETF 118",
      "createdAt": "2024-01-16T21:18:24Z",
      "updatedAt": "2024-02-25T08:24:26Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "5d2a4cd84e8d4ce47ef3f0bfcf74404b5d22a3f8",
      "headRepository": "panva/oauth-browser-based-apps",
      "headRefName": "filip-review",
      "headRefOid": "e718520f2c1151625b07781927624d241dcf5a05",
      "closedAt": "2024-02-13T18:28:33Z",
      "mergedAt": "2024-02-13T18:28:33Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6f12ac032a426d52f5a471f21872c5442d5f8cf0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5vlVzp",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:18:47Z",
          "updatedAt": "2024-02-09T10:18:47Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Note: flows may be referred to as silent, iframes in such flows OTOH are hidden",
              "createdAt": "2024-02-09T10:18:47Z",
              "updatedAt": "2024-02-09T10:18:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vlWfN",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:20:24Z",
          "updatedAt": "2024-02-09T10:20:24Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Note: we cannot say this pattern exlusively uses client_secret based flows, it may also use private key jwt or mtls.",
              "createdAt": "2024-02-09T10:20:24Z",
              "updatedAt": "2024-02-09T10:20:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vlX35",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:23:47Z",
          "updatedAt": "2024-02-09T10:23:47Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "there is no interoperable mechanism for signalling refresh token expiration, it may be known or disclosed but we cannot say that all clients know how long their refresh tokens will survive",
              "createdAt": "2024-02-09T10:23:47Z",
              "updatedAt": "2024-02-09T10:23:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vlZKN",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:26:53Z",
          "updatedAt": "2024-02-09T10:26:53Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "I would actually suggest to include a guideline here which is to\r\n\r\n- have Origin allow-list pre-registerable or even required for browser based applications\r\n- implement preflights that are wildcard and/or limited\r\n- figure out the client_id from the actual request (client_id in body, aud/azp in tokens) and check the origin matches one that is pre-registered, otherwise error the response and/or remove the actual responses' CORS headers to have the browser hide the response properties.",
              "createdAt": "2024-02-09T10:26:53Z",
              "updatedAt": "2024-02-09T10:26:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vlaMz",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:29:20Z",
          "updatedAt": "2024-02-09T10:29:20Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "If we don't mention the intended way to persist non-extractable CryptoKey instances a developer will realize they can't serialize the non-extractable key and resolve into making it extractable and subsequently just serializing it to JWK and store it using other storage mechanisms.\r\n\r\nUsing IndexedDB and non-extractable CryptoKey has at least the benefit of not allowing the CryptoKey to be exfiltrated by an online attack.\r\n\r\nYes it's still vulnerable to reading the serialized data off disk but that's a different vector.",
              "createdAt": "2024-02-09T10:29:20Z",
              "updatedAt": "2024-02-09T10:29:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vlaeK",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T10:29:59Z",
          "updatedAt": "2024-02-09T10:29:59Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Note: we're not using unmodified, we require the PKCE extension to be used.",
              "createdAt": "2024-02-09T10:29:59Z",
              "updatedAt": "2024-02-09T10:29:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5vm7lb",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T14:02:06Z",
          "updatedAt": "2024-02-09T14:02:06Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Note: the javascript application has no way of determining the access token is *expired* given the only reliable information it would get is a www-authenticate header with an error=invalid_token property, the optional error_description may include this detail but should not be relied on because of its free form unstructured contents.",
              "createdAt": "2024-02-09T14:02:06Z",
              "updatedAt": "2024-02-09T14:02:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2TjK",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T22:49:50Z",
          "updatedAt": "2024-02-12T22:49:50Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I believe the idea was to pass the `expires_in` [back to the browser](https://datatracker.ietf.org/doc/html/draft-bertocci-oauth2-tmi-bff-01#name-access-token-response) for this, but I agree this reads better anyway.",
              "createdAt": "2024-02-12T22:49:50Z",
              "updatedAt": "2024-02-12T22:49:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2VPG",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T22:56:23Z",
          "updatedAt": "2024-02-12T22:56:23Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "```suggestion\r\nclient, since there is no way to provision it with client credentials in this model.\r\n```",
              "createdAt": "2024-02-12T22:56:23Z",
              "updatedAt": "2024-02-12T22:56:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2Vgy",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T22:57:29Z",
          "updatedAt": "2024-02-12T22:57:29Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nWhen no active session is found, the JavaScript application calls out to the token-mediating backend (C) to initiate the Authorization Code flow with the PKCE extension (described in {{pattern-tmb-flow}}), to which the token-mediating backend responds by redirecting the browser to the authorization endpoint (D). When the user is redirected back, the browser delivers the authorization code to the token-mediating backend (E), where the token-mediating backend can then exchange it for tokens at the token endpoint (F) using its client credentials and PKCE code verifier.\r\n```",
              "createdAt": "2024-02-12T22:57:29Z",
              "updatedAt": "2024-02-12T22:57:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2VnJ",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T22:57:51Z",
          "updatedAt": "2024-02-12T22:57:51Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "```suggestion\r\nextension (described in {{pattern-bff-flow}}), to which the BFF responds by redirecting the browser to the authorization endpoint (D). When the user is redirected back, the browser delivers the authorization code to the BFF (E), where the BFF can then exchange it for tokens at the token endpoint (F) using its client credentials and PKCE code verifier.\r\n```",
              "createdAt": "2024-02-12T22:57:51Z",
              "updatedAt": "2024-02-12T22:57:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2VuE",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T22:58:16Z",
          "updatedAt": "2024-02-12T22:58:16Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "How about \"credentials\" instead of secret? The point is to make an obvious distinction that this client is using credentials in this version.",
              "createdAt": "2024-02-12T22:58:16Z",
              "updatedAt": "2024-02-12T22:58:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2WqP",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T23:01:58Z",
          "updatedAt": "2024-02-12T23:01:59Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nhowever, that the browser will typically do a \"preflight\" request to check to see\r\n```",
              "createdAt": "2024-02-12T23:01:58Z",
              "updatedAt": "2024-02-12T23:01:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2g3s",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T23:39:13Z",
          "updatedAt": "2024-02-12T23:39:13Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "That sounds like it will require a lot of additional text to justify those recommendations.",
              "createdAt": "2024-02-12T23:39:13Z",
              "updatedAt": "2024-02-12T23:39:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5v2hgG",
          "commit": {
            "abbreviatedOid": "d015b2d"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "see suggestions inline",
          "createdAt": "2024-02-12T23:40:04Z",
          "updatedAt": "2024-02-12T23:40:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCUe3lM5v-igg",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-13T18:26:57Z",
          "updatedAt": "2024-02-13T18:26:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCUe3lM5wfC0x",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Hey @panva, thanks for the detailed review!\r\n\r\n@aaronpk I am aware that this is merged already, but I added a bunch of comments that I believe need addressing. Let me know if you need any more input from me.",
          "createdAt": "2024-02-18T09:53:37Z",
          "updatedAt": "2024-02-18T10:08:29Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I don't believe that the consistent rewording to `execution context` is accurate in this context. It is true that the code runs in the execution context, but the underlying security model of the browser is based on origins (Same-Origin Policy). When two execution contexts have the same origin and have a direct reference to each other, they are not isolated (e.g., a parent window and a frame). \r\n\r\nI strongly recommend to stick with `origin`. Alternatively, we should add a note to explain this context.",
              "createdAt": "2024-02-18T09:53:38Z",
              "updatedAt": "2024-02-18T10:08:29Z"
            },
            {
              "originalPosition": 66,
              "body": "Doesn't the silent apply to the \"flow\" here? As in `silent ... flow`? The attack does not rely on the frame being hidden, but on the attackers ability to run a flow that does not require user interaction, so the __silent__ modifier is more important/accurate than the __hidden__ modifier.",
              "createdAt": "2024-02-18T09:55:56Z",
              "updatedAt": "2024-02-18T10:08:29Z"
            },
            {
              "originalPosition": 169,
              "body": "This is not correct. The browser only uses preflights for CORS-safelisted requests (i.e., anything that cannot be sent without modifying a request through JS). A simple GET or POST without custom headers or without a custom content type will not require a preflight.",
              "createdAt": "2024-02-18T10:02:57Z",
              "updatedAt": "2024-02-18T10:08:29Z"
            },
            {
              "originalPosition": 180,
              "body": "I am assuming you are hinting at a dynamic CORS configuration where the AS uses the client ID to lookup a configuration and determine if this origin is legitimate? If that is indeed true, I don't think enforcement through CORS would be a correct implementation technique. I consider it application-level logic, akin to checking a redirect URI during an OAuth flow. As such, I would handle this as an application-level error instead of an *invalid CORS request*.\r\n\r\nI am not objecting against this, but I believe it needs a bit more explaining when it is left in. This will not be obvious to someone without proper context.",
              "createdAt": "2024-02-18T10:06:22Z",
              "updatedAt": "2024-02-18T10:08:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5wfE0B",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T10:11:48Z",
          "updatedAt": "2024-02-18T10:11:48Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Explaining either one of the two that you think is more appropriate is definitely needed. I don't think origin is any better to execution context without an explanation of what we mean by it.",
              "createdAt": "2024-02-18T10:11:48Z",
              "updatedAt": "2024-02-18T10:11:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5wfFmz",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T10:26:05Z",
          "updatedAt": "2024-02-18T10:26:05Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "A simple request won't get a preflight, right, feel free to reword the conditions which are currently summarized as \"typically\".\r\n\r\nIt needs to be mentioned (at least here) that when one uses DPoP there are no more simple requests. Having had written not one browser based client I am no longer envisioning typical operation to be without preflights.",
              "createdAt": "2024-02-18T10:26:05Z",
              "updatedAt": "2024-02-18T10:28:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5wfF1p",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T10:29:57Z",
          "updatedAt": "2024-02-18T10:29:57Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "It is not enforced through CORS, the request would still fail with a proper oauth error, but it is through CORS that we ensure even these error responses don't get read from unintended origins.",
              "createdAt": "2024-02-18T10:29:57Z",
              "updatedAt": "2024-02-18T10:29:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5wfLbj",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T11:57:27Z",
          "updatedAt": "2024-02-18T11:57:27Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "So the scenario would be as follows:\r\n\r\nThe AS has client 1 with origin A and client B with origin B. Upon handling a preflight, it sees a request coming from origin B, so it allows the request to go through. Upon handling the request, the AS sees that client 1 does not have origin B approved, so it issues an error message. However, additionally, it should not set the CORS header that allows origin B to read this response.\r\n\r\nIs that a correct description? If so, I think we need to add this context in the document to make this point clear. We probably also need to make this a SHOULD requirement for the AS (as I don't think we can make it a MUST)",
              "createdAt": "2024-02-18T11:57:27Z",
              "updatedAt": "2024-02-18T11:57:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5wfLib",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T12:00:22Z",
          "updatedAt": "2024-02-18T12:00:22Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "It's currently a Note and I think that's enough to give guidance. I wouldn't make this normative in any way.",
              "createdAt": "2024-02-18T12:00:22Z",
              "updatedAt": "2024-02-18T12:00:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5xOfXL",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T08:03:56Z",
          "updatedAt": "2024-02-25T08:03:56Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Reworded to clarify what it means.",
              "createdAt": "2024-02-25T08:03:56Z",
              "updatedAt": "2024-02-25T08:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5xOf2I",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T08:16:18Z",
          "updatedAt": "2024-02-25T08:16:18Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "I understand your point of view, but vanilla OAuth requests with form encoding would be simple requests. Reworded the text to add the necessary context.",
              "createdAt": "2024-02-25T08:16:18Z",
              "updatedAt": "2024-02-25T08:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5xOgKE",
          "commit": {
            "abbreviatedOid": "e718520"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T08:24:25Z",
          "updatedAt": "2024-02-25T08:24:26Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Sounds good. I have rephrased this to include a bit more details on an example.",
              "createdAt": "2024-02-25T08:24:25Z",
              "updatedAt": "2024-02-25T08:24:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOCUe3lM5nKFKi",
      "title": "more silent frame edits",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/33",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-17T09:15:43Z",
      "updatedAt": "2024-02-22T06:31:39Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "c593337de1055185b9d41783bf3e16ac922f9231",
      "headRepository": "panva/oauth-browser-based-apps",
      "headRefName": "more-edit",
      "headRefOid": "776a156f18527511982ff33f8955a67989a549ee",
      "closedAt": "2024-02-21T21:34:05Z",
      "mergedAt": "2024-02-21T21:34:05Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "5715598fdf2964a2af01277755540f0882aa1e00"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5w6y5H",
          "commit": {
            "abbreviatedOid": "776a156"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T21:34:00Z",
          "updatedAt": "2024-02-21T21:34:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOCUe3lM5nNIxR",
      "title": "6.1.3.3.3. Use Anti-forgery/double submit cookies",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/34",
      "state": "MERGED",
      "author": "damienbod",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes https://github.com/oauth-wg/oauth-browser-based-apps/issues/26\r\n",
      "createdAt": "2024-02-18T07:23:03Z",
      "updatedAt": "2024-02-21T21:36:19Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "c593337de1055185b9d41783bf3e16ac922f9231",
      "headRepository": "damienbod/oauth-browser-based-apps",
      "headRefName": "feature/6-1-3-3-use-Anti-forgery",
      "headRefOid": "7831ad2b4eb688a846ddc8a22aed592f895ed120",
      "closedAt": "2024-02-21T21:36:18Z",
      "mergedAt": "2024-02-21T21:36:18Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "38c71730d16b1b5da783e644aaa4a33b02331040"
      },
      "comments": [
        {
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @philippederyck I like it, I updated the PR",
          "createdAt": "2024-02-18T10:52:37Z",
          "updatedAt": "2024-02-18T10:52:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5wfCiY",
          "commit": {
            "abbreviatedOid": "df048fb"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the suggestion @damienbod. I believe it is important to explain why this addition is there, so I've taken a stab at rewording (see below). \r\n\r\nI have also removed some of the implementation details that are not necessarily relevant (e.g., the use of HTTPS). I also removed the note on encryption, since the value in the cookie is typically random, so there would be no need to encrypt the cookie. \r\n\r\nLet me know what you think.\r\n\r\n\r\n\r\n```\r\nSome technology stacks and frameworks have built-in CRSF protection using anti-forgery cookies. This mechanism relies on a session-specific secret that is stored in a cookie, which can only be read by the legitimate frontend running in the domain associated with the cookie. The frontend is expected to read the cookie and insert its value into the request, typically by adding a custom request header. The backend verifies the value in the cookie to the value provided by the frontend to identity legitimate requests. When implemented correctly for all state changing requests, this mechanism effectively mitigates CSRF.\r\n\r\nNote that this mechanism is not necessarily recommended over the CORS approach. However, if a framework offers built-in support for this mechanism, it can serve as a low-effort alternative to protect against CSRF.\r\n```",
          "createdAt": "2024-02-18T09:47:13Z",
          "updatedAt": "2024-02-18T09:47:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCUe3lM5w6zc-",
          "commit": {
            "abbreviatedOid": "7831ad2"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T21:35:28Z",
          "updatedAt": "2024-02-21T21:35:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOCUe3lM5nNjJe",
      "title": "Reworded *significant burden*",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/36",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR resolves issue #25 by rephrasing the *significant burden* of having a BFF",
      "createdAt": "2024-02-18T10:18:10Z",
      "updatedAt": "2024-02-22T17:25:34Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "c593337de1055185b9d41783bf3e16ac922f9231",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/25-address-language",
      "headRefOid": "545b9aec335a524b6ddd1317a230240a68fe043f",
      "closedAt": "2024-02-22T17:25:34Z",
      "mergedAt": "2024-02-22T17:25:34Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "afe2b1ea6436c9d9fe54e1fdca179ea40196b8eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5wfS6x",
          "commit": {
            "abbreviatedOid": "ca5aa7b"
          },
          "author": "damienbod",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T14:28:42Z",
          "updatedAt": "2024-02-18T14:28:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "How about adding this as well?\r\n\r\n```\r\nA proxy is not required, if the resource server and the BFF server are the same. \r\n```\r\n",
              "createdAt": "2024-02-18T14:28:42Z",
              "updatedAt": "2024-02-18T14:28:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5w7FK8",
          "commit": {
            "abbreviatedOid": "ca5aa7b"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T22:28:35Z",
          "updatedAt": "2024-02-21T22:28:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I feel like this needs to link to [6.1.2.4](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-16#section-6.1.2.4), which already mentions that no proxying is necessary in that situation. How about this instead:\r\n\r\n> See Section 6.1.2.4 for additional notes if the BFF is acting as the resource server.",
              "createdAt": "2024-02-21T22:28:35Z",
              "updatedAt": "2024-02-21T22:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM5xCTcZ",
          "commit": {
            "abbreviatedOid": "ca5aa7b"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-22T17:23:27Z",
          "updatedAt": "2024-02-22T17:23:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nTo summarize, the architecture of a BFF is significantly more complicated than a browser-only application. It requires deploying and operating a server-side BFF component. Additionally, this pattern requires all interactions between the JavaScript application and the resource servers to be proxied by the BFF. Depending on the deployment pattern, this proxy behavior can add a significant burden on the server-side components. See {{practical-deployment-scenarios}} for additional notes if the BFF is acting as the resource server.\r\n```",
              "createdAt": "2024-02-22T17:23:27Z",
              "updatedAt": "2024-02-22T17:23:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOCUe3lM5nNsQY",
      "title": "Addressed comments from Elar Lang",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/37",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR incorporates a bunch of comments made by Elar Lang via mail.",
      "createdAt": "2024-02-18T11:47:22Z",
      "updatedAt": "2024-02-21T21:52:03Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "b5baa7e8d4c1c85997e7b2bd5023c510222cdb82",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/review-elar-lang",
      "headRefOid": "9119a78421ddbc2ca650e478267080211ea53225",
      "closedAt": "2024-02-21T21:52:03Z",
      "mergedAt": "2024-02-21T21:52:03Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "c807e83ca1c0a0084264c4ba593096e77441093c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5w65Jx",
          "commit": {
            "abbreviatedOid": "9119a78"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T21:51:57Z",
          "updatedAt": "2024-02-21T21:51:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "PR_kwDOCUe3lM5nNsdt",
      "title": "Moved new section on in-browser flows",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/38",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The new section on the security of in-browser communication flows only applies to the browser-based OAuth client. It does not apply to the BFF or TM Backend. Therefore, I moved this section to the security considerations of the relevant pattern.",
      "createdAt": "2024-02-18T11:50:41Z",
      "updatedAt": "2024-02-21T21:47:08Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "38c71730d16b1b5da783e644aaa4a33b02331040",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/move-inbrowser-flows",
      "headRefOid": "8fbf58f134fb39c2f533cdf1a40e1ff0e7760d95",
      "closedAt": "2024-02-21T21:47:08Z",
      "mergedAt": "2024-02-21T21:47:08Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "b5baa7e8d4c1c85997e7b2bd5023c510222cdb82"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5w63R3",
          "commit": {
            "abbreviatedOid": "8fbf58f"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T21:46:30Z",
          "updatedAt": "2024-02-21T21:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 39,
      "id": "PR_kwDOCUe3lM5n1gdm",
      "title": "Reworded text based on PR comments",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/39",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reworded the text based on the discussion in [PR #30](https://github.com/oauth-wg/oauth-browser-based-apps/pull/30)\r\n\r\nThis PR resolves issue #35 ",
      "createdAt": "2024-02-25T08:26:03Z",
      "updatedAt": "2024-02-28T23:05:29Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "afe2b1ea6436c9d9fe54e1fdca179ea40196b8eb",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/35-review-pr-30",
      "headRefOid": "9c7d6f471ebd1cbcea49bdf1a8e0a37e9f8d0411",
      "closedAt": "2024-02-28T23:05:29Z",
      "mergedAt": "2024-02-28T23:05:29Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7cd74c4c81d422f96864fc2bc3b316366ebfdc6b"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you both!",
          "createdAt": "2024-02-28T23:05:24Z",
          "updatedAt": "2024-02-28T23:05:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM5xOlxK",
          "commit": {
            "abbreviatedOid": "9c7d6f4"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-25T10:45:47Z",
          "updatedAt": "2024-02-25T10:45:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOCUe3lM5p23Zt",
      "title": "Add BFF advice for performance purposes",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/40",
      "state": "CLOSED",
      "author": "emmanuelgautier",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As the Token Mediating Backend may be considered for performance reason sometimes, this PR shared an alternative solution.\r\nMost of the time, the resource servers are deployed with a proxy handling incoming request. Re-using those components may be a solution to not degrade security, not degrades performance, and be an alternative to use Token Mediating Backend pattern.\r\n\r\nA not answered question in this PR is how to shared relevant informations to handle cookies decryption when applied. Does this RFC should handle this question?",
      "createdAt": "2024-03-17T10:46:26Z",
      "updatedAt": "2024-04-13T15:00:35Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "741f8820be57a2a29c60d7713b5655031279a04a",
      "headRepository": "emmanuelgautier/oauth-browser-based-apps",
      "headRefName": "resource-proxy-reusage",
      "headRefOid": "8da66994e92b7683d1d3a16f5c03d1789474f48f",
      "closedAt": "2024-04-13T15:00:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You're absolutely right that there is a lot of freedom in deciding how to implement the BFF or TM-BFF pattern. If there are pre-existing architecture components that can handle some of the heavy lifting, you are definitely encouraged to do so. \r\n\r\nWith that in mind, it is important to note that neither the BFF nor the TM-BFF require actual changes on the part of the resource server. It received an access token before, and it still receives an access token now. The specifics of how you implement the handling of that access token are out of scope for OAuth in general, and for this document as well. \r\n\r\nIn a nutshell, I don't think this PR addresses a core issue or adds an in-scope clarification, so I would not include it. ",
          "createdAt": "2024-03-18T05:47:00Z",
          "updatedAt": "2024-03-18T05:47:00Z"
        },
        {
          "author": "emmanuelgautier",
          "authorAssociation": "NONE",
          "body": "Thanks for your review @philippederyck. I agree with you, this is not a core issue but more a deployment advice as it already exist some in the draft.\r\n\r\nThis PR intends to add a reminder about this implementation freedom and avoid wrong choice with TM-BFF based on performance reasons.\r\n\r\nAs there exists some architecture where the performance is critical but still exists some misconception on how to implement BFF, the latency reason could drive the decision to choose TM-BFF instead of BFF.\r\n\r\nMaybe the latency reason to choose TM-BFF can be removed to avoid confusion? ",
          "createdAt": "2024-03-18T09:27:50Z",
          "updatedAt": "2024-03-18T09:27:50Z"
        },
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe the latency reason to choose TM-BFF can be removed to avoid confusion?\r\n\r\nI agree that this suggestion makes sense. I have made the necessary changes in #47. \r\n\r\n@aaronpk if #47 is acceptable, this PR can be closed.",
          "createdAt": "2024-04-11T05:27:36Z",
          "updatedAt": "2024-04-11T05:27:46Z"
        },
        {
          "author": "emmanuelgautier",
          "authorAssociation": "NONE",
          "body": "I am OK with the new PR. Thanks for the rewording.",
          "createdAt": "2024-04-13T15:00:31Z",
          "updatedAt": "2024-04-13T15:00:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 45,
      "id": "PR_kwDOCUe3lM5qlIv5",
      "title": "Processed review from Justin Richer",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/45",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-24T09:40:52Z",
      "updatedAt": "2024-05-01T17:03:17Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "741f8820be57a2a29c60d7713b5655031279a04a",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/review-justin-richer",
      "headRefOid": "5cbdc2233c68a482fa8b48240b1724076ca2766d",
      "closedAt": "2024-05-01T17:03:16Z",
      "mergedAt": "2024-05-01T17:03:16Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6b9d710c032187891f9153ea7972562ebd10bf3e"
      },
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk Everything is handled. The author error is also fixed, so LGTM",
          "createdAt": "2024-04-11T16:03:47Z",
          "updatedAt": "2024-04-11T16:03:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM50wIPd",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T20:59:20Z",
          "updatedAt": "2024-03-25T20:59:20Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Was there a reason to remove the mention of Web Assembly?",
              "createdAt": "2024-03-25T20:59:20Z",
              "updatedAt": "2024-03-25T20:59:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wNza",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:13:53Z",
          "updatedAt": "2024-03-25T21:13:53Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "```suggestion\r\nWhen the refresh token expires, there is no way to obtain a valid access token without running an entirely new Authorization Code flow. Therefore, it is recommended to configure the lifetime of the cookie-based session managed by the BFF to be equal to the maximum lifetime of the refresh token. Additionally, when the BFF learns that a refresh token for an active session is no longer valid, it is recommended to invalidate the session.\r\n```",
              "createdAt": "2024-03-25T21:13:53Z",
              "updatedAt": "2024-03-25T21:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wN3K",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:14:03Z",
          "updatedAt": "2024-03-25T21:14:03Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "this one should stay as \"flow\"",
              "createdAt": "2024-03-25T21:14:03Z",
              "updatedAt": "2024-03-25T21:14:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wOF3",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:14:45Z",
          "updatedAt": "2024-03-25T21:14:46Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nIn this advanced attack scenario, the attacker completely disregards any tokens that the application has already obtained. Instead, the attacker takes advantage of the ability to run malicious code that is associated with the application's origin. With that ability, the attacker can inject a hidden iframe and launch a silent Authorization Code flow. This silent flow will reuse the user's existing session with the authorization server and result in the issuing of a new, independent set of tokens. This scenario consists of the following steps:\r\n```\r\n\r\nThis one reads better as \"flow\"",
              "createdAt": "2024-03-25T21:14:46Z",
              "updatedAt": "2024-03-25T21:14:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wOrJ",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:16:26Z",
          "updatedAt": "2024-03-25T21:16:26Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "```suggestion\r\nThe most important takeaway from this scenario is that it runs a new OAuth flow instead of focusing on stealing existing tokens. In essence, even if the application finds a token storage mechanism with perfect security, the attacker will still be able to request a new set of tokens. Note that because the attacker controls the application in the browser, the attacker's Authorization Code flow is indistinguishable from a legitimate Authorization Code flow.\r\n```\r\n\r\nThis one should stay as \"flow\" since the paragraph started by referring to \"a new OAuth flow\".",
              "createdAt": "2024-03-25T21:16:26Z",
              "updatedAt": "2024-03-25T21:16:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wRcY",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:24:36Z",
          "updatedAt": "2024-03-25T21:24:36Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "```suggestion\r\nWhen the attacker obtains a valid refresh token from a browser-based OAuth client, they can abuse the refresh token by running a Refresh Token grant with the authorization server. The response of the Refresh Token grant contains an access token, which gives the attacker the ability to access protected resources (See {{consequence-at}}). In essence, abusing a stolen refresh token enables long-term impersonation of the legitimate client application to resource servers.\r\n```\r\n\r\nIt is a either a \"grant\" or \"flow\" when referring to the actual request.",
              "createdAt": "2024-03-25T21:24:36Z",
              "updatedAt": "2024-03-25T21:24:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wRvF",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:25:31Z",
          "updatedAt": "2024-03-25T21:25:31Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "```suggestion\r\nIf the BFF notices that the user's access token has expired and the BFF has a refresh token, it can use the refresh token to obtain a fresh access token. These steps are not shown in the diagram, but would occur between step J and K. Note that this BFF client is a confidential client, so it will use its client authentication in the refresh token request.\r\n```",
              "createdAt": "2024-03-25T21:25:31Z",
              "updatedAt": "2024-03-25T21:25:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wSBq",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:26:26Z",
          "updatedAt": "2024-03-25T21:26:26Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "```suggestion\r\n#### The Authorization Code Grant {#pattern-bff-flow}\r\n```",
              "createdAt": "2024-03-25T21:26:26Z",
              "updatedAt": "2024-03-25T21:26:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wShx",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:27:59Z",
          "updatedAt": "2024-03-25T21:27:59Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "This should be \"triggers a navigation\" instead of \"calls out\" just like [this line](https://github.com/oauth-wg/oauth-browser-based-apps/pull/45/files#diff-b8a39beaf896e9ec278c32c7ce5f353a35d1a54b46cc14edd775e65183f51c70R436), right?",
              "createdAt": "2024-03-25T21:27:59Z",
              "updatedAt": "2024-03-25T21:28:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wS-j",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:29:24Z",
          "updatedAt": "2024-03-25T21:29:24Z",
          "comments": [
            {
              "originalPosition": 411,
              "body": "```suggestion\r\nWhen the refresh token expires, there is no way to obtain a valid access token without starting an entirely new Authorization Code grant. Therefore, it is recommended to configure the lifetime of the cookie-based session to be equal to the maximum lifetime of the refresh token if such information is known upfront. Additionally, when the token-mediating backend learns that a refresh token for an active session is no longer valid, it is recommended to invalidate the session.\r\n```",
              "createdAt": "2024-03-25T21:29:24Z",
              "updatedAt": "2024-03-25T21:29:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wTWa",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:30:32Z",
          "updatedAt": "2024-03-25T21:30:32Z",
          "comments": [
            {
              "originalPosition": 607,
              "body": "```suggestion\r\nThe authorization server could opt to make user consent mandatory in every Authorization Code flow (as described in Section 10.2 OAuth 2.0 {{RFC6749}}), thus requiring user interaction before issuing an authorization code. This approach would make it harder for an attacker to run a silent flow to obtain a fresh set of tokens. However, it also significantly impacts the user experience by continuously requiring consent. As a result, this approach would result in \"consent fatigue\", which makes it likely that the user will blindly approve the consent, even when it is associated with a flow that was initialized by the attacker.\r\n```",
              "createdAt": "2024-03-25T21:30:32Z",
              "updatedAt": "2024-03-25T21:30:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wTi5",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:31:09Z",
          "updatedAt": "2024-03-25T21:31:09Z",
          "comments": [
            {
              "originalPosition": 631,
              "body": "```suggestion\r\nOAuth Implicit Grant {#implicit_flow}\r\n```\r\n\r\nMatches the section heading of RFC6749 this way",
              "createdAt": "2024-03-25T21:31:09Z",
              "updatedAt": "2024-03-25T21:31:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wTs3",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:31:38Z",
          "updatedAt": "2024-03-25T21:31:38Z",
          "comments": [
            {
              "originalPosition": 672,
              "body": "```suggestion\r\n### Further Attacks on the Implicit Grant\r\n```",
              "createdAt": "2024-03-25T21:31:38Z",
              "updatedAt": "2024-03-25T21:31:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wTy8",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:31:55Z",
          "updatedAt": "2024-03-25T21:31:56Z",
          "comments": [
            {
              "originalPosition": 719,
              "body": "```suggestion\r\n### Disadvantages of the Implicit Grant\r\n```",
              "createdAt": "2024-03-25T21:31:55Z",
              "updatedAt": "2024-03-25T21:31:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wX09",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:45:24Z",
          "updatedAt": "2024-03-25T21:45:25Z",
          "comments": [
            {
              "originalPosition": 788,
              "body": "```suggestion\r\nOnce registered, the Service Worker runs an Authorization Code flow and obtains the tokens. Since the Service Worker keeps track of tokens in its own isolated execution environment, they are out of reach for any application code, including potentially malicious code. Consequentially, the Service Worker meets the first requirement of preventing token exfiltration. This essentially neutralizes the first two attack payloads discussed in {{payloads}}.\r\n```",
              "createdAt": "2024-03-25T21:45:24Z",
              "updatedAt": "2024-03-25T21:45:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wX6P",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:45:42Z",
          "updatedAt": "2024-03-25T21:45:42Z",
          "comments": [
            {
              "originalPosition": 791,
              "body": "```suggestion\r\nTo meet the second security requirement, the Service Worker must be able to guarantee that an attacker controlling the legitimate application cannot execute a new Authorization Code grant, an attack discussed in {{payload-new-flow}}. Due to the nature of Service Workers, the registered Service Worker will be able to block all outgoing requests that initialize such a new flow, even when they occur in a frame or a new window.\r\n```",
              "createdAt": "2024-03-25T21:45:42Z",
              "updatedAt": "2024-03-25T21:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wX-O",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:45:54Z",
          "updatedAt": "2024-03-25T21:45:55Z",
          "comments": [
            {
              "originalPosition": 796,
              "body": "```suggestion\r\nOne of the consequences of unregistering a Service Worker is that it will not be present when a new browsing context is opened. So when the attacker first unregisters the Service Worker, and then starts a new flow in a frame, there will be no Service Worker associated with the browsing context of the frame. Consequentially, the attacker will be able to run an Authorization Code grant, extract the code from the frame's URL, and exchange it for tokens.\r\n```",
              "createdAt": "2024-03-25T21:45:54Z",
              "updatedAt": "2024-03-25T21:45:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wYGi",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:46:18Z",
          "updatedAt": "2024-03-25T21:46:18Z",
          "comments": [
            {
              "originalPosition": 803,
              "body": "```suggestion\r\nFinally, note that the use of a Service Worker by itself does not increase the attack surface of the application. In practice, Service Workers are often used to retrofit a legacy application with support for including OAuth access tokens on outgoing requests. The Service Worker in these scenarios does not change the security properties of the application, but merely simplifies development and maintenance of the application.\r\n```",
              "createdAt": "2024-03-25T21:46:18Z",
              "updatedAt": "2024-03-25T21:46:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wYTf",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:46:59Z",
          "updatedAt": "2024-03-25T21:46:59Z",
          "comments": [
            {
              "originalPosition": 848,
              "body": "```suggestion\r\nOne common use of Web Workers is to isolate the refresh token. In such a scenario, the application runs an Authorization Code flow to obtain the authorization code. This code is forwarded to a Web Worker, which exchanges it for tokens. The Web Worker keeps the refresh token in memory and sends the access token to the main application. The main application uses the access token as desired. When the application needs to run a refresh token flow, it asks the Web Worker to do so, after which the application obtains a fresh access token.\r\n```",
              "createdAt": "2024-03-25T21:46:59Z",
              "updatedAt": "2024-03-25T21:47:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM50wYZf",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:47:18Z",
          "updatedAt": "2024-03-25T21:47:19Z",
          "comments": [
            {
              "originalPosition": 851,
              "body": "```suggestion\r\nIn this scenario, the application's existing refresh token is effectively protected against exfiltration, but the access token is not. Additionally, nothing would prevent an attacker from obtaining their own tokens by running a new Authorization Code flow.\r\n```",
              "createdAt": "2024-03-25T21:47:18Z",
              "updatedAt": "2024-03-25T21:47:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM52zyjc",
          "commit": {
            "abbreviatedOid": "a8db1b8"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T05:01:00Z",
          "updatedAt": "2024-04-11T05:01:00Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "AFAIK, WebAssembly runs in a sandboxed environment (unlike JS). To carry out the attacks we list in this spec, WASM would rely on JS anyway. With this context, it felt unfair to call out WASM here (without much reason), so I opted to reword this and keep it more generic. ",
              "createdAt": "2024-04-11T05:01:00Z",
              "updatedAt": "2024-04-11T05:01:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCUe3lM52zzhZ",
          "commit": {
            "abbreviatedOid": "23bbfc2"
          },
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-11T05:06:28Z",
          "updatedAt": "2024-04-11T05:06:29Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "Yes.",
              "createdAt": "2024-04-11T05:06:28Z",
              "updatedAt": "2024-04-11T05:06:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOCUe3lM5qtWCN",
      "title": "Feedback",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/46",
      "state": "CLOSED",
      "author": "0xandybarlow",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Overall the spec reads very well, I didn't have trouble following.\r\n\r\nI did spot a missing word perhaps? And also I was curious if there was a better way to describe the intent behind \"Authenticated Encryption with Authenticated Data\" statements - cipher? suite? algorithm? I couldn't decide on a better way - feel free to reject!\r\n\r\nGreat work!",
      "createdAt": "2024-03-25T20:53:57Z",
      "updatedAt": "2024-05-01T17:03:39Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "741f8820be57a2a29c60d7713b5655031279a04a",
      "headRepository": "0xandybarlow/oauth-browser-based-apps",
      "headRefName": "andy-review",
      "headRefOid": "d0fab5e707a6db95df3c3bb39ee94cef5cbdff5c",
      "closedAt": "2024-05-01T17:03:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "philippederyck",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your feedback @0xandybarlow. I have incorporated the missing word in PR #45, which is pending anyway. The text about AEAD encryption does need to be improved, but this is already pending in issue #44.\r\n\r\n@aaronpk This PR can be closed, since both items are addressed/being tracked in an issue.",
          "createdAt": "2024-04-11T05:32:16Z",
          "updatedAt": "2024-04-11T05:32:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "PR_kwDOCUe3lM5sUXqE",
      "title": "Reworded the benefits of the Token Mediating Backend",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/47",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR offers an alternative to #40. Compared to PR #40 it makes two changes:\r\n\r\n1. I removed the newly added text to avoid creating confusion between the responsibilities of a BFF. While it is technically possible to deploy a BFF as part of an API gateway, I believe this suggestion may create confusion for someone trying to grasp the pattern. An API Gateway is closely linked to an API, while a BFF is (in theory) closely linked to a frontend.\r\n\r\n2. Reworded the benefits of the Token Mediating Backend to more accurately represent the advantages/disadvantages of the pattern, as correctly suggested by this PR\r\n\r\nIf this PR is merged, #40 can be closed.",
      "createdAt": "2024-04-11T05:26:47Z",
      "updatedAt": "2024-05-01T17:04:26Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "741f8820be57a2a29c60d7713b5655031279a04a",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/alternative-for-pr-40",
      "headRefOid": "dd09298cd5912df1a99266ed1e96f474d3b3da8c",
      "closedAt": "2024-05-01T17:04:26Z",
      "mergedAt": "2024-05-01T17:04:26Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "84e0a8519fed6485a4b728a40bad13adf8e79eb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM53Ko8X",
          "commit": {
            "abbreviatedOid": "dd09298"
          },
          "author": "emmanuelgautier",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-13T14:59:04Z",
          "updatedAt": "2024-04-13T14:59:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOCUe3lM5s3NBN",
      "title": "feat: narrowing ascii-art and adding svg support",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/50",
      "state": "MERGED",
      "author": "duncanwd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #49\r\n\r\n1. Narrows the existing ASCII diagrams to 72 characters for better plain-text layout.\r\n2. Extracts the narrowed ASCII art into separate files.\r\n3. Modifies the markdown to invoke aasvg for automated SVG generation and inclusion in the HTML version\r\n\r\n**Note:** The aasvg npm package must be installed for the Makefile to function correctly. See the instructions link at the bottom of the main README.md for the install procedure.\r\n\r\nPlease check for errors in the modified ASCII diagrams, figure labels, and figure titles.",
      "createdAt": "2024-04-17T01:43:57Z",
      "updatedAt": "2024-05-01T17:09:49Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "741f8820be57a2a29c60d7713b5655031279a04a",
      "headRepository": "duncanwd/oauth-browser-based-apps",
      "headRefName": "feature/artwork",
      "headRefOid": "ab3750d2d0592b55fdc506bee9b1e84af2d422a3",
      "closedAt": "2024-05-01T17:09:48Z",
      "mergedAt": "2024-05-01T17:09:48Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "c97fa1fa473205e22a219b509533ddf688404a3a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOCUe3lM6Fct3X",
      "title": "Handled review comments",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/57",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR includes the following changes\r\n\r\n- Handled review comments from Rifaat Shekh-Yusef (mail 13/11/2024), details included below\r\n- Resolved #56\r\n\r\n\r\n\r\n\r\n### Detailed changes from review Rifaat\r\n\r\nI have the following comments/questions:\r\n> \r\n> Section 6.1.1\r\n> \u201cThis response to the browser will also trigger the reloading of the JavaScript application (H).\u201d\r\n> I am assuming that there is a reason for this reload, but that is not clear to me. Can you elaborate on why a reload is needed?\r\n\r\nClarified.\r\n\r\n\r\n> Section 6.1.2.1\r\n> \u2022 There are few places where the word \u201cinitialize\u201d is used, but I guess you meant to say \u201cinitiate\u201d?\r\n> \u2022 \u201cInitialization URI\u201d should that be \u201cauthorization URI\u201d?\r\n\r\nFixed.\r\n \r\n\r\n> Section 6.1.2.2\r\n> \u2022 \u201cThese steps are not shown in the diagram, but would occur between step J and K. \u201d\r\n> Should the BFF mint a new access token as soon as the existing access token has expired to allow for faster response to the request in step J?\r\n\r\nReworded.\r\n\r\n\r\n> \u2022 \u201cTherefore, it is recommended to configure the lifetime of the cookie-based session managed by the BFF to be equal to the maximum lifetime of the refresh token. Additionally, when the BFF learns that a refresh token for an active session is no longer valid, it is recommended to invalidate the session.\u201d\r\n> \u201crecommended\u201d -> \u201cRECOMMENDED\u201d?\r\n> Since this is a \u201crecommended\u201d, should there be some text to explain to the implementers when this recommendation might be ignored?\r\n\r\nChanged \"recommended\" to \"makes sense\" since this is not really a RECOMMENDATION, but mainly an observation for the implementer. All security hinges on the validity of the access/refresh token, and the session of the BFF is just to keep track of them. Keeping it around after a token expires is mainly ineffecient and pointless, but not really problematic.\r\n\r\n\r\n \r\n> Section 6.1.3.2\r\n> \u201c\r\n> \u2022 The BFF SHOULD enable the SameSite=Strict flag for its cookies\r\n> \u2022 The BFF SHOULD set its cookie path to /\r\n> \u2022 The BFF SHOULD NOT set the Domain attribute for cookies\r\n> \u2022 The BFF SHOULD start the name of its cookies with the __Host- prefix ([CookiePrefixes])\r\n> \u201d\r\n> The above statements use \u201cSHOULD\u201d, which implies that in some cases these can be ignored. Section 6.1.3.3.1 then elaborates on the \u201csameSite\u201d flag. Should there be some text to elaborate on the others?\r\n\r\nI added a sentence to clarify this a bit. In my opinion, these can definitely all be MUSTs, but that may conflict with certain corner cases or implementation strategies. We can continue this discussion if the current fix is not sufficient.\r\n\r\n\r\n> Section 6.2.2.1\r\n> \u201cThe endpoint that initializes the Authorization Code flow (step C) is \u2026\u201d\r\n> \u201cinitializes\u201d -> \u201cinitiates\u201d?\r\n\r\nFixed.\r\n\r\n \r\n> Section 6.2.2.2\r\n> \u201cTherefore, it is recommended to configure the lifetime of the cookie-based session to be equal to the maximum lifetime of the refresh token if such information is known upfront. Additionally, when the token-mediating backend learns that a refresh token for an active session is no longer valid, it is recommended to invalidate the session.\u201d\r\n> \u201crecommended\u201d -> \u201cRECOMMENDED\u201d?\r\n> Since this is a \u201crecommended\u201d, should there be some text to explain to the implementers when this recommendation might be ignored?\r\n\r\nFixed like before.\r\n\r\n\r\n> Section 6.3.2.2\r\n> \u2022 \u201cusing PKCE, and confirming that the authorization server supports PKCE\u201d\r\n> How would the browser-based app \u201cconfirm\u201d that the authorization server supports PKCE?\r\n\r\nThe developer would do that, but I've reworded this to avoid any confusion.\r\n\r\n \r\n> Section 6.3.2.3\r\n> \u2022 \u201cAt this point, when the application attempts to use the refresh token after 8 hours, the request will fail and the application will have to re-initialize an Authorization Code flow that relies on the user's authentication or previously established session\u201d\r\n> \u201cre-initialize\u201d -> \u201cre-initiate\u201d?\r\n\r\nFixed.\r\n\r\n\r\n> Section 6.3.3.1\r\n> \r\n> \u201cFor this reason, and those stated in Section 5.3.1 of [RFC6819], it is NOT RECOMMENDED for authorization servers to require client authentication of browser-based applications using a shared secret, as this serves no value beyond client identification which is already provided by the client_id parameter.\u201d\r\n> Since this is considered a bad practice, should we be more forceful here and try to change \u201cNOT RECOMMENDED\u201d to \u201cMUST NOT\u201d?\r\n\r\nDone.\r\n\r\n\r\n> Section 6.3.4.2.3\r\n> \u201ceven when it is associated with a flow that was initialized by the attacker.\u201d\r\n> \u201cinitialized\u201d -> \u201cinitiated\u201d?\r\n\r\nFixed.\r\n\r\n",
      "createdAt": "2024-12-17T07:01:05Z",
      "updatedAt": "2024-12-17T23:05:09Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "aa098db52956d26880867204289f75da43b83189",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/review-rifaat",
      "headRefOid": "131c5681c08cdae936e24d5f4e3a24d9e5926c45",
      "closedAt": "2024-12-17T23:05:09Z",
      "mergedAt": "2024-12-17T23:05:09Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "3d345349c09f0bfc684fe88c4b79afc6fc220c39"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCUe3lM6VoBYE",
          "commit": {
            "abbreviatedOid": "131c568"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-17T22:33:22Z",
          "updatedAt": "2024-12-17T22:33:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOCUe3lM6FkWUP",
      "title": "remove long paragraph about OIDC",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/60",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #59",
      "createdAt": "2024-12-17T23:11:59Z",
      "updatedAt": "2024-12-18T20:49:40Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "3d345349c09f0bfc684fe88c4b79afc6fc220c39",
      "headRepository": "oauth-wg/oauth-browser-based-apps",
      "headRefName": "issue-59",
      "headRefOid": "0188462754da04b95aa1b16573103cadd3379b2f",
      "closedAt": "2024-12-18T20:49:36Z",
      "mergedAt": "2024-12-18T20:49:36Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "88d31746c31b8d3c9172fdae9cf4cec8dc4a3e0a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOCUe3lM6Frlei",
      "title": "Clarified the security properties of HttpOnly cookies",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/61",
      "state": "MERGED",
      "author": "philippederyck",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Improved the intro of BFF and token-mediating backend to highlight the security benefits of HttpOnly cookies. This resolves #53",
      "createdAt": "2024-12-18T17:49:22Z",
      "updatedAt": "2024-12-18T20:49:07Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "85bb5ce0c6c3178505733ece2157aff5135766c5",
      "headRepository": "philippederyck/OAUTHWG-oauth-browser-based-apps",
      "headRefName": "pdr/53-httponly-cookies",
      "headRefOid": "f327e55e56e42db10db77fb36b46caa737acf5e5",
      "closedAt": "2024-12-18T20:49:07Z",
      "mergedAt": "2024-12-18T20:49:07Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "1f50e8837dc4af5c27a6a74c1f521b4efa5f4c8b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 65,
      "id": "PR_kwDOCUe3lM6JArac",
      "title": "Gen-ART review: simple editorial fixes and suggestion",
      "url": "https://github.com/oauth-wg/oauth-browser-based-apps/pull/65",
      "state": "OPEN",
      "author": "thomas-fossati",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-26T14:45:06Z",
      "updatedAt": "2025-01-26T17:02:24Z",
      "baseRepository": "oauth-wg/oauth-browser-based-apps",
      "baseRefName": "main",
      "baseRefOid": "64eaa586f5a109ab8e6b731b88d757270758beab",
      "headRepository": "thomas-fossati/oauth-browser-based-apps",
      "headRefName": "main",
      "headRefOid": "2e24901a6197892856444822cfad14501a101310",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}