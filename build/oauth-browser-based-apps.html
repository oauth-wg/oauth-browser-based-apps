<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>OAuth 2.0 for Browser-Based Apps</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Notational Conventions">
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 Overview">
<link href="#rfc.section.5" rel="Chapter" title="5 First-Party Applications">
<link href="#rfc.section.6" rel="Chapter" title="6 Application Architecture Patterns">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Browser-Based Apps that Can Share Data with the Resource Server">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 JavaScript Applications with a Backend">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 JavaScript Applications without a Backend">
<link href="#rfc.section.7" rel="Chapter" title="7 Authorization Code Flow">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Initiating the Authorization Request from a Browser-Based Application">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Handling the Authorization Code Redirect">
<link href="#rfc.section.8" rel="Chapter" title="8 Refresh Tokens">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Registration of Browser-Based Apps">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Client Authentication">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Client Impersonation">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Cross-Site Request Forgery Protections">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Authorization Server Mix-Up Mitigation">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Cross-Domain Requests">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 Content-Security Policy">
<link href="#rfc.section.9.8" rel="Chapter" title="9.8 OAuth Implicit Grant Authorization Flow">
<link href="#rfc.section.9.8.1" rel="Chapter" title="9.8.1 Threat: Interception of the Redirect URI">
<link href="#rfc.section.9.8.2" rel="Chapter" title="9.8.2 Threat: Access Token Leak in Browser History">
<link href="#rfc.section.9.8.3" rel="Chapter" title="9.8.3 Threat: Manipulation of Scripts">
<link href="#rfc.section.9.8.4" rel="Chapter" title="9.8.4 Threat: Access Token Leak to Third Party Scripts">
<link href="#rfc.section.9.8.5" rel="Chapter" title="9.8.5 Countermeasures">
<link href="#rfc.section.9.8.6" rel="Chapter" title="9.8.6 Disadvantages of the Implicit Flow">
<link href="#rfc.section.9.8.7" rel="Chapter" title="9.8.7 Historic Note">
<link href="#rfc.section.9.9" rel="Chapter" title="9.9 Additional Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Server Support Checklist">
<link href="#rfc.appendix.B" rel="Chapter" title="B Document History">
<link href="#rfc.appendix.C" rel="Chapter" title="C Acknowledgements">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.30.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Parecki, A. and D. Waite" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-oauth-browser-based-apps-04" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-09-22" />
  <meta name="dct.abstract" content="This specification details the security considerations and best practices that must be taken into account when developing browser-based applications that use OAuth 2.0." />
  <meta name="description" content="This specification details the security considerations and best practices that must be taken into account when developing browser-based applications that use OAuth 2.0." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Open Authentication Protocol</td>
<td class="right">A. Parecki</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Okta</td>
</tr>
<tr>
<td class="left">Intended status: Best Current Practice</td>
<td class="right">D. Waite</td>
</tr>
<tr>
<td class="left">Expires: March 25, 2020</td>
<td class="right">Ping Identity</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 22, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">OAuth 2.0 for Browser-Based Apps<br />
  <span class="filename">draft-ietf-oauth-browser-based-apps-04</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This specification details the security considerations and best practices that must be taken into account when developing browser-based applications that use OAuth 2.0.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 25, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Notational Conventions</a>
</li>
<li>3.   <a href="#rfc.section.3">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">Overview</a>
</li>
<li>5.   <a href="#rfc.section.5">First-Party Applications</a>
</li>
<li>6.   <a href="#rfc.section.6">Application Architecture Patterns</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Browser-Based Apps that Can Share Data with the Resource Server</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">JavaScript Applications with a Backend</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">JavaScript Applications without a Backend</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Authorization Code Flow</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Initiating the Authorization Request from a Browser-Based Application</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Handling the Authorization Code Redirect</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Refresh Tokens</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Registration of Browser-Based Apps</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Client Authentication</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Client Impersonation</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Cross-Site Request Forgery Protections</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Authorization Server Mix-Up Mitigation</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">Cross-Domain Requests</a>
</li>
<li>9.7.   <a href="#rfc.section.9.7">Content-Security Policy</a>
</li>
<li>9.8.   <a href="#rfc.section.9.8">OAuth Implicit Grant Authorization Flow</a>
</li>
<ul><li>9.8.1.   <a href="#rfc.section.9.8.1">Threat: Interception of the Redirect URI</a>
</li>
<li>9.8.2.   <a href="#rfc.section.9.8.2">Threat: Access Token Leak in Browser History</a>
</li>
<li>9.8.3.   <a href="#rfc.section.9.8.3">Threat: Manipulation of Scripts</a>
</li>
<li>9.8.4.   <a href="#rfc.section.9.8.4">Threat: Access Token Leak to Third Party Scripts</a>
</li>
<li>9.8.5.   <a href="#rfc.section.9.8.5">Countermeasures</a>
</li>
<li>9.8.6.   <a href="#rfc.section.9.8.6">Disadvantages of the Implicit Flow</a>
</li>
<li>9.8.7.   <a href="#rfc.section.9.8.7">Historic Note</a>
</li>
</ul><li>9.9.   <a href="#rfc.section.9.9">Additional Security Considerations</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">IANA Considerations</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Server Support Checklist</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Document History</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This specification describes the current best practices for implementing OAuth 2.0 authorization flows in applications running entirely in a browser.</p>
<p id="rfc.section.1.p.2">For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP (best current practice) was published that guides integration of these technologies.  This document is formally known as <a href="#RFC8252" class="xref">[RFC8252]</a> or BCP 212, but nicknamed "AppAuth" after the OpenID Foundation-sponsored set of libraries that assist developers in adopting these practices.</p>
<p><a href="#RFC8252" class="xref">[RFC8252]</a> makes specific recommendations for how to securely implement OAuth in native applications, including incorporating additional OAuth extensions where needed.</p>
<p id="rfc.section.1.p.4">OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing OAuth for native apps as well as browser-based apps, and includes additional considerations when running in a browser. This is primarily focused on OAuth, except where OpenID Connect provides additional considerations.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.3.p.1">In addition to the terms defined in referenced specifications, this document uses the following terms:</p>
<p></p>

<dl>
<dt>"OAuth":</dt>
<dd style="margin-left: 8">In this document, "OAuth" refers to OAuth 2.0, <a href="#RFC6749" class="xref">[RFC6749]</a>.</dd>
<dt>"Browser-based application":</dt>
<dd style="margin-left: 8">An application that is dynamically downloaded and executed in a web browser, usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</dd>
</dl>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.4.p.1">At the time that OAuth 2.0 RFC 6749 was created, browser-based JavaScript applications needed a solution that strictly complied with the same-origin policy. Common deployments of OAuth 2.0 involved an application running on a different domain than the authorization server, so it was historically not possible to use the authorization code flow which would require a cross-origin POST request. This was the principal motivation for the definition of the implicit flow, which returns the access token in the front channel via the fragment part of the URL, bypassing the need for a cross-origin POST request.</p>
<p id="rfc.section.4.p.2">However, there are several drawbacks to the implicit flow, generally involving vulnerabilities associated with the exposure of the access token in the URL. See <a href="#implicit_flow" class="xref">Section 9.8</a> for an analysis of these attacks and the drawbacks of using the implicit flow in browsers. Additional attacks and security considerations can be found in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>.</p>
<p id="rfc.section.4.p.3">In recent years, widespread adoption of Cross-Origin Resource Sharing (CORS), which enables exceptions to the same-origin policy, allows browser-based apps to use the OAuth 2.0 authorization code flow and make a POST request to exchange the authorization code for an access token at the token endpoint. In this flow, the access token is never exposed in the less secure front-channel. Furthermore, adding PKCE to the flow assures that even if an authorization code is intercepted, it is unusable by an attacker.</p>
<p id="rfc.section.4.p.4">For this reason, and from other lessons learned, the current best practice for browser-based applications is to use the OAuth 2.0 authorization code flow with PKCE.</p>
<p id="rfc.section.4.p.5">Browser-based applications MUST:</p>
<p></p>

<ul>
<li>Use the OAuth 2.0 authorization code flow with the PKCE extension</li>
<li>Protect themselves against CSRF attacks by using the OAuth 2.0 state parameter to carry one-time use CSRF tokens, or by ensuring the authorization server supports PKCE</li>
<li>Register one or more redirect URIs, and not vary the redirect URI per authorization request</li>
</ul>
<p id="rfc.section.4.p.7">OAuth 2.0 authorization servers MUST:</p>
<p></p>

<ul>
<li>Require exact matching of registered redirect URIs</li>
<li>Support the PKCE extension</li>
</ul>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#first-party-applications" id="first-party-applications">First-Party Applications</a>
</h1>
<p id="rfc.section.5.p.1">While OAuth was initially created to allow third-party applications to access an API on behalf of a user, it has proven to be useful in a first-party scenario as well. First-party apps are applications where the same organization provides both the API and the application.</p>
<p id="rfc.section.5.p.2">For example, a web email client provided by the operator of the email account, or a mobile banking application created by bank itself. (Note that there is no requirement that the application actually be developed by the same company; a mobile banking application developed by a contractor that is branded as the bank's application is still considered a first-party application.) The first-party app consideration is about the user's relationship to the application and the service.</p>
<p id="rfc.section.5.p.3">To conform to this best practice, first-party applications using OAuth or OpenID Connect MUST use the OAuth Authorization Code flow as described later in this document.</p>
<p id="rfc.section.5.p.4">The Resource Owner Password Grant MUST NOT be used, as described in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> section 3.4.</p>
<p id="rfc.section.5.p.5">By using the Authorization Code flow and redirecting the user to the authorization server, this provides the authorization server the opportunity to prompt the user for multi-factor authentication options, take advantage of single-sign-on sessions, or use third-party identity providers. In contrast, the Password grant does not provide any built-in mechanism for these, and would instead be extended with custom code.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#application-architecture-patterns" id="application-architecture-patterns">Application Architecture Patterns</a>
</h1>
<p id="rfc.section.6.p.1">There are three primary architectural patterns available when building browser-based applications.</p>
<p></p>

<ul>
<li>a JavaScript application with no backend, accessing resource servers directly</li>
<li>a JavaScript application with a backend</li>
<li>a JavaScript application that has methods of sharing data with resource servers, such as using common-domain cookies</li>
</ul>
<p id="rfc.section.6.p.3">These three architectures have different use cases and considerations.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#browser-based-apps-that-can-share-data-with-the-resource-server" id="browser-based-apps-that-can-share-data-with-the-resource-server">Browser-Based Apps that Can Share Data with the Resource Server</a>
</h1>
<p id="rfc.section.6.1.p.1">For simple system architectures, such as when the JavaScript application is served from a domain that can share cookies with the domain of the API (resource server), OAuth adds additional attack vectors that could be avoided with a different solution.</p>
<p id="rfc.section.6.1.p.2">In particular, using any redirect-based mechanism of obtaining an access token enables the redirect-based attacks described in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>, but if the application, AS and API share a domain, then it is unnecessary to use a redirect mechanism to communicate between them.</p>
<p id="rfc.section.6.1.p.3">An additional concern with handling access tokens in a browser is that there is no secure storage mechanism where JavaScript code can keep the access token to be later used in an API request. Using an OAuth flow results in the JavaScript code getting an access token, needing to store it somewhere, and then retrieve it to make an API request.  Instead, a more secure design is to use an HTTP-only cookie between the JavaScript application and API so that the JavaScript code can't access the cookie value itself.</p>
<p id="rfc.section.6.1.p.4">OAuth was originally created for third-party or federated access to APIs, so it may not be the best solution in a common-domain deployment. That said, using OAuth even in a common-domain architecture does mean you can more easily rearchitect things later, such as if you were to later add a new domain to the system.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#javascript-applications-with-a-backend" id="javascript-applications-with-a-backend">JavaScript Applications with a Backend</a>
</h1>
<pre>
+-------------+
|             |
|Authorization|
|   Server    |
|             |
+-------------+

   ^     +
   |(A)  |(B)
   |     |
   +     v

+-------------+             +--------------+
|             | +---------&gt; |              |
| Application |   (C)       |   Resource   |
|   Server    |             |    Server    |
|             | &lt;---------+ |              |
+-------------+   (D)       +--------------+

    ^    +
    |    |
    |    | browser
    |    | cookie
    |    |
    +    v

+-------------+
|             |
|   Browser   |
|             |
+-------------+
</pre>
<p id="rfc.section.6.2.p.1">In this architecture, the JavaScript code is loaded from a dynamic Application Server that also has the ability to execute code itself. This enables the ability to keep all of the steps involved in obtaining an access token outside of the JavaScript application.</p>
<p id="rfc.section.6.2.p.2">(Common examples of this architecture are an Angular front-end with a .NET backend, or a React front-end with a Spring Boot backend.)</p>
<p id="rfc.section.6.2.p.3">The Application Server SHOULD be considered a confidential client, and issued its own client secret. The Application Server SHOULD use the OAuth 2.0 authorization code grant to initiate a request for an access token. Upon handling the redirect from the Authorization Server, the Application Server will request an access token using the authorization code returned (A), which will be returned to the Application Server (B). The Application Server utilizes its own session with the browser to store the access token.</p>
<p id="rfc.section.6.2.p.4">When the JavaScript application in the browser wants to make a request to the Resource Server, it MUST instead make the request to the Application Server, and the Application Server will make the request with the access token to the Resource Server (C), and forward the response (D) back to the browser.</p>
<p id="rfc.section.6.2.p.5">Security of the connection between code running in the browser and this Application Server is assumed to utilize browser-level protection mechanisms. Details are out of scope of this document, but many recommendations can be found at the OWASP Foundation (https://www.owasp.org/), such as setting an HTTP-only and Secure cookie to authenticate the session between the browser and Application Server.</p>
<p id="rfc.section.6.2.p.6">In this scenario, the session between the browser and Application Server MAY be either a session cookie provided by the Application Server, OR the access token itself. Note that if the access token is used as the session identifier, this exposes the access token to the end user even if it is not available to the JavaScript application, so some authorization servers may wish to limit the capabilities of these clients to mitigate risk.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#javascript-applications-without-a-backend" id="javascript-applications-without-a-backend">JavaScript Applications without a Backend</a>
</h1>
<pre>
                      +---------------+           +--------------+
                      |               |           |              |
                      | Authorization |           |   Resource   |
                      |    Server     |           |    Server    |
                      |               |           |              |
                      +---------------+           +--------------+

                             ^     +                 ^     +
                             |     |                 |     |
                             |(B)  |(C)              |(D)  |(E)
                             |     |                 |     |
                             |     |                 |     |
                             +     v                 +     v

+-----------------+         +-------------------------------+
|                 |   (A)   |                               |
| Static Web Host | +-----&gt; |           Browser             |
|                 |         |                               |
+-----------------+         +-------------------------------+
</pre>
<p id="rfc.section.6.3.p.1">In this architecture, the JavaScript code is first loaded from a static web host into the browser (A). The application then runs in the browser, and is considered a public client since it has no ability to be issued a client secret.</p>
<p id="rfc.section.6.3.p.2">The code in the browser then initiates the authorization code flow with the PKCE extension (described in <a href="#authorization_code_flow" class="xref">Section 7</a>) (B) above, and obtains an access token via a POST request (C). The JavaScript app is then responsible for storing the access token securely using appropriate browser APIs.</p>
<p id="rfc.section.6.3.p.3">When the JavaScript application in the browser wants to make a request to the Resource Server, it can include the access token in the request (D) and make the request directly.</p>
<p id="rfc.section.6.3.p.4">In this scenario, the Authorization Server and Resource Server MUST support the necessary CORS headers to enable the JavaScript code to make this POST request from the domain on which the script is executing. (See <a href="#cors" class="xref">Section 9.6</a> for additional details.)</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#authorization_code_flow" id="authorization_code_flow">Authorization Code Flow</a>
</h1>
<p id="rfc.section.7.p.1">Public browser-based apps that use the authorization code grant type described in Section 4.1 of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> MUST also follow these additional requirements described in this section.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#auth_code_request" id="auth_code_request">Initiating the Authorization Request from a Browser-Based Application</a>
</h1>
<p id="rfc.section.7.1.p.1">Public browser-based apps MUST implement the Proof Key for Code Exchange (PKCE <a href="#RFC7636" class="xref">[RFC7636]</a>) extension to OAuth, and authorization servers MUST support PKCE for such clients.</p>
<p id="rfc.section.7.1.p.2">The PKCE extension prevents an attack where the authorization code is intercepted and exchanged for an access token by a malicious client, by providing the authorization server with a way to verify the same client instance that exchanges the authorization code is the same one that initiated the flow.</p>
<p id="rfc.section.7.1.p.3">Browser-based apps MUST use a unique value for the the OAuth 2.0 "state" parameter on each request, and MUST verify the returned state in the authorization response matches the original state the app created.</p>
<p id="rfc.section.7.1.p.4">Browser-based apps MUST follow the recommendations in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> section 3.1 to protect themselves during redirect flows.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#auth_code_redirect" id="auth_code_redirect">Handling the Authorization Code Redirect</a>
</h1>
<p id="rfc.section.7.2.p.1">Authorization servers MUST require an exact match of a registered redirect URI.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#refresh_tokens" id="refresh_tokens">Refresh Tokens</a>
</h1>
<p id="rfc.section.8.p.1">Refresh tokens provide a way for applications to obtain a new access token when the initial access token expires. With public clients, the risk of a leaked refresh token is greater than leaked access tokens, since an attacker may be able to continue using the stolen refresh token to obtain new access tokens potentially without being detectable by the authorization server.</p>
<p id="rfc.section.8.p.2">Browser-based applications provide an attacker with several opportunities by which a refresh token can be leaked, just as with access tokens. As such, these applications are considered a higher risk for handling refresh tokens.</p>
<p><a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> describes some additional requirements around refresh tokens on top of the recommendations of <a href="#RFC6749" class="xref">[RFC6749]</a>. Applications and authorization servers conforming to this BCP MUST also follow the recommendations in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> around refresh tokens.</p>
<p id="rfc.section.8.p.4">In particular, authorization servers:</p>
<p></p>

<ul>
<li>MUST rotate refresh tokens on each use, in order to be able to detect a stolen refresh token if one is replayed (described in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> section 4.12)</li>
<li>MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time</li>
<li>upon issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token if the refresh token has a preestablished expiration time</li>
</ul>
<p id="rfc.section.8.p.6">For example:</p>
<p></p>

<ul>
<li>A user authorizes an application, issuing an access token that lasts 1 hour, and a refresh token that lasts 24 hours</li>
<li>After 1 hour, the initial access token expires, so the application uses the refresh token to get a new access token</li>
<li>The authorization server returns a new access token that lasts 1 hour, and a new refresh token that lasts 23 hours</li>
<li>This continues until 24 hours pass from the initial authorization</li>
<li>At this point, when the application attempts to use the refresh token after 24 hours, the request will fail and the application will have to involve the user in a new authorization request</li>
</ul>
<p id="rfc.section.8.p.8">By limiting the overall refresh token lifetime to the lifetime of the initial refresh token, this ensures a stolen refresh token cannot be used indefinitely.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#client_registration" id="client_registration">Registration of Browser-Based Apps</a>
</h1>
<p id="rfc.section.9.1.p.1">Browser-based applications are considered public clients as defined by section 2.1 of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a>, and MUST be registered with the authorization server as such. Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly.</p>
<p id="rfc.section.9.1.p.2">Authorization servers MUST require that browser-based applications register one or more redirect URIs.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#client_authentication" id="client_authentication">Client Authentication</a>
</h1>
<p id="rfc.section.9.2.p.1">Since a browser-based application's source code is delivered to the end-user's browser, it cannot contain provisioned secrets. As such, a browser-based app with native OAuth support is considered a public client as defined by Section 2.1 of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a>.</p>
<p id="rfc.section.9.2.p.2">Secrets that are statically included as part of an app distributed to multiple users should not be treated as confidential secrets, as one user may inspect their copy and learn the shared secret.  For this reason, and those stated in Section 5.3.1 of <a href="#RFC6819" class="xref">[RFC6819]</a>, it is NOT RECOMMENDED for authorization servers to require client authentication of browser-based applications using a shared secret, as this serves little value beyond client identification which is already provided by the client_id request parameter.</p>
<p id="rfc.section.9.2.p.3">Authorization servers that still require a statically included shared secret for SPA clients MUST treat the client as a public client, and not accept the secret as proof of the client's identity. Without additional measures, such clients are subject to client impersonation (see <a href="#client_impersonation" class="xref">Section 9.3</a> below).</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#client_impersonation" id="client_impersonation">Client Impersonation</a>
</h1>
<p id="rfc.section.9.3.p.1">As stated in Section 10.2 of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a>, the authorization server SHOULD NOT process authorization requests automatically without user consent or interaction, except when the identity of the client can be assured. Even when the user has previously approved an authorization request for a given client_id, the request SHOULD be processed as if no previous request had been approved, unless the identity of the client can be proven.</p>
<p id="rfc.section.9.3.p.2">If authorization servers restrict redirect URIs to a fixed set of absolute HTTPS URIs without wildcard domains, paths, or query string components, this exact match of registered absolute HTTPS URIs MAY be accepted by authorization servers as proof of identity of the client for the purpose of deciding whether to automatically process an authorization request when a previous request for the client_id has already been approved.</p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#csrf_protection" id="csrf_protection">Cross-Site Request Forgery Protections</a>
</h1>
<p id="rfc.section.9.4.p.1">Section 5.3.5 of <a href="#RFC6819" class="xref">[RFC6819]</a> recommends using the "state" parameter to link client requests and responses to prevent CSRF (Cross-Site Request Forgery) attacks. To conform to this best practice, use of the "state" parameter is REQUIRED, as described in <a href="#auth_code_request" class="xref">Section 7.1</a>, unless the application has a method of ensuring the authorization server supports PKCE, since PKCE also prevents CSRF attacks.</p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#auth_server_mixup" id="auth_server_mixup">Authorization Server Mix-Up Mitigation</a>
</h1>
<p id="rfc.section.9.5.p.1">The security considerations around the authorization server mix-up that are referenced in Section 8.10 of <a href="#RFC8252" class="xref">[RFC8252]</a> also apply to browser-based apps.</p>
<p id="rfc.section.9.5.p.2">Clients MUST use a unique redirect URI for each authorization server used by the application. The client MUST store the redirect URI along with the session data (e.g. along with "state") and MUST verify that the URI on which the authorization response was received exactly matches.</p>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#cors" id="cors">Cross-Domain Requests</a>
</h1>
<p id="rfc.section.9.6.p.1">To complete the authorization code flow, the browser-based application will need to exchange the authorization code for an access token at the token endpoint.  If the authorization server provides additional endpoints to the application, such as metadata URLs, dynamic client registration, revocation, introspection, discovery or user info endpoints, these endpoints may also be accessed by the browser-based app.  Since these requests will be made from a browser, authorization servers MUST support the necessary CORS headers (defined in <a href="#Fetch" class="xref">[Fetch]</a>) to allow the browser to make the request.</p>
<p id="rfc.section.9.6.p.2">This specification does not include guidelines for deciding whether a CORS policy for the token endpoint should be a wildcard origin or more restrictive. Note, however, that the browser will attempt to GET or POST to the API endpoint before knowing any CORS policy; it simply hides the succeeding or failing result from JavaScript if the policy does not allow sharing.</p>
<h1 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> <a href="#csp" id="csp">Content-Security Policy</a>
</h1>
<p id="rfc.section.9.7.p.1">A browser-based application that wishes to use either long-lived refresh tokens or privileged scopes SHOULD restrict its JavaScript execution to a set of statically hosted scripts via a Content Security Policy (<a href="#CSP2" class="xref">[CSP2]</a>) or similar mechanism. A strong Content Security Policy can limit the potential attack vectors for malicious JavaScript to be executed on the page.</p>
<h1 id="rfc.section.9.8">
<a href="#rfc.section.9.8">9.8.</a> <a href="#implicit_flow" id="implicit_flow">OAuth Implicit Grant Authorization Flow</a>
</h1>
<p id="rfc.section.9.8.p.1">The OAuth 2.0 Implicit grant authorization flow (defined in Section 4.2 of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a>) works by receiving an access token in the HTTP redirect (front-channel) immediately without the code exchange step. In this case, the access token is returned in the fragment part of the redirect URI, providing an attacker with several opportunities to intercept and steal the access token. Several attacks on the implicit flow are described by <a href="#RFC6819" class="xref">[RFC6819]</a> and <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>, not all of which have sufficient mitigation strategies.</p>
<h1 id="rfc.section.9.8.1">
<a href="#rfc.section.9.8.1">9.8.1.</a> <a href="#threat-interception-of-the-redirect-uri" id="threat-interception-of-the-redirect-uri">Threat: Interception of the Redirect URI</a>
</h1>
<p id="rfc.section.9.8.1.p.1">If an attacker is able to cause the authorization response to be sent to a URI under his control, he will directly get access to the fragment carrying the access token.  A method of performing this attack is described in detail in <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>.</p>
<h1 id="rfc.section.9.8.2">
<a href="#rfc.section.9.8.2">9.8.2.</a> <a href="#threat-access-token-leak-in-browser-history" id="threat-access-token-leak-in-browser-history">Threat: Access Token Leak in Browser History</a>
</h1>
<p id="rfc.section.9.8.2.p.1">An attacker could obtain the access token from the browser's history.  The countermeasures recommended by <a href="#RFC6819" class="xref">[RFC6819]</a> are limited to using short expiration times for tokens, and indicating that browsers should not cache the response.  Neither of these fully prevent this attack, they only reduce the potential damage.</p>
<p id="rfc.section.9.8.2.p.2">Additionally, many browsers now also sync browser history to cloud services and to multiple devices, providing an even wider attack surface to extract access tokens out of the URL.</p>
<p id="rfc.section.9.8.2.p.3">This is discussed in more detail in Section 4.3.2 of <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>.</p>
<h1 id="rfc.section.9.8.3">
<a href="#rfc.section.9.8.3">9.8.3.</a> <a href="#threat-manipulation-of-scripts" id="threat-manipulation-of-scripts">Threat: Manipulation of Scripts</a>
</h1>
<p id="rfc.section.9.8.3.p.1">An attacker could modify the page or inject scripts into the browser via various means, including when the browser's HTTPS connection is being man-in-the-middled by for example a corporate network. While this type of attack is typically out of scope of basic security recommendations to prevent, in the case of browser-based apps it is much easier to perform this kind of attack, where an injected script can suddenly have access to everything on the page.</p>
<p id="rfc.section.9.8.3.p.2">The risk of a malicious script running on the page is far greater when the application uses a known standard way of obtaining access tokens, namely that the attacker can always look at the window.location to find an access token. This threat profile is very different compared to an attacker specifically targeting an individual application by knowing where or how an access token obtained via the authorization code flow may end up being stored.</p>
<h1 id="rfc.section.9.8.4">
<a href="#rfc.section.9.8.4">9.8.4.</a> <a href="#threat-access-token-leak-to-third-party-scripts" id="threat-access-token-leak-to-third-party-scripts">Threat: Access Token Leak to Third Party Scripts</a>
</h1>
<p id="rfc.section.9.8.4.p.1">It is relatively common to use third-party scripts in browser-based apps, such as analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.  In these situations, the author of the application may not be able to be fully aware of the entirety of the code running in the application. When an access token is returned in the fragment, it is visible to any third-party scripts on the page.</p>
<h1 id="rfc.section.9.8.5">
<a href="#rfc.section.9.8.5">9.8.5.</a> <a href="#countermeasures" id="countermeasures">Countermeasures</a>
</h1>
<p id="rfc.section.9.8.5.p.1">In addition to the countermeasures described by <a href="#RFC6819" class="xref">[RFC6819]</a> and <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a>, using the authorization code with PKCE avoids these attacks.</p>
<p id="rfc.section.9.8.5.p.2">When PKCE is used, if an authorization code is stolen in transport, the attacker is unable to do anything with the authorization code.</p>
<h1 id="rfc.section.9.8.6">
<a href="#rfc.section.9.8.6">9.8.6.</a> <a href="#disadvantages-of-the-implicit-flow" id="disadvantages-of-the-implicit-flow">Disadvantages of the Implicit Flow</a>
</h1>
<p id="rfc.section.9.8.6.p.1">There are several additional reasons the Implicit flow is disadvantageous compared to using the standard Authorization Code flow.</p>
<p></p>

<ul>
<li>OAuth 2.0 provides no mechanism for a client to verify that an access token was issued to it, which could lead to misuse and possible impersonation attacks if a malicious party hands off an access token it retrieved through some other means to the client.</li>
<li>Returning an access token in the front channel redirect gives the authorization server no assurance that the access token will actually end up at the application, since there are many ways this redirect may fail or be intercepted.</li>
<li>Supporting the implicit flow requires additional code, more upkeep and understanding of the related security considerations, while limiting the authorization server to just the authorization code flow reduces the attack surface of the implementation.</li>
<li>If the JavaScript application gets wrapped into a native app, then <a href="#RFC8252" class="xref">[RFC8252]</a> also requires the use of the authorization code flow with PKCE anyway.</li>
</ul>
<p id="rfc.section.9.8.6.p.3">In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally signed. Returning an id_token using the Implicit flow (response_type=id_token) requires the client validate the JWT signature, as malicious parties could otherwise craft and supply fraudulent id_tokens. Performing OpenID Connect using the authorization code flow provides the benefit of the client not needing to verify the JWT signature, as the ID token will have been fetched over an HTTPS connection directly from the authorization server. Additionally, in many cases an application will request both an ID token and an access token, so it is simplier and provides fewer attack vectors to obtain both via the authorization code flow.</p>
<h1 id="rfc.section.9.8.7">
<a href="#rfc.section.9.8.7">9.8.7.</a> <a href="#historic-note" id="historic-note">Historic Note</a>
</h1>
<p id="rfc.section.9.8.7.p.1">Historically, the Implicit flow provided an advantage to single-page apps since JavaScript could always arbitrarily read and manipulate the fragment portion of the URL without triggering a page reload. This was necessary in order to remove the access token from the URL after it was obtained by the app.</p>
<p id="rfc.section.9.8.7.p.2">Modern browsers now have the Session History API (described in "Session history and navigation" of <a href="#HTML" class="xref">[HTML]</a>), which provides a mechanism to modify the path and query string component of the URL without triggering a page reload. This means modern browser-based apps can use the unmodified OAuth 2.0 authorization code flow, since they have the ability to remove the authorization code from the query string without triggering a page reload thanks to the Session History API.</p>
<h1 id="rfc.section.9.9">
<a href="#rfc.section.9.9">9.9.</a> <a href="#additional-security-considerations" id="additional-security-considerations">Additional Security Considerations</a>
</h1>
<p id="rfc.section.9.9.p.1">The OWASP Foundation (https://www.owasp.org/) maintains a set of security recommendations and best practices for web applications, and it is RECOMMENDED to follow these best practices when creating an OAuth 2.0 Browser-Based application.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.10.p.1">This document does not require any IANA actions.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="CSP2">[CSP2]</b></td>
<td class="top">
<a title="Google, Inc">West, M.</a>, <a title="Google, Inc">Barth, A.</a> and <a title="Mozilla Corporation">D. Veditz</a>, "<a>Content Security Policy</a>", December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="Fetch">[Fetch]</b></td>
<td class="top">
<a>whatwg</a>, "<a>Fetch</a>", 2018.</td>
</tr>
<tr>
<td class="reference"><b id="oauth-security-topics">[oauth-security-topics]</b></td>
<td class="top">
<a title="yes.com">Lodderstedt, T.</a>, <a title="Yubico">Bradley, J.</a>, <a title="Facebook">Labunets, A.</a> and <a title="yes.com">D. Fett</a>, "<a>OAuth 2.0 Security Best Current Practice</a>", July 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6819">[RFC6819]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>McGloin, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc6819">OAuth 2.0 Threat Model and Security Considerations</a>", RFC 6819, DOI 10.17487/RFC6819, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7636">[RFC7636]</b></td>
<td class="top">
<a>Sakimura, N.</a>, <a>Bradley, J.</a> and <a>N. Agarwal</a>, "<a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange by OAuth Public Clients</a>", RFC 7636, DOI 10.17487/RFC7636, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8252">[RFC8252]</b></td>
<td class="top">
<a>Denniss, W.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8252">OAuth 2.0 for Native Apps</a>", BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="HTML">[HTML]</b></td>
<td class="top">
<a>whatwg</a>, "<a>HTML</a>", 2018.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#server-support-checklist" id="server-support-checklist">Server Support Checklist</a>
</h1>
<p id="rfc.section.A.p.1">OAuth authorization servers that support browser-based apps MUST:</p>
<p></p>

<ol>
<li>Require "https" scheme redirect URIs.</li>
<li>Require exact matching of registered redirect URIs.</li>
<li>Support PKCE <a href="#RFC7636" class="xref">[RFC7636]</a>. Required to protect authorization code grants sent to public clients. See <a href="#auth_code_request" class="xref">Section 7.1</a>
</li>
<li>Support cross-domain requests at the token endpoint in order to allow browsers to make the authorization code exchange request. See <a href="#cors" class="xref">Section 9.6</a>
</li>
<li>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue secrets to applications of this type.</li>
<li>Not support the Resource Owner Password grant for browser-based clients.</li>
<li>Follow the <a href="#oauth-security-topics" class="xref">[oauth-security-topics]</a> recommendations on refresh tokens, as well as the additional requirements described in <a href="#refresh_tokens" class="xref">Section 8</a>.</li>
</ol>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#document-history" id="document-history">Document History</a>
</h1>
<p id="rfc.section.B.p.1">[[ To be removed from the final specification ]]</p>
<p id="rfc.section.B.p.2">-04</p>
<p></p>

<ul>
<li>Disallow the use of the Password Grant</li>
<li>Add PKCE support to summary list for authorization server requirements</li>
<li>Rewrote refresh token section to allow refresh tokens if they are time-limited, rotated on each use, and requiring that the rotated refresh token lifetimes do not extend past the lifetime of the initial refresh token, and to bring it in line with the Security BCP</li>
<li>Updated recommendations on using state to reflect the Security BCP</li>
<li>Updated server support checklist to reflect latest changes</li>
<li>Updated the same-domain JS architecture section to emphasize the architecture rather than domain</li>
<li>Editorial clarifications in the section that talks about OpenID Connect ID tokens</li>
</ul>
<p id="rfc.section.B.p.4">-03</p>
<p></p>

<ul>
<li>Updated the historic note about the fragment URL clarifying that the Session History API means browsers can use the unmodified authorization code flow</li>
<li>Rephrased "Authorization Code Flow" intro paragraph to better lead into the next two sections</li>
<li>Softened "is likely a better decision to avoid using OAuth entirely" to "it may be&#8230;" for common-domain deployments</li>
<li>Updated abstract to not be limited to public clients, since the later sections talk about confidential clients</li>
<li>Removed references to avoiding OpenID Connect for same-domain architectures</li>
<li>Updated headers to better describe architectures (Apps Served from a Static Web Server -&gt; JavaScript Applications without a Backend)</li>
<li>Expanded "same-domain architecture" section to better explain the problems that OAuth has in this scenario</li>
<li>Referenced Security BCP in implicit flow attacks where possible</li>
<li>Minor typo corrections</li>
</ul>
<p id="rfc.section.B.p.6">-02</p>
<p></p>

<ul>
<li>Rewrote overview section incorporating feedback from Leo Tohill</li>
<li>Updated summary recommendation bullet points to split out application and server requirements</li>
<li>Removed the allowance on hostname-only redirect URI matching, now requiring exact redirect URI matching</li>
<li>Updated section 6.2 to drop reference of SPA with a backend component being a public client</li>
<li>Expanded the architecture section to explicitly mention three architectural patterns available to JS apps</li>
</ul>
<p id="rfc.section.B.p.8">-01</p>
<p></p>

<ul>
<li>Incorporated feedback from Torsten Lodderstedt</li>
<li>Updated abstract</li>
<li>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</li>
<li>Clarified use of the state parameter for CSRF protection</li>
<li>Added background information about the original reason the implicit flow was created due to lack of CORS support</li>
<li>Clarified the same-domain use case where the SPA and API share a cookie domain</li>
<li>Moved historic note about the fragment URL into the Overview</li>
</ul>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.C.p.1">The authors would like to acknowledge the work of William Denniss and John Bradley, whose recommendation for native apps informed many of the best practices for browser-based applications. The authors would also like to thank Hannes Tschofenig and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27 session at which this BCP was originally proposed, and the following individuals who contributed ideas, feedback, and wording that shaped and formed the final specification:</p>
<p id="rfc.section.C.p.2">Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett, George Fletcher, Hannes Tschofenig, Janak Amarasena, John Bradley, Joseph Heenan, Justin Richer, Karl McGuinness, Leo Tohill, Tomek Stojecki, Torsten Lodderstedt, and Vittorio Bertocci.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Aaron Parecki</span> 
	  <span class="n hidden">
		<span class="family-name">Parecki</span>
	  </span>
	</span>
	<span class="org vcardline">Okta</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:aaron@parecki.com">aaron@parecki.com</a></span>

<span class="vcardline">URI: <a href="https://aaronparecki.com">https://aaronparecki.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David Waite</span> 
	  <span class="n hidden">
		<span class="family-name">Waite</span>
	  </span>
	</span>
	<span class="org vcardline">Ping Identity</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:david@alkaline-solutions.com">david@alkaline-solutions.com</a></span>

  </address>
</div>

</body>
</html>
