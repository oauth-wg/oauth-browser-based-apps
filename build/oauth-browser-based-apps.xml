<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.11 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-01" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2019" month="March" day="27"/>

    <area>Security Area</area>
    <workgroup>Open Authentication Protocol</workgroup>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>OAuth 2.0 authorization requests from browser-based apps must be made using the 
authorization code grant with the PKCE extension, and should not be issued a
client secret when registered.</t>

<t>This specification details the security considerations that must be
taken into account when developing browser-based applications, as well as best
practices for how they can securely implement OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications running entirely in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices.</t>

<t>AppAuth steers developers away from performing user authorization via embedding user
agents such as browser controls into native apps, instead insisting that an external
agent (such as the system browser) be used. The RFC continues on to promote
capabilities and supplemental specifications beyond the base OAuth 2.0 and
OpenID Connect specifications to improve baseline security, such as <xref target="RFC7636"/>,
also known as PKCE.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps as well as browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText='&quot;OAuth&quot;:'>
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/>.</t>
  <t hangText='&quot;Browser-based application&quot;:'>
  An application that is dynamically downloaded and executed in a web browser, 
usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>For authorizing users within a browser-based application, the best current practice is to</t>

<t><list style="symbols">
  <t>Use the OAuth 2.0 authorization code flow with the PKCE extension</t>
  <t>Use the OAuth 2.0 state parameter to carry one-time use CSRF tokens</t>
  <t>Recommend exact matching of redirect URIs, and require the hostname of the redirect URI match the hostname of the URL the app was served from</t>
  <t>Do not return access tokens in the front channel</t>
</list></t>

<t>Since the publication of OAuth 2.0 RFC 6749, browsers have broadly adopted the concept of CORS, enabling the ability for JavaScript applications to make cross-domain requests. During the time RFC 6749 was originally being written, browsers did not have wide support, so it was not possible to require browsers to use the authorization code flow, so the implicit flow was developed instead.</t>

<t>There are several drawbacks to the implicit flow, including the fact that access tokens are
returned in the front-channel via the fragment part of the redirect URI, and as such
are vulnerable to a variety of attacks where the access token can be intercepted or
stolen. See <xref target="implicit_flow"/> for a deeper analysis of these attacks and the drawbacks
of using the implicit flow in browsers, many of which are described by <xref target="oauth-security-topics"/>.</t>

<t>Now, thanks to the wide adoption of CORS, browser-based apps can perform the OAuth 2.0
authorization code flow and make a POST request to the token endpoint to exchange an 
authorization code for an access token, just like other OAuth clients. This ensures 
that access tokens are not sent via the less secure front-channel, and are only 
returned over an HTTPS connection initiated from the application. Combined with PKCE, 
this enables the authorization server to ensure that authorization codes are useless 
even if intercepted in transport.</t>

<t>Historically, the Implicit flow provided an advantage to single-page apps since JavaScript could always arbitrarily read and manipulate the fragment portion of the URL without triggering a page reload. Now with the Session History API (described in "Session history and navigation" of <xref target="HTML"></xref>), browsers have a mechanism to modify the path component of the URL without triggering a page reload, so this overloaded use of the fragment portion is no longer needed.</t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth and OpenID Connect were initially created to allow third-party
applications to access an API on behalf of a user, they have both proven to be
useful in a first-party scenario as well. First-party apps are applications where
by the same organization that provides the API being accessed by the application.</t>

<t>For example, a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use an OAuth Authorization Code flow as described later in this
document or use the OAuth Password grant.</t>

<t>It is strongly RECOMMENDED that applications use the Authorization Code flow over
the Password grant for several reasons. By redirecting to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single-sign-on sessions,
or use third-party identity providers. In contrast, the Password grant does not
provide any built-in mechanism for these, and must be extended with custom code.</t>

</section>
<section anchor="architectural-considerations" title="Architectural Considerations">

<t>In some cases, it may make sense to avoid the use of a strictly browser-based OAuth
application entirely, and instead use an architecture that keeps OAuth access tokens
out of the browser.</t>

<section anchor="apps-served-from-a-common-domain-as-the-api" title="Apps Served from a Common Domain as the API">

<t>For simple system architectures, such as when the JavaScript application is served
from a domain that can share cookies with the API's (resource server's) domain, it 
is likely a better decision to avoid using OAuth entirely, and just use session 
authentication to communicate with the API.</t>

<t>OAuth and OpenID Connect provide very little benefit in this deployment scenario,
so it is recommended to reconsider whether you need OAuth or OpenID Connect at all
in this case. Session authentication has the benefit of having fewer moving parts
and fewer attack vectors. OAuth and OpenID Connect were created primarily for
third-party or federated access to APIs, so may not be the best solution in a
same-domain scenario.</t>

</section>
<section anchor="browser-based-app-with-a-backend-component" title="Browser-Based App with a Backend Component">

<t>To avoid the risks inherent in handling OAuth access tokens from a purely browser-based
application, implementations may wish to move the authorization code exchange and
handling of access and refresh tokens into a backend component.</t>

<t>Security of the connection between code running in the browser and this backend component is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found at the OWASP Foundation (https://www.owasp.org/).</t>

<t>In this scenario, the backend component may be a confidential client which has the 
ability to authenticate itself. Despite this, there are still some ways in which this application
is effectively a public client, as the end result is the application's code is still
running in the browser and visible to the user. Some authorization servers may have
different policies for public and confidential clients, and this type of hybrid
approach does not provide all the assurances of confidential clients that an
authorization server is expecting. Authorization servers may wish to treat this type
of deployment as a public client.</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Public browser-based apps needing user authorization create an authorization
request URI with the authorization code grant type per Section 4.1 of
OAuth 2.0 <xref target="RFC6749"/>, using a redirect URI capable of being received by the app.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Public browser-based apps MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension to OAuth, and authorization servers MUST support
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the same client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based apps MUST use the OAuth 2.0 "state" parameter to protect themselves
against Cross-Site Request Forgery and authorization code swap attacks and MUST use
a unique value for each authorization request, and MUST verify the returned state
in the authorization response matches the original state the app created.</t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers SHOULD require an exact match of a registered redirect URI.</t>

<t>If an authorization server wishes to provide some flexibility in redirect URI usage
to clients, it MAY require that only the hostname component of the redirect URI match
the hostname of the URL the application is served from.</t>

<t>Authorization servers MUST support one of the two redirect URI validation mechanisms
as described above.</t>

</section>
</section>
<section anchor="refresh-tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. <xref target="oauth-security-topics"/> describes some additional
requirements around refresh tokens on top of the recommendations of <xref target="RFC6749"/>.</t>

<t>For public clients, the risk of a leaked refresh token is much greater than leaked
access tokens, since an attacker can potentially continue using the stoken refresh
token to obtain new access without being detectable by the authorization server.
Additionally, browser-based applications provide many attack vectors by which a
refresh token can be leaked. As such, these applications are considered a higher risk
for handling refresh tokens.</t>

<t>Authorization servers SHOULD NOT issue refresh tokens to browser-based applications.</t>

<t>If an authorization server does choose to issue refresh tokens to browser-based
applications, then it MUST issue a new refresh token with every access token refresh
response. Doing this mitigates the risk of a leaked refresh token, as a
leaked refresh token can be detected if both the attacker and the legitimate client
attempt to use the same refresh token. Authorization servers MUST follow the
additional refresh token replay mitigation techniques described in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured. Even when the user has previously approved an
authorization request for a given client_id, the request SHOULD be
processed as if no previous request had been approved, unless the identity of
the client can be proven.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs without wildcard domains, paths, or query string components, this exact
match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Section 5.3.5 of <xref target="RFC6819"/> recommends using the "state" parameter to
link client requests and responses to prevent CSRF (Cross-Site Request Forgery)
attacks. To conform to this best practice, use of the "state" parameter is
REQUIRED, as described in <xref target="auth_code_request"/>.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>The security considerations around the authorization server mix-up that
are referenced in Section 8.10 of <xref target="RFC8252"/> also apply to browser-based apps.</t>

<t>Clients MUST use a unique redirect URI for each authorization server used by the
application. The client MUST store the redirect URI along with the session data
(e.g. along with "state") and MUST verify that the URI on which the authorization
response was received exactly matches.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the authorization code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing. If POSTs in particular from
unsupported single-page applications are to be rejected as errors per authorization
server security policy, such rejection is typically done based on the Origin
request header.</t>

</section>
<section anchor="csp" title="Content-Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Grant Authorization Flow">

<t>The OAuth 2.0 Implicit grant authorization flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by receiving an access token in the HTTP redirect
(front-channel) immediately without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token. Several attacks
on the implicit flow are described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
not all of which have sufficient mitigation strategies.</t>

<section anchor="threat-interception-of-the-redirect-uri" title="Threat: Interception of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
his control, he will directly get access to the fragment carrying the access token.
A method of performing this attack is described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser via various
means, including when the browser's HTTPS connection is being man-in-the-middled
by for example a corporate network. While this type of attack is typically out of
scope of basic security recommendations to prevent, in the case of browser-based
apps it is much easier to perform this kind of attack, where an injected script
can suddenly have access to everything on the page.</t>

<t>The risk of a malicious script running on the page is far greater when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the window.location to find an access token. This threat profile is
very different compared to an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the authorization code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the authorization code with PKCE avoids these attacks.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that an access token was
issued to it, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front channel redirect gives the authorization
server little assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the authorization code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the authorization code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally
signed. Performing OpenID Connect using the authorization code flow also provides
the additional benefit of the client not needing to verify the JWT signature, as the
token will have been fetched over an HTTPS connection directly from the authorization
server. However, returning an id_token using the Implicit flow requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent id_tokens.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to single-page apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. Now with the Session History API (described in
"Session history and navigation" of <xref target="HTML"/>), browsers have a mechanism to modify
the path component of the URL without triggering a page reload, so this overloaded
use of the fragment portion is no longer needed.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization>Google, Inc</organization>
    </author>
    <author initials="D." surname="Veditz" fullname="Dan Veditz">
      <organization>Mozilla Corporation</organization>
    </author>
    <date year="2016" month="December"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2018" month="November"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching on redirect URIs or matching the hostname the application
is served from.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
</list></t>

</section>
<section anchor="document-history" title="Document History">

<t>[[ To be removed from the final specification ]]</t>

<t>-01</t>

<t><list style="symbols">
  <t>Incorporated feedback from Torsten Lodderstedt</t>
  <t>Updated abstract</t>
  <t>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</t>
  <t>Clarified use of the state parameter for CSRF protection</t>
  <t>Added background information about the original reason the implicit flow was created due to lack of CORS support</t>
  <t>Clarified the same-domain use case where the SPA and API share a cookie domain</t>
  <t>Moved historic note about the fragment URL into the Overview</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, John Bradley, Joseph Heenan, Justin Richer,
Karl McGuinness, Tomek Stojecki, Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAPTSm1wAA7Vd62/byLX/Pn/FwPthk0JSk2z30RQXuI6z2Xibh2/sNCiK
YjEiR9LUFKnLIa1og/zv97xmOENR3rS3XbSwLZHzOHMev/OazOdz1bmusk/1
2/O+2+gni0d61bT6WdvsvW3nz4y3pT7f7bwqm6I2W3iybM2qmzvbreaNgZfm
S3l4iQ/PDTw8f/RYlaaDh588evzH+aNv5k++V8rt2qe6a3vfPXn06I+PnijT
WiMzq9v9U31Zd7atbTd/jlOownRP9bLYKVU0pavXT3Xv58YXzqmde6q07pri
qT5YD7/6pu1au/Lx78N2+FPhMpsWX5nD/7V2NXxzvtBXsILi1tFnvLlz0zZ1
9nnTwsRvbztDf9mtcdVTbfCx/97xY4ui2dKXfeue6k3X7fzT3/+eHsmfSCZ/
vtAfjOtsMvVzc+fK5FOa+Ar2rS9LW8MxHdIVlPj0f5vq1lSutnPfVH3nmtrT
VKpu2q3p3J3FPb97cfHk8eM/yq/fff+H+OsP8dPvv/vmO/n1hyffPsFfL66v
6CfQmVnkooHzqTt9bQvYaXfQV03lCl7VQGHYpmzotbu1+oP1HX0qG3+9SD+i
Pf7UNOvKzuD4i+z989Js9TPTAnckA8CxpZ/dO8JzU+u/2NJ1v6YjAO2zD2mI
182vrqoMbLLdNa1BWtLXzMbPbWG3S9siP38Hn7+wXbHJiEOfHJEinO1+Y7r9
Ol1E8kmUlB/gTxYpLySed83OFT6baZDUeBDPgKL6om9bPJ6r1hSdK+zJc7lp
Wg8HqV81ZWnx1zI7oZvFxDdEI5ClyOthsJ+bTQ3qwpSVPaSj/LwYfUoj/LVf
uqLJT7kuW3vQr8yyB9H3o6MefUyDvDCFXTbN7fiona3wGLrRWScfHe2CSf+m
uYun+wPoqXqVis/Lm9evsgPAD/7fJ63m87k2S9/haSk1HCoP6n4lFtSt/d8e
DtfrVdtsdaZpNWpavQV1qpdWb01pQT+iuug2Vqt8GFCgVq9bA+yxdzARPnL1
54sftf0InODhkZk2dan9pumrUtcNjem873EeVVQOOQu4srUwwsbiwtYOGKS1
5UKpm43z2u9s4Vau4BlL24Ge8jRT4GZYBswFnEWP4HemCxtQnbmFYV3dNdoU
RdPXMlFp72wFUgAbO9p+JbN5WL3Xe1tV+HOJ+mUnUuDJnm2aPa4EVgAagZZj
q4N2211lt7izSP4FH8zWlcC6SoFFapuyL2hLn75yyZ+f1X8l/52ggS9aB8sh
KhQin7g8nS8vLgR3GdcyOsNVBbsHAmUb121f1/gWvsybggcCpWA3L2D4mng5
fS9QFYRcmCZhQOCDtztbXz5HjV/bokPe0Jc/3rzQzy6u1APaQNhN2MhDvQfS
7/pl5fwGTofOdt3DaeOaO7vmQ9fNConhre5ssambqlk7kEemHkCMno7DEVm2
poL93NbNvsZj/fRJjNPnzxohysWVfvL4yUwv+07XrrhF+Sv1GYAV3MqZBghh
W4WUl928AKYqaRVzvwPaNcC8wAwdrqlyy9a0zgpTGu+Bu1MqIVnLZocnpHgD
8QiByjKpBonAh5P3zN4cWHjhT9wUEruHsxkJ+p0zGpVQWYYHlFkDLYCn+mJD
bM1nikIEXFh5lpXhbEEIQN901pT4E5bPugB3U5Oct7WpeFD9IAxK4nmAt6Jy
eYiSD/OXC30DXwLNaUZXgx7SsFCYcwfbaQClFGZnlq5yHdKN1Ee/E0Y2VS4L
KJWHpi5pQpTfnOFUznDjd2FOEJEW1DS9i4gnKpVZJBAxCAKZz59nylS+GXgH
dd0i1bLTIBeOGIyR9yKx3m1dBVxB+1vabm9RQyWyKgOuMhnzmS460tisaF1d
VD3KBszocJNwNCPtyGpWxDuTak3SAv/btW4L6wMpWYHo4AxwQLSmmbIfC7sj
HdrakTzjAd65fPaRbgZiqTdNZ+RLePEOtwzfZGovV4BW34KK3Tdt6fXZ6/fX
N2cz/qnfvKXf3/34P+8v3/34HH+/fnn+6lX8hZ9Q8Mfb96/ke/xtePPi7evX
P755zi/Dp3r00evzv54RbdXZ26uby7dvzl+dIdm6TLMAHkduQuOGzsYO7Bme
i4+6Go+GOQkx8+fPSIgbi2KLuuqgsi1f1pGCOCryDAy6xdFWwKM0FrghcAJ1
gbom4+rZaGlwfp7U1aqpQNWT9OJgTxXsiFTaU4U+Uv4a7Jy/5IlIViKbz3gn
CPlpJ2fPTllQGvs8sy2sO3CqA6hW+BC1cQkCVTWANUpiY/sRpLDjjRpg+mXg
0ZkGwNP7nl7agwh1ZNz1z+bOXAOhd91Cn6OI+mZrO7cFXqT1o0pGBACsqc/Q
MFV2vgOdla11hvr/7Prq/AxP5+2dbe+c3avhXNDoBfUa1Kkn5JPK0TEVZqye
puwbEqJrlPqdfo/Ga5MpsGOshcb6FNSaHMODrIFNMS1YMTh2JEJh2vYAEm3n
SCDcBPhk717AV4CUPIzyzgKOBSbAc4BVAgYEHwT3CwYNCAl4AD58/+5SdA5i
SdfyxJvGd2gwxR5nj/M4k4+9f/eKfgLNyN4DFe+AhGjfYD3PG0KOIFN9WyOK
A1Uqq2VJtPgkELXYGFBElVLXoAd5QYQciogRBsKgAUIGnoVj83pj0BC0wIbA
XGSVLRsW0GGk9GCAi7fvrmeAigwMK5iYbdWB1PXAhzmcArJvAYjqom28n5cN
ONsDCF/o52ByZDQ6k7A4IgawwNrVxPFLi48J3ycrLx2Da9rBHtQtmcymBTEG
WXAdjYMP7GB6t6xIWYVzi6PAZ70w0AnWo+Hwe7RWroCBmSHNgE3KgBYIv6OR
QN3o4dsWFH7Zmv3SFLc+6LVsoJnYr0CLFXIfQ43s0GFExdzAKiJywFw4gGAP
f2rWpAVBAroppmQWNgyHMHKk7/qqhrUKkYy+Q/wGxwsvm66jtbPxIzol6yIn
IFgA5Be0m63yXVPZegFetQW1Gfb7C+4XECcyjQHi2R1CNzjlA0CsAc2GGY1A
nEg/BY8Mbll+HECRcKYzYLua1r7fOIQzsO7BJC0PsKLJyACp9Td4IkD+ejgu
4i0GrCxQLA8TDiQSQ6BprpKmXEhaNu6RhMToq7dg3EU8ogUkGoNW2jVAYfwU
oAgsDpV4PemYEm1zhTHT/0C/sMIQUgOjtrIu9kS9QCDgMfDkvFbTvEeS5JGr
AptV+AD7fzkjCnvBx00N8jtwLWBOWtzLm5ura1QwCKBw5a4Gu2860X5BKwZN
sgDItF0SBiArgBZghuukVSPT+gn5JXVKup93JjJ1RDHeHegA2o8CmYX1rDKG
RmkDf9+jcgEWeQn+AIxBRpyt3GXGioIISzqH8s4Agl+TXI1ssMcPQGUn+rOg
kIGpwNHBdS1d1zImbdEVYWap3a6v0MDlsg5rG3xCMi5IrAYcug506dqSsjWa
JgfnFhT+Qr9JDes17B9H4O0d9PnVpX6QQbmz8MhGHsEF1ebOrRlL4OR/w4jO
3x+OLYzRW4vs4fyW7EJTutWBjZVBVmy24EXiPv6J9YtiRtUBJy1ICpW5jHFE
G4f2QFcNiA84GdaWFHBRL1zru/kVKMsDei7RgJ1A5wiKPmxcFcT72McH8NZa
YWq0YAWcXidgDOEoLrot56ieD2psMkXygHfwABrUrhtTrUgVE/iacfSFDTfI
M/GbrRmKK3hi1VeMIVe0MZpG+wJEpXVNcKgW+kXyLbtarc0NOKl8teRz8gRd
2jWc4a8Jpo3uDz6DK2ZzzbtgdTsWZ8aUALPQ+5sJ1qVQvKikQYLkbXT/DXBc
OFl+WEJbM0XmZNss8UyWoLlpAQn4DvSH0fBrwAYg7auFfgBemeiFjqwbMYgS
jECsE77MxgML3Qs0SSBASifkZ7BBf4rrUlPryt41HIyAsWE7wV1Ygtop2ali
Z7++/dqnLIMP+c5Vg8+JT2cnn5L+IcUhRt/mzjKOaJYkdxvSi+3X6E9UzBMb
twu2KaOImGpUugDwEQY1uCK2hCKlWbBudmqNeRANaMGypYJskQ+MUm7EPdfn
mU6/GGxr6omixmyDD6uiowjj95n/cGW8R6+bI7ywkcuOaQwWbg1HnnjKYlHy
pfNYp5aEior80nwastoBLgKzeowa6GeHiNoI8zQnrdyMjWEmi9PWkIQJ9WFf
I3yXANRuOGxcitr2VefmK+ZFHAjjFcGh2AWPm2BLtG8gmmLfvFvXc5qTrIUn
AWXKRLWnneThwqJb2PBlLTLgO7arIyqVjSVEr+QdjTBv2buqm8PBDgZmRRIE
UJKRSAjrk9NYBhRRwKeANRACoBE4b8Hd64DUfcsxmiSAc9IQxMgFet6A/mDH
M/Q8tubAqA4Ak2dIfde4MhCZdTmwlCs61CIZkOQUbipcIRwdol0clxQRMMO6
RZXdAq72wTalME6hUIsGHYLaioJ114PzqTFxt93CxM/ZZTNRuWM8/0v/Yy3v
KcQXwqLpYv0QbKToHE4x7UmS/NH6lKxPfEnaLmUhNmi7iqa5xehiRDSwYtBd
D2CupgcsJ0LwtX8oA9BZKRgdoTG6vxiYRDVR2sJ5CUTxyaU6KT8PwtZ4GMLu
jMoTgcHoA9ATBK5A1JauLoZRJzBE4HFY8QEW2HVo3GxtV7DmGIqzu6o5kCIL
9n2m2Pl1qLQlpMHQA/9krkaCkx9waHrCQWNlGxeB+q2qVJgPOXwRgeJon5tg
pGSRwGmAUZBsKwuACAwh/YHiDyYMNswfs7cH20RlA0rgflAVTHkarUWNOigW
2MTKkuiiJQz8j9T2BBhRNiUnFwNUIeNPsEmhBQ/hikBWFJSjGDefpdHPYAMY
OboIKPafkBOylIN2aJ2/xQAPwpGaDhp0WlkNzJc7ZiIPO87BZYpEZbG4GGkX
Q4VU2Du/YTB+dzIAkribpYpLQf0VYCrGwlYgYpshOkUhhKUQJUJ7IGFMsosW
SlzAkBKgWZNIfaKsBGUgkhiPDeyuwFb0W2Z1OMzK/RpfnFcItFCiOpkt2gqM
Q0l2lRxW1pC+AFQGv6hReBjTYxRbiKIl5JQoyAqzYloQ49sP59dXSaJMPwjl
LPv9ftHsjd8tAE///uGCTAhNFaVY4N54m3hsS8tYccUm1ETUzNGOIIYqhOjw
NAZJtRH9Prd+5wj/Ooqfx7AVwUmyaOSGwiHwyLTChKtQc9rVCkl6x+qTA4+y
nlkwHJZ4xAOmoMBvDh1BQdORBxyr7jn7OxfjeAGugDbChU6BHWZydJMUOJsr
Fqgdltk4SRXLcg2R+IieEumlXXcH4ge9OSxbR6LVNgZIEhBJ1NagLXmHwIyA
WTApDa9NjR7SiWoSqCFpP+4Y+S1GcDLdXpDhDvXisFaMlCXGgVIA2eGQ4T8G
qS8QpH76KlvSL3g+HLo7BYSUuuLBJ2JiaF9O5GlZmROKST9XIQiG8fNoLk8W
YdDZYCTxWoT7D4vHKLtD2DtJ3MzEkps8Sk/Z14qOmP1X+Ma6u8x/RZJdcqAq
hCBzCr6TZYtSPjIXEc8wgZmustfP/wy0us+anD4IcpyGMg3C120DO/6z5Tg+
ccCPovDVA0q0JHngh0PWJSbGJNQ3yZ40n4TkFQ1GXg5ivhB55ERnntEBUcIY
XEchEAEHSez5mAucT4N1ilNpvIlyKhzKzvbWoCJoeh+11TL4InK604IpJh8r
EYAI8EmIY7Hfz5oYMbrhbAxIZVgNZySndzBEWGp5a4iJUiwLxG8xQJDxsfZH
ObAzSoKd5VkwsYD46BaMwB0syawNrlZfUJLmGg1C4GPA72srUb6JVfu92WWx
+rASZTSAXRhD35mq55C0RW05WY41G95NqBljxrQNJcZgPACVnljOsYnbGxJH
kgQMCTbBjSjDLwOKOeGovwuKIRdT/vDL5XSsX4NYSC4+JKKoniQmHNkzHOrB
Mi2FOGF1pC0HxvREgybaIjLhq8p+dIIEKP2WaL3eg+Ou0D8JBg9g++vzvybZ
TWBECuJnCcyjaO1xxlP9Rsbz2Lcjtbk4RbVUmZCMyJDdvslnB5ZzgrcGkKey
UJBZAuBFTngnwPWG3eOxTXuX49po4kn4SbGMQrfNsiN/GWzePlc5wcNVEhTO
vwVLDxsAKHoyMZWUv9GpJpUuSbQSMSwh0BEiJ4W9Gw4rx67wcV7Z8GKARpEx
gm/CDFpZc2tH0+BJblG5r0nUKIZZy5Mq81pmkveI+h0LsTBz1nQMkapDLJNK
8n2ep5FJFf81UD2heUgcsCkvLeo8Mu/BmE+w2EKdR5qia3+6PjIyAnkCufuK
M0jSUeXUEQ+B6QGIjpOvs5DyTMfnWEYSzd24NXrrSH9FFZhBg+XnfFJ4hvIf
LkMd8wdmDk5u936tQwC42DQNh7m+aPgs5UEUqEnxED6hAViCcgKS4bUUDcmE
J/BDsAbg2DTMMsiQcKJr4Eb/BQxM/opRk7wtp8eshMmwFadeiJsCD4cgeAXq
u3NbND8sPwoesRRkHYoNyNhnk5yC+UQXrmNiWDLUmeWLbAHwY+CR90wwDetC
0RIf1WSdToAPTvqXBUFJj6K9GopSJ4oBNVhTJsYvbfL0l5jTCdRzUlZytcUZ
AK4eA8H04h88WTxWWVlM5h9ENLK0qSE+4YeIGBivUJzvPULUu63U1jBMJM9F
oI18lBJHhbpveATeZAjHbuSKURloIpKEWNmOKbEWAWx1uN+UZhb+Hl0XKKDI
5mIQr83NPVU3XvDiz/OAYHLmeajwxKmHEqZ7isq+RvtHsdwAnEtbgZ8mpW4S
bZhz1krF+jlHYWL009GuoLUgHY7uBpUtYym+T5TyxAoUMYBUpjLrBDiCgdFU
XWdMOOLB6y/gQQ6U4ZIkRkBBGdNJ2aCUu1JSMFT4GKo21CXyjlv2nGzmNA6G
37lmL29I6CSSanwenhBqkDYE8ijy2zHUAG7CTpwHh5XTO+ZB0JctszBF4QM5
Fxr9B862cUYrhFPQVBA4J1UUCPLt4hty24UQPzwmYeRA9qhClWzgtM+ZVHgF
8o+yV6t7bFGMDWQ7kThWAKo+BOPZueFS7NDVIdIZZmMogFGzCgs4DkeJbREP
V8bCn+ivnZRf4gkO0kUnYpI/eBdKOk2QaNdX51E3khoIYSObcGtgYBXDeDUz
DZpdyRTKmIbAULOK8Vx6A4Q0ZPcW+gNjsdRqbYEdkgRQVNbI5v3yH8RjTXSl
t1j639SsER94KigLZEu/A5C8tGAjHyYK6TJ9INVH+ZuT6gjI7yf49PGjxRN9
2nocWQglFiLBYEFrn+hOgo+bbThNFbBsL+0KXrLWFPIwBUf3h/p0lsSYXOVz
CdwpKIZikwhCf7xLXBOeYUNHau8wMlJRXh6LS8rjOGXgV67lWzscKnKz+Avy
iGx9aZXsnLUOYKi6iZPFpzcGpAMzAWHume5rqs0a7UwlbCs740oYQayTwgNs
R2nX3IZx0ePKfRyaWMySkkJWcbEaPRXOYu+qsjBgyzlJBIyMRUyeSqlhE4BQ
cRLQJNFRDgXq5Oqr6Oon+CLMp5P50BVfWpE7qRKZ3BXAjyiHo7MPFJKcOKaK
dg2noDHLScGukA7kTEHCfJFTx+g/HBYxjzk+xDBb5AiFjBW0YHa8JK6ng09X
MWkjINK3q1+GTM6XxmPIpEZD8+3I0Aw+sU8czqkQmgK/63YAa0FkOcNB/oeE
YCiGyTXmD05v76GSANpC/3bBTFLadrw0MLOhI2Q20YNxHHD+fJwCuGZV9dp9
nL/fwY/oR+gQC2OG+2XrPva7Lyf9zeZ036JELE4ia5hq3u/I6FGlctICkmjl
HxaPH8Uzlb426lpC836YdHARuF6ktpAKKkLkMospnQhgygr7ocwtRRPc8iWc
wuGrrpEodja6wYLEwb8IZQSl6Yx6YBfrRfqEHPzDiaCpGHIcshlSdmNzFIOm
WL8esxykl6pDiKQOMiklIO8Cp6MENq0/ieCJizHH0P1GTX2S2zuG+ahhK0WV
CWnJ86kBJ2L8Qoy8fnqBduEkp001coU3Yy14llTn8nkPgKYzeFwY4ARNLz0+
Uy7dDP66a2JSHpsPCVTTn4Dei4YCHE3LsBu7p4c1hGDRsCiE5cTmS3tUcXlE
3MXQIeLtoLuQ1LHpWVJX0XH6gswOzlVbnNvAyrE0Xm9Ay+NzD5LWrU+fqKsf
00hJGeyQ3w3NIihFsrYTzdAh5So4lxtjsY2Rk7pHVs3wonZ8wUKwTKPKevGN
KLcezTvnEhK3l7EDSAyWTnd2pjbNHkNSs0H8wn6IrEnc56cfb3AgKvIXXsJq
2biApYWVWYVdluSD1Id02X9CT4hqqQ56E0v8gP8Kya5i1YtxEhSkVDv1ESUF
VY5Zn8cbqMgnga4CZZpBQHCJFHNA59IVfWVaHqyv5cwRJU23k/mkKbC1/+Bg
GUiIbVuMju7GKeCAjqN14OWJZ8AjSJagO+xi31zNvavUoklpLzqomDdm/iMl
xtdszEfXbAiSOG3CwDLeo53osId8CxoO64jXUFHPK1Kp4xh8C2jK3bnKYlqS
CkySXJCAUgfymBwZdwSGOrSATAdXT2GChUbDxz11ZphTV4voB58+4TUkKIFc
mIf9uEOSZKHPFVe5nhwBUXYF73XCSRKuH8fAUcRiejVlQeaL2Ocoh4c8RL2H
5FHFVoqfKLmfAxQqT8CzyzuKvjQnx0hk8NziXFxIcHxFQKbBhvKCJyfLCx5i
x+4tpQHYtrIs57ZJIn4I9CMSUA+yFpqH4Pdu4Suw9djzGRohNnZUlQXHv1vE
PlYszxMXlOZTMTFz3Dj2my1iQy48ydNwFCxUKg+VxI4lIebhuYO9s6ZKlhPC
3NfyukBfJXyQ93NNNG0NcB1HPxnDninRa0MHGPVK+H61wtofLKMaoC1ZZssX
J6ivvvoKUBvGROQCJdyLG7pq3iUUimmREP6nunmuTirMdE9hBF8sCeTLk2hT
NrYGpaU2HE3EWwlmoMjYjvCswAlrm7Rm5SdJHa6xPTMlOOgyQCibpsRtJDcn
cD0Xy64beQwcev6tXEFKr3OeknKp+pU1t/iyRO5DTxGo1TTnRyZX0nfjVQ+d
YKKHv/ah7WhBYky9H7YNwaSs2nXMLsBLpLekOpA8PLD4bcepVzZF3DlN+EDS
lFxuXZLaD/c/xLamJJpagG8QgL0kodQbsQixq3HVo+0KjmFCe+nnoTQ7iGAf
mnijei3NllVknqGk9GNcTo0yQ03ghzqW/8RGLYqnNX0ZGjSkuTIJEZeWPh/J
PXXD7almWBgFiL0yhWVcTu0qp4vMAQ6PmOR16F4ToWLD4Kf4ImsRW1uOeVFw
MJg7KjRNMRfaP+xcRbMDfFH7tLc2xrkGfjruQ/SSMwbazl09h8fnfH1NiW1Q
q6FtiUow+XYrhL8dqv2F5rawrGJwkK8BwDCJVKgyRSwD7kLEQOME/RBPmMVs
keFYwFEs20vInDLxIBpOCn9iUyp8dws8PSxtJtVVphb6RkChqLS+L0uLrMlt
fFH3UCa24w75zI7fZInWocyKx4ylvclLdEUNQJFQOBBPKq01xRsdYDy+hQSr
q0pE6FiJgWEv0iFD31mUYKw+qRLnOK03UNJmWTXNbfAXAXuXzX5RNUPt/gqp
NTLh0jLbEVejxKzw3J1X5L0N1abUBhauYUg4PHo0yA2daUGti8ChugHx69E8
Jrtf8t09wsctScOG2odzpcmEsGVs0j3Vdwyeo8K63H4nHE/BifI3dTps5AaL
7TW3S0b5vZSOg8pIMXDBLSQx4z0U6A/iO3mjizSFKOoLB6CLW2sq+KJojUef
gLo56zWrZ1JQxIbcxQEsEq40Qxrd7B01dJzhd2dYv91hAyIBJlTK3nV9Uocg
5Ar6K8X8SdtAsPLLoNTNHpvzQ28idYekNe7HBe1ZmOgDxVDHGNFPNPuzpQ9Z
saQaGi3BFIlzycSTvcit5uS1K2PL+q/CsCGSOsGFsZObmx98KISRcCi22AIZ
6AFHfXXlDF3Yo0j0UDyONw5krdqzXOSBpH0dzq4korH+uqfEWKj23PnY6BYu
Khi8B/RKpu59yAo1qKcvf4/vLcCLLIbRqSB10BoqLX8SnXeit3CB96kMTkmM
ZtXNqDPOxPKDJgsejllwb/CmQLm3DsF9NxM4zQa6wi40DNs4z71o5XDTRpZf
i0WibgUDpjaBuRXLmZCqq2MpoAtQWmfvqAy2bfr1hgvg+B4DMvJ0eWmSbVjQ
bS4oO/c4X9ndKYPng3msifZJvASVAxWS+43l/YlpyWhH0Z/QJiyKlh9EEmRB
xBCUE+4hWEeGiYx1XBoqIAzxoFrLL9zADV9zZGb6bgxJE4+uqCrBV6S4Vr/D
lkHq8NHshRCvSaMPw9qK8qAngvjEF5Vg7FA9raejrHBU1DF3n3FiFOwT8Q2w
Ey/1XMUdDg1NSAKJ7Z7oIVxjOcW+hY9Io5LXNdwzJlVoSfoA149wOtJOUqTR
Ntx3TxHrtfoAx8jNPeM7ADmV+Uv0z700ewWAw5dm6geUjv/5w81DtnalW7uO
Ij/YY4sp3KvBnRu1y92rfdnFxv0FPcG16QN/JF18SRYRLWBo6MjL32GRGhdl
sLcztP6oRBr4vgLM/K0wEHzfdSDR3R1uA5kIGi70yxB9bVNxj3QdKHA5LQ7D
xpSUDdsTe8lVFkY7xHlFud07j42JZtUNF/cdFJjrvuwrrgr5JVZoojkJF4hQ
EPnffp+I+g/cJ6L+E/eJqC+5T+TTJ7xQ5PPnL7tRRDHc+XfeKKL+hRtFBkdd
n6qm/OJo5Zd2EWpM1CH690moWCZXY5cSCT1xdypexDG6ChZDIAQ30wIsdIti
Qaq346HIgaOOCxHJAZbkpaH5rSDq8vzN+YhOHO0FX2Cy90yN7jqNWY2hu+Kg
aVSulKHEJpCWOiuxJIBLc6SO72Jji9sKWPHefv9hbqkCzMqyZKgT7VdPlXq8
0JRNxdWd0VGeAVzf2O1xWeWT5NHxpXR5J4enHFX4Ejk1tl6M/Wi6Snncc/EN
zBSoMG77WoQ1lGkH0bFNoZEpkO5jYDMvxw3XgU3UIij1h2QJkxfGTad0s9pY
zmUFNcHXTA9pxXvbm0PKUZZIOW5Y1bewqjcN3WHbbyerZUP1GsZKGEYNZYMg
O+PSe1qUD9WdTZ47Iy0jsSPk1OeBr0P49JgH//Y3LByhbNu2iTc4kK7iLqgs
d/r3vwP7P3qMnsJlHeNX2IlvSxQJfnvqTvPf6fe7kutFwz3bv9MXeKHrykmL
GqVK3GSVJUtAx1caAs0pb5ttnUKo0dWN+Wcqf8BYxjXHLfWHpr3Fs00nTxT0
+OZHamvEGpyhYgheBfWMzixseM3VJ/GWcnRW4t03sZWMvbcJYI01FOFGgrIn
m1whGeWOuJgjH5MqvWEAV0/hvKHJEcs0kXnQYvLVFkYut5CKMxjwNZ32JiCJ
Gm8yGpYeDRVavRgnjbd7goUqEGhWtlxz59AEa91EkQGNzh4fBljoiqr4MkfN
4FBwzx8A5zmz1c9tDWaZrUx6p/1M7an6N7dGR1f+8mnYMl7jRyxxZK3UPT0r
+njxhHbDDuiCP/0SvT+vb0D/NitbuzU1j06wf4wkYHohiQDIv7ER/1EJYk+/
aXb6yfcqFPKYLu2fx6u2RxdcAm9iSV4ZCqTTW2uHeKBH4nFqSCq8wUoaMNFB
ePn1Pdf/iznamJ1lnCckPaEZnmIEvjZLW4Ebh9dZAOlncGxgefWF2e7wC/y7
AeY+h2fgy4tNi/diwwOvgSNvzSz9ZwNm6ieLFW76RUVgH0T5iNiznDfgL293
G/0SXASc/Oceb93W7xy9rv5s2kq/Ln7qHQ4D275ptvZWX3fNP/BfBZlNHxvu
/C/gsjd489kz23ZNUbgAAlZVv1qp/wNPZ0L9uGUAAA==

-->

</rfc>

