<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.12 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-07" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2020" month="October" day="02"/>

    <area>Security Area</area>
    <workgroup>Open Authentication Protocol</workgroup>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification details the security considerations and best practices that must be
taken into account when developing browser-based applications that use OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications executing in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices. <xref target="RFC8252"/> makes specific recommendations for how to securely implement OAuth in native
applications, including incorporating additional OAuth extensions where needed.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps and browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText='&quot;OAuth&quot;:'>
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/> and <xref target="RFC6750"/>.</t>
  <t hangText='&quot;Browser-based application&quot;:'>
  An application that is dynamically downloaded and executed in a web browser,
usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>At the time that OAuth 2.0 <xref target="RFC6749"/> and <xref target="RFC6750"/> were created, browser-based JavaScript applications needed a solution that strictly complied with the same-origin policy. Common deployments of OAuth 2.0 involved an application running on a different domain than the authorization server, so it was historically not possible to use the authorization code flow which would require a cross-origin POST request. This was one of the motivations for the definition of the implicit flow, which returns the access token in the front channel via the fragment part of the URL, bypassing the need for a cross-origin POST request.</t>

<t>However, there are several drawbacks to the implicit flow, generally involving vulnerabilities associated with the exposure of the access token in the URL. See <xref target="implicit_flow"/> for an analysis of these attacks and the drawbacks of using the implicit flow in browsers. Additional attacks and security considerations can be found in <xref target="oauth-security-topics"/>.</t>

<t>In recent years, widespread adoption of Cross-Origin Resource Sharing (CORS), which enables exceptions to the same-origin policy, allows browser-based apps to use the OAuth 2.0 authorization code flow and make a POST request to exchange the authorization code for an access token at the token endpoint. In this flow, the access token is never exposed in the less secure front-channel. Furthermore, adding PKCE to the flow ensures that even if an authorization code is intercepted, it is unusable by an attacker.</t>

<t>For this reason, and from other lessons learned, the current best practice for browser-based applications is to use the OAuth 2.0 authorization code flow with PKCE.</t>

<t>Browser-based applications:</t>

<t><list style="symbols">
  <t>MUST use the OAuth 2.0 authorization code flow with the PKCE extension when obtaining an access token</t>
  <t>MUST Protect themselves against CSRF attacks by either:
  <list style="symbols">
      <t>ensuring the authorization server supports PKCE, or</t>
      <t>by using the OAuth 2.0 "state" parameter or the OpenID Connect "nonce" parameter to carry one-time use CSRF tokens</t>
    </list></t>
  <t>MUST Register one or more redirect URIs, and use only exact registered redirect URIs in authorization requests</t>
</list></t>

<t>OAuth 2.0 authorization servers:</t>

<t><list style="symbols">
  <t>MUST Require exact matching of registered redirect URIs</t>
  <t>MUST Support the PKCE extension</t>
  <t>MUST NOT issue access tokens in the authorization response</t>
  <t>If issuing refresh tokens to browser-based apps, then:
  <list style="symbols">
      <t>SHOULD rotate refresh tokens on each use, and</t>
      <t>MUST set a maximum lifetime on refresh tokens or expire if they are not used in some amount of time</t>
    </list></t>
</list></t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth was initially created to allow third-party
applications to access an API on behalf of a user, it has proven to be
useful in a first-party scenario as well. First-party apps are applications where
the same organization provides both the API and the application.</t>

<t>Examples of first-party applications are a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use a redirect-based flow (such as the OAuth Authorization Code flow) 
as described later in this document.</t>

<t>The Resource Owner Password Grant MUST NOT be used, as described in 
<xref target="oauth-security-topics"/> section 3.4. Instead, by using the Authorization Code flow 
and redirecting the user to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single-sign-on sessions,
or use third-party identity providers. In contrast, the Password grant does not
provide any built-in mechanism for these, and would instead be extended with custom code.</t>

</section>
<section anchor="application-architecture-patterns" title="Application Architecture Patterns">

<t>There are three primary architectural patterns available when building browser-based
applications.</t>

<t><list style="symbols">
  <t>a JavaScript application that has methods of sharing data with resource servers, such as using common-domain cookies</t>
  <t>a JavaScript application with a backend</t>
  <t>a JavaScript application with no backend, accessing resource servers directly</t>
</list></t>

<t>These three architectures have different use cases and considerations.</t>

<section anchor="browser-based-apps-that-can-share-data-with-the-resource-server" title="Browser-Based Apps that Can Share Data with the Resource Server">

<t>For simple system architectures, such as when the JavaScript application is served
from a domain that can share cookies with the domain of the API (resource server), 
OAuth adds additional attack vectors that could be avoided with a different solution.</t>

<t>In particular, using any redirect-based mechanism of obtaining an access token
enables the redirect-based attacks described in <xref target="oauth-security-topics"/>, but if 
the application, authorization server and resource server share a domain, then it is 
unnecessary to use a redirect mechanism to communicate between them.</t>

<t>An additional concern with handling access tokens in a browser is that as of the date of this publication, there is no
secure storage mechanism where JavaScript code can keep the access token to be later
used in an API request. Using an OAuth flow results in the JavaScript code getting an 
access token, needing to store it somewhere, and then retrieve it to make an API request.</t>

<t>Instead, a more secure design is to use an HTTP-only cookie between the JavaScript application 
and API so that the JavaScript code can't access the cookie value itself. Additionally, the SameSite
cookie attribute can be used to prevent CSRF attacks, or alternatively, the application
and API could be written to use anti-CSRF tokens.</t>

<t>OAuth was originally created for third-party or federated access to APIs, so it may not be
the best solution in a common-domain deployment. That said, using OAuth even in a common-domain
architecture does mean you can more easily rearchitect things later, such as if you were 
to later add a new domain to the system.</t>

</section>
<section anchor="javascript-applications-with-a-backend" title="JavaScript Applications with a Backend">

<figure><artwork><![CDATA[
+-------------+  +--------------+ +---------------+
|             |  |              | |               |
|Authorization|  |    Token     | |   Resource    |
|  Endpoint   |  |   Endpoint   | |    Server     |
|             |  |              | |               |
+-------------+  +--------------+ +---------------+

       ^                ^                   ^
       |             (D)|                (G)|
       |                v                   v
       |
       |         +--------------------------------+
       |         |                                |
       |         |          Application           |
    (B)|         |            Server              |
       |         |                                |
       |         +--------------------------------+
       |
       |           ^     ^     +          ^    +
       |        (A)|  (C)|  (E)|       (F)|    |(H)
       v           v     +     v          +    v

+-------------------------------------------------+
|                                                 |
|                   Browser                       |
|                                                 |
+-------------------------------------------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is loaded from a dynamic Application Server (A) that also has the ability to execute code itself. This enables the ability to keep
all of the steps involved in obtaining an access token outside of the JavaScript
application.</t>

<t>In this case, the Application Server initiates the OAuth flow itself, by redirecting the browser to the authorization endpoint (B). When the user is redirected back, the browser delivers the authorization code to the application server (C), where it can then exchange it for an access token at the token endpoint (D) using its client secret. The application server then keeps the access token and refresh token stored internally, and creates a separate session with the browser-based app via a 
traditional browser cookie (E).</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it instead makes the request to the Application Server (F), and the Application Server will
make the request with the access token to the Resource Server (H), and forward the response (H)
back to the browser.</t>

<t>(Common examples of this architecture are an Angular front-end with a .NET backend, or
a React front-end with a Spring Boot backend.)</t>

<t>The Application Server SHOULD be considered a confidential client, and issued its own client secret. The Application Server SHOULD use the OAuth 2.0 Authorization Code grant with PKCE to initiate a request for an access token.</t>

<t>Security of the connection between code running in the browser and this Application Server is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found in the OWASP Cheat Sheet series (https://cheatsheetseries.owasp.org/),
such as setting an HTTP-only and Secure cookie to authenticate the session between the
browser and Application Server.</t>

<t>In this scenario, the session between the browser and Application Server SHOULD be a
session cookie provided by the Application Server.</t>

<!--
TODO: security considerations around things like Server Side Request Forgery or logging the cookies

TODO: Add another description of the alternative architecture where access tokens are passed to JS and the JS app makes API calls directly. https://mailarchive.ietf.org/arch/msg/oauth/sl-g6zYSpJW3sYqrR0peadUw54U/
-->

</section>
<section anchor="javascript-applications-without-a-backend" title="JavaScript Applications without a Backend">

<figure><artwork><![CDATA[
                      +---------------+           +--------------+
                      |               |           |              |
                      | Authorization |           |   Resource   |
                      |    Server     |           |    Server    |
                      |               |           |              |
                      +---------------+           +--------------+

                             ^     +                 ^     +
                             |     |                 |     |
                             |(B)  |(C)              |(D)  |(E)
                             |     |                 |     |
                             |     |                 |     |
                             +     v                 +     v

+-----------------+         +-------------------------------+
|                 |   (A)   |                               |
| Static Web Host | +-----> |           Browser             |
|                 |         |                               |
+-----------------+         +-------------------------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is first loaded from a static web host into
the browser (A), and the application then runs in the browser. This application is considered a public
client, since there is no way to issue it a client secret and there is no other secure
client authentication mechanism available in the browser.</t>

<t>The code in the browser initiates the authorization code flow with the PKCE
extension (described in <xref target="authorization_code_flow"/>) (B) above, and obtains an
access token via a POST request (C). The JavaScript app is then responsible for storing
the access token (and optional refresh token) securely using appropriate browser APIs.</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it can include the access token in the request (D) and make the request directly.</t>

<t>In this scenario, the Authorization Server and Resource Server MUST support
the necessary CORS headers to enable the JavaScript code to make this POST request
from the domain on which the script is executing. (See <xref target="cors"/> for additional details.)</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Public browser-based apps that use the authorization code grant type described in
Section 4.1 of OAuth 2.0 <xref target="RFC6749"/> MUST also follow these additional requirements
described in this section.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Public browser-based apps MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension when obtaining an access token, and authorization servers MUST support and enforce
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the same client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based apps MUST prevent CSRF attacks against their redirect URI. This can be
accomplished by any of the below:</t>

<t><list style="symbols">
  <t>using PKCE, and confirming that the authorization server supports PKCE</t>
  <t>using a unique value for the OAuth 2.0 "state" parameter</t>
  <t>if the application is using OpenID Connect, by using the OpenID Connect "nonce" parameter</t>
</list></t>

<t>Browser-based apps MUST follow the recommendations in <xref target="oauth-security-topics"/> 
Section 2.1 to protect themselves during redirect flows.</t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers MUST require an exact match of a registered redirect URI.</t>

</section>
</section>
<section anchor="refresh_tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. With public clients, the risk of a leaked refresh token 
is greater than leaked access tokens, since an attacker may be able to 
continue using the stolen refresh token to obtain new access tokens potentially without being 
detectable by the authorization server.</t>

<t>Browser-based applications provide an attacker with several opportunities by which a
refresh token can be leaked, just as with access tokens. As such, these applications 
are considered a higher risk for handling refresh tokens.</t>

<t>Authorization servers may choose whether or not to issue refresh tokens to browser-based
applications. <xref target="oauth-security-topics"/> describes some additional requirements around refresh tokens 
on top of the recommendations of <xref target="RFC6749"/>. Applications and authorization servers 
conforming to this BCP MUST also follow the recommendations in <xref target="oauth-security-topics"/> 
around refresh tokens if refresh tokens are issued to browser-based apps.</t>

<t>In particular, authorization servers:</t>

<t><list style="symbols">
  <t>SHOULD rotate refresh tokens on each use, in order to be able to detect a stolen refresh token if one is replayed (described in <xref target="oauth-security-topics"/> section 4.12)</t>
  <t>MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time</t>
  <t>upon issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token if the refresh token has a preestablished expiration time</t>
</list></t>

<t>For example:</t>

<t><list style="symbols">
  <t>A user authorizes an application, issuing an access token that lasts 1 hour, and a refresh token that lasts 24 hours</t>
  <t>After 1 hour, the initial access token expires, so the application uses the refresh token to get a new access token</t>
  <t>The authorization server returns a new access token that lasts 1 hour, and a new refresh token that lasts 23 hours</t>
  <t>This continues until 24 hours pass from the initial authorization</t>
  <t>At this point, when the application attempts to use the refresh token after 24 hours, the request will fail and the application will have to involve the user in a new authorization request</t>
</list></t>

<t>By limiting the overall refresh token lifetime to the lifetime of the initial refresh token, this ensures a stolen refresh token cannot be used indefinitely.</t>

<t>Authorization servers MAY set different policies around refresh token issuance, lifetime and expiration for browser-based apps compared to other public clients.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs, preventing the use of wildcard domains, wildcard paths, or wildcard query string components, 
this exact match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Clients MUST prevent Cross-Site Request Forgery (CSRF) attacks against their redirect URI.
Clients can accomplish this by either ensuring the authorization server supports
PKCE and relying on the CSRF protection that PKCE provides, or if the client is also an 
OpenID Connect client, using the OpenID Connect "nonce" parameter, or by using the 
"state" parameter to carry one-time-use CSRF tokens as described in <xref target="auth_code_request"/>.</t>

<t>See Section 2.1 of <xref target="oauth-security-topics"/> for additional details.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>The security considerations around the authorization server mix-up that
are referenced in Section 8.10 of <xref target="RFC8252"/> also apply to browser-based apps.</t>

<t>Clients MUST use a unique redirect URI for each authorization server used by the
application. The client MUST store the redirect URI along with the session data
(e.g. along with "state") and MUST verify that the URI on which the authorization
response was received exactly matches.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the authorization code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing.</t>

</section>
<section anchor="csp" title="Content-Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Flow">

<t>The OAuth 2.0 Implicit flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by the authorization server issuing an access token in the
authorization response (front-channel) without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token.</t>

<t>Authorization servers MUST NOT issue access tokens in the authorization response, and MUST issue
access tokens only from the token endpoint.</t>

<section anchor="attacks-on-the-implicit-flow" title="Attacks on the Implicit Flow">

<t>Many attacks on the implicit flow described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>
do not have sufficient mitigation strategies. The following sections describe the specific
attacks that cannot be mitigated while continuing to use the implicit flow.</t>

<section anchor="threat-interception-of-the-redirect-uri" title="Threat: Interception of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
their control, they will directly get access to the authorization response including the access token.
Several methods of performing this attack are described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

<t>This is discussed in more detail in Section 4.3.2 of <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser through various
means, including when the browser's HTTPS connection is being man-in-the-middled
by, for example, a corporate network. While this type of attack is typically out of
scope of basic security recommendations to prevent, in the case of browser-based
apps it is much easier to perform this kind of attack, where an injected script
can suddenly have access to everything on the page.</t>

<t>The risk of a malicious script running on the page may be amplified when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the <spanx style="verb">window.location</spanx> variable to find an access token. This threat profile
is different from an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the authorization code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the authorization code with PKCE extension prevents the attacks described above by
avoiding returning the access token in the redirect response at all.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that a particular access token was
intended for that client, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front-channel redirect gives the authorization
server no assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the authorization code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the authorization code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally
signed. Returning an id_token using the Implicit flow (<spanx style="verb">response_type=id_token</spanx>) requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent id_tokens. Performing OpenID Connect using the authorization code flow provides
the benefit of the client not needing to verify the JWT signature, as the ID token will 
have been fetched over an HTTPS connection directly from the authorization server. Additionally,
in many cases an application will request both an ID token and an access token, so it is
simplier and provides fewer attack vectors to obtain both via the authorization code flow.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to single-page apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. This was necessary in order to remove the
access token from the URL after it was obtained by the app.</t>

<t>Modern browsers now have the Session History API (described in "Session history and
navigation" of <xref target="HTML"/>), which provides a mechanism to modify the path and query string
component of the URL without triggering a page reload. This means modern browser-based apps can
use the unmodified OAuth 2.0 authorization code flow, since they have the ability to
remove the authorization code from the query string without triggering a page reload
thanks to the Session History API.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6750;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <date year="2018" month="October"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2019" month="July"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2020"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth authorization servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching of registered redirect URIs.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
  <t>Not support the Resource Owner Password grant for browser-based clients.</t>
  <t>Follow the <xref target="oauth-security-topics"/> recommendations on refresh tokens, as well
as the additional requirements described in <xref target="refresh_tokens"/>.</t>
</list></t>

</section>
<section anchor="document-history" title="Document History">

<t>[[ To be removed from the final specification ]]</t>

<t>-07</t>

<t><list style="symbols">
  <t>Clarify PKCE requirements apply only to issuing access tokens</t>
  <t>Change "MUST" to "SHOULD" for refresh token rotation</t>
  <t>Editorial clarifications</t>
</list></t>

<t>-06</t>

<t><list style="symbols">
  <t>Added refresh token requirements to AS summary</t>
  <t>Editorial clarifications</t>
</list></t>

<t>-05</t>

<t><list style="symbols">
  <t>Incorporated editorial and substantive feedback from Mike Jones</t>
  <t>Added references to "nonce" as another way to prevent CSRF attacks</t>
  <t>Updated headers in the Implicit Flow section to better represent the relationship between the paragraphs</t>
</list></t>

<t>-04</t>

<t><list style="symbols">
  <t>Disallow the use of the Password Grant</t>
  <t>Add PKCE support to summary list for authorization server requirements</t>
  <t>Rewrote refresh token section to allow refresh tokens if they are time-limited, rotated on each use, and requiring that the rotated refresh token lifetimes do not extend past the lifetime of the initial refresh token, and to bring it in line with the Security BCP</t>
  <t>Updated recommendations on using state to reflect the Security BCP</t>
  <t>Updated server support checklist to reflect latest changes</t>
  <t>Updated the same-domain JS architecture section to emphasize the architecture rather than domain</t>
  <t>Editorial clarifications in the section that talks about OpenID Connect ID tokens</t>
</list></t>

<t>-03</t>

<t><list style="symbols">
  <t>Updated the historic note about the fragment URL clarifying that the Session History API means browsers can use the unmodified authorization code flow</t>
  <t>Rephrased "Authorization Code Flow" intro paragraph to better lead into the next two sections</t>
  <t>Softened "is likely a better decision to avoid using OAuth entirely" to "it may be&#8230;" for common-domain deployments</t>
  <t>Updated abstract to not be limited to public clients, since the later sections talk about confidential clients</t>
  <t>Removed references to avoiding OpenID Connect for same-domain architectures</t>
  <t>Updated headers to better describe architectures (Apps Served from a Static Web Server -&gt; JavaScript Applications without a Backend)</t>
  <t>Expanded "same-domain architecture" section to better explain the problems that OAuth has in this scenario</t>
  <t>Referenced Security BCP in implicit flow attacks where possible</t>
  <t>Minor typo corrections</t>
</list></t>

<t>-02</t>

<t><list style="symbols">
  <t>Rewrote overview section incorporating feedback from Leo Tohill</t>
  <t>Updated summary recommendation bullet points to split out application and server requirements</t>
  <t>Removed the allowance on hostname-only redirect URI matching, now requiring exact redirect URI matching</t>
  <t>Updated section 6.2 to drop reference of SPA with a backend component being a public client</t>
  <t>Expanded the architecture section to explicitly mention three architectural patterns available to JS apps</t>
</list></t>

<t>-01</t>

<t><list style="symbols">
  <t>Incorporated feedback from Torsten Lodderstedt</t>
  <t>Updated abstract</t>
  <t>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</t>
  <t>Clarified use of the state parameter for CSRF protection</t>
  <t>Added background information about the original reason the implicit flow was created due to lack of CORS support</t>
  <t>Clarified the same-domain use case where the SPA and API share a cookie domain</t>
  <t>Moved historic note about the fragment URL into the Overview</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, Janak Amarasena, John Bradley, Joseph Heenan,
Justin Richer, Karl McGuinness, Leo Tohill, Mike Jones, Tomek Stojecki, 
Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
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
HOABE3S0MlwNjgr1cb5QXbjTNCrnmlGoH0BLjcEwrYST2yQT9mRts+sSdvL+
Vvf0bWkTfkeaoww8UU79XKknC+2PwjmgjT0Am3ENys1emvLT6NGHn5oDLz6D
F90Sh1XZCzdkHteQ7lML9RShOvrWu+gHyfdyntpIAo9SX0dT4OPipNlASBsc
7SEY810O3Tp2yScYhyj6GIX7YJlvYx03LlDqG5jVTzWd79q7ExHTrcqijC7W
k0NWLfYHC1mRHH7CSbUu+blOc9Fd2ztUvmBXvpWPt9FxRlNHc3ADg/2qiFD3
8B0lLPs0g+nkqL0Cv2E12MydsMNnQosiPlFTOEjeGtTi0pmhLxxtupjGPh39
53/qy5oLFpBh54E1r7Av9iAj4r/+C0j48XdoA5/gabQgtwir02JHSoSiGIHU
W+75JPF9Rg8+ohUfdMeuEqzTqpVGDoGF114CMADVqDMgTsAfqgTz+pZKxfJ8
r7o3mR727r6Ard/g6Rj3jPgNjnjqj/jF9CX/NGvXSzTZyJpZgaZLXRgJgnRi
/RsQ2208J84nozm4tD60NKQtm/QdGKv3h0E+bHOagUt5KUaCpr5QhRxz5PRr
LIzXurYRyQk8cbc7zBwEVN+uad1f47rRHeOxOrLA0lNreHmMBp6eagdfjSxd
T2Xdp+070HNwi1xwsHvRmng++/WnnTuVizIdJX428/WP9eAQMPlu0t9gtFbS
V0mhnCPhJiWTWyOm9APrvziEBSyEe7Li5mEeUXCKeVUFD/YOmz3CMiQkSOWw
pBKvSqmtmBokTW3VmRO18euov7d8JOmVjdGNnGJ45qRIDWzxF/cHjHbHbrZr
02JrSuJb8VNAPGtXWi+d7Kcpz6G2H5r2yJTX7kipgbHqrDJC3WdqMHl3kCxu
n43OpPKGCqrTPIFdghFjdgDr095uQNk0oj5PKM2E4dt1Q/LjYKI/zwHn6gWC
jGiZvH4+8FcBLurutvY5CeiOqsH4QXPnoOBQADrm3euYr9Y6SkLvcXriALns
yx0zYznVYGkXiwWz5KkjDGJkMcuW46xd7eIEUTB72JfBmxBy8IDPrcC9lp0a
aQbLnIKlVcpTvUt8gCDUmybC4eTgmxHWGiDuszzSs38OqTKRVFjfdS3qOye6
7fzP+sENKrGA/OWnLZ/TdjA12YMRBm8/bUuXlQBK5LK0G1GBeV/Xpg39kKQN
FkHQZzfHbAMfTZ2YzoHMMTfnZcZ696JCF/Vui4m4TeOQEGjwqYqYeS1nYfup
F16e4lalYvOtrUEfWWNObsS/RJakzFAv+7K0nQ5Zsy1Mu6PI8vBQuSlxw0hE
3AolCzmW0ayv266ic3Yl0SGkUDu9f0Y+gyBH3LGdI48mnJhB8O3iKYVHmnob
UJhSAs6OB0dahQoWCVIOqgRjvNljuzFz/sSbiqnXSE7EVwenWo2fDyYtXgHj
cW+f7KlE6Q5egoKPp6+8rXNyaNu8G2EQXoEsZNrpwdrjJxmz/OVU3ES9p6QW
HyL0KcWU0Y4etQvOJNEf6+baUrl7+Hik2LBMDTUU1FkrLffwyhwu+KqRjsjs
NSZk8+LFnSwjQamR6AC6p9yhM3lPcC4RjHhUNObjurTnIahi5uBOHYu6aCEK
+QN95GQoaUzsJe87wvsHSUYvbvyZ9kodZ+gtL21+JbQ05htwZmErh+FRYBqZ
dHiZxsW0EVzzRyD6wmz0C1tVRctukjf1GhOzTF7a3UzdUgHogAvgJoV4Qiu7
YXN27fpWV0N3i5quXF7o/clTSMKtgNxQ+jWGr1p92WbremWr4oq6k42gvw+Q
YlwvCmxS63xgYKeuWgzRs10DS3j6nW8pjbnMUl8hfVwGxxZhs8aaD4uU4paQ
rBgSKVoEHqfxSZEvCFUDMtgRrzu2sMm9DgTIs7W5azu/EewbMQufYwZTZZZg
uFqSZwD6GWxbAdrRidls8Qb+XQNyH8MzcPNk3QDy4QPvACOvzUy/MFVhS/0K
hNpM/WixAgz0IXL8AynvAXsGorUyMB5IBtjBCkZIkAX+akHX0q/BwIHZqDc9
fK7S5wWP9xfTlPpd9iOYpjAuwCEInllku83g2sZeg2yv/wZKczHTanSDEUb/
UXRITbX+wTZdnWWF83etyn61Uv8f1ua1oSyPAAA=

-->

</rfc>

