<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-05" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2020" month="February" day="28"/>

    <area>Security Area</area>
    <workgroup>Open Authentication Protocol</workgroup>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification details the security considerations and best practices that must be
taken into account when developing browser-based applications that use OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications executing in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices. <xref target="RFC8252"/> makes specific recommendations for how to securely implement OAuth in native
applications, including incorporating additional OAuth extensions where needed.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps and browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText='&quot;OAuth&quot;:'>
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/> and <xref target="RFC6750"/>.</t>
  <t hangText='&quot;Browser-based application&quot;:'>
  An application that is dynamically downloaded and executed in a web browser,
usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>At the time that OAuth 2.0 <xref target="RFC6749"/> and <xref target="RFC6750"/> were created, browser-based JavaScript applications needed a solution that strictly complied with the same-origin policy. Common deployments of OAuth 2.0 involved an application running on a different domain than the authorization server, so it was historically not possible to use the authorization code flow which would require a cross-origin POST request. This was one of the motivations for the definition of the implicit flow, which returns the access token in the front channel via the fragment part of the URL, bypassing the need for a cross-origin POST request.</t>

<t>However, there are several drawbacks to the implicit flow, generally involving vulnerabilities associated with the exposure of the access token in the URL. See <xref target="implicit_flow"/> for an analysis of these attacks and the drawbacks of using the implicit flow in browsers. Additional attacks and security considerations can be found in <xref target="oauth-security-topics"/>.</t>

<t>In recent years, widespread adoption of Cross-Origin Resource Sharing (CORS), which enables exceptions to the same-origin policy, allows browser-based apps to use the OAuth 2.0 authorization code flow and make a POST request to exchange the authorization code for an access token at the token endpoint. In this flow, the access token is never exposed in the less secure front-channel. Furthermore, adding PKCE to the flow ensures that even if an authorization code is intercepted, it is unusable by an attacker.</t>

<t>For this reason, and from other lessons learned, the current best practice for browser-based applications is to use the OAuth 2.0 authorization code flow with PKCE.</t>

<t>Browser-based applications MUST:</t>

<t><list style="symbols">
  <t>Use the OAuth 2.0 authorization code flow with the PKCE extension</t>
  <t>Protect themselves against CSRF attacks by using the OAuth 2.0 state parameter or the OpenID Connect nonce parameter to carry one-time use CSRF tokens, or by ensuring the authorization server supports PKCE</t>
  <t>Register one or more redirect URIs, and use only exact registered redirect URIs in authorization requests</t>
</list></t>

<t>OAuth 2.0 authorization servers MUST:</t>

<t><list style="symbols">
  <t>Require exact matching of registered redirect URIs</t>
  <t>Support the PKCE extension</t>
</list></t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth was initially created to allow third-party
applications to access an API on behalf of a user, it has proven to be
useful in a first-party scenario as well. First-party apps are applications where
the same organization provides both the API and the application.</t>

<t>Examples of first-party applications are a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use a redirect-based flow (such as the OAuth Authorization Code flow) 
as described later in this document.</t>

<t>The Resource Owner Password Grant MUST NOT be used, as described in 
<xref target="oauth-security-topics"/> section 3.4. Instead, by using the Authorization Code flow 
and redirecting the user to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single-sign-on sessions,
or use third-party identity providers. In contrast, the Password grant does not
provide any built-in mechanism for these, and would instead be extended with custom code.</t>

</section>
<section anchor="application-architecture-patterns" title="Application Architecture Patterns">

<t>There are three primary architectural patterns available when building browser-based
applications.</t>

<t><list style="symbols">
  <t>a JavaScript application that has methods of sharing data with resource servers, such as using common-domain cookies</t>
  <t>a JavaScript application with a backend</t>
  <t>a JavaScript application with no backend, accessing resource servers directly</t>
</list></t>

<t>These three architectures have different use cases and considerations.</t>

<section anchor="browser-based-apps-that-can-share-data-with-the-resource-server" title="Browser-Based Apps that Can Share Data with the Resource Server">

<t>For simple system architectures, such as when the JavaScript application is served
from a domain that can share cookies with the domain of the API (resource server), 
OAuth adds additional attack vectors that could be avoided with a different solution.</t>

<t>In particular, using any redirect-based mechanism of obtaining an access token
enables the redirect-based attacks described in <xref target="oauth-security-topics"/>, but if 
the application, authorization server and resource server share a domain, then it is 
unnecessary to use a redirect mechanism to communicate between them.</t>

<t>An additional concern with handling access tokens in a browser is that as of the date of this publication, there is no
secure storage mechanism where JavaScript code can keep the access token to be later
used in an API request. Using an OAuth flow results in the JavaScript code getting an 
access token, needing to store it somewhere, and then retrieve it to make an API request.</t>

<t>Instead, a more secure design is to use an HTTP-only cookie between the JavaScript application 
and API so that the JavaScript code can't access the cookie value itself. Additionally, the SameSite
cookie attribute can be used to prevent CSRF attacks, or alternatively, the application
and API could be written to use anti-CSRF tokens.</t>

<t>OAuth was originally created for third-party or federated access to APIs, so it may not be
the best solution in a common-domain deployment. That said, using OAuth even in a common-domain
architecture does mean you can more easily rearchitect things later, such as if you were 
to later add a new domain to the system.</t>

</section>
<section anchor="javascript-applications-with-a-backend" title="JavaScript Applications with a Backend">

<figure><artwork><![CDATA[
+-------------+
|             |
|Authorization|
|   Server    |
|             |
+-------------+

   ^     +
   |(A)  |(B)
   |     |
   +     v

+-------------+             +--------------+
|             | +---------> |              |
| Application |   (C)       |   Resource   |
|   Server    |             |    Server    |
|             | <---------+ |              |
+-------------+   (D)       +--------------+

    ^    +
    |    |
    |    | browser
    |    | cookie
    |    |
    +    v

+-------------+
|             |
|   Browser   |
|             |
+-------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is loaded from a dynamic Application Server
that also has the ability to execute code itself. This enables the ability to keep
all of the steps involved in obtaining an access token outside of the JavaScript
application.</t>

<t>In this case, the Application Server performs the OAuth flow itself, and keeps the 
access token and refresh token stored internally, creating a separate session with
the browser-based app via a traditional browser cookie.</t>

<t>(Common examples of this architecture are an Angular front-end with a .NET backend, or
a React front-end with a Spring Boot backend.)</t>

<t>The Application Server SHOULD be considered a confidential client, and issued its own client
secret. The Application Server SHOULD use the OAuth 2.0 authorization code grant to initiate
a request for an access token. Upon handling the redirect from the Authorization
Server, the Application Server will request an access token using the authorization code
returned (A), which will be returned to the Application Server (B). The Application Server
stores this access token itself and establishes its own cookie-based session with the Browser application.
The Application Server can store the access token either server-side, or in the cookie itself.</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it MUST instead make the request to the Application Server, and the Application Server will
make the request with the access token to the Resource Server (C), and forward the response (D)
back to the browser.</t>

<t>Security of the connection between code running in the browser and this Application Server is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found in the OWASP Cheat Sheet series (https://cheatsheetseries.owasp.org/),
such as setting an HTTP-only and Secure cookie to authenticate the session between the
browser and Application Server.</t>

<t>In this scenario, the session between the browser and Application Server MAY be either a
session cookie provided by the Application Server, OR the access token itself. Note that
if the access token is used as the session identifier, this exposes the access token
to the end user even if it is not available to the JavaScript application, so some
authorization servers may wish to limit the capabilities of these clients to mitigate risk.</t>

</section>
<section anchor="javascript-applications-without-a-backend" title="JavaScript Applications without a Backend">

<figure><artwork><![CDATA[
                      +---------------+           +--------------+
                      |               |           |              |
                      | Authorization |           |   Resource   |
                      |    Server     |           |    Server    |
                      |               |           |              |
                      +---------------+           +--------------+

                             ^     +                 ^     +
                             |     |                 |     |
                             |(B)  |(C)              |(D)  |(E)
                             |     |                 |     |
                             |     |                 |     |
                             +     v                 +     v

+-----------------+         +-------------------------------+
|                 |   (A)   |                               |
| Static Web Host | +-----> |           Browser             |
|                 |         |                               |
+-----------------+         +-------------------------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is first loaded from a static web host into
the browser (A), and the application then runs in the browser. This application is considered a public
client, since there is no way to issue it a client secret and there is no other secure
client authentication mechanism available in the browser.</t>

<t>The code in the browser initiates the authorization code flow with the PKCE
extension (described in <xref target="authorization_code_flow"/>) (B) above, and obtains an
access token via a POST request (C). The JavaScript app is then responsible for storing
the access token (and optional refresh token) securely using appropriate browser APIs.</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it can include the access token in the request (D) and make the request directly.</t>

<t>In this scenario, the Authorization Server and Resource Server MUST support
the necessary CORS headers to enable the JavaScript code to make this POST request
from the domain on which the script is executing. (See <xref target="cors"/> for additional details.)</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Public browser-based apps that use the authorization code grant type described in
Section 4.1 of OAuth 2.0 <xref target="RFC6749"/> MUST also follow these additional requirements
described in this section.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Public browser-based apps MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension to OAuth, and authorization servers MUST support
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the same client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based apps MUST prevent CSRF attacks against their redirect URI. This can be
accomplished by either using PKCE, using a unique value for the OAuth 2.0 "state" parameter 
on each request, or by using the OpenID Connect "nonce" parameter.</t>

<t>Browser-based apps MUST follow the recommendations in <xref target="oauth-security-topics"/> 
section 3.1 to protect themselves during redirect flows.</t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers MUST require an exact match of a registered redirect URI.</t>

</section>
</section>
<section anchor="refresh_tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. With public clients, the risk of a leaked refresh token 
is greater than leaked access tokens, since an attacker may be able to 
continue using the stolen refresh token to obtain new access tokens potentially without being 
detectable by the authorization server.</t>

<t>Browser-based applications provide an attacker with several opportunities by which a
refresh token can be leaked, just as with access tokens. As such, these applications 
are considered a higher risk for handling refresh tokens.</t>

<t>Authorization servers may choose whether or not to issue refresh tokens to browser-based
applications. <xref target="oauth-security-topics"/> describes some additional requirements around refresh tokens 
on top of the recommendations of <xref target="RFC6749"/>. Applications and authorization servers 
conforming to this BCP MUST also follow the recommendations in <xref target="oauth-security-topics"/> 
around refresh tokens if refresh tokens are issued to browser-based apps.</t>

<t>In particular, authorization servers:</t>

<t><list style="symbols">
  <t>MUST rotate refresh tokens on each use, in order to be able to detect a stolen refresh token if one is replayed (described in <xref target="oauth-security-topics"/> section 4.12)</t>
  <t>MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time</t>
  <t>upon issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token if the refresh token has a preestablished expiration time</t>
</list></t>

<t>For example:</t>

<t><list style="symbols">
  <t>A user authorizes an application, issuing an access token that lasts 1 hour, and a refresh token that lasts 24 hours</t>
  <t>After 1 hour, the initial access token expires, so the application uses the refresh token to get a new access token</t>
  <t>The authorization server returns a new access token that lasts 1 hour, and a new refresh token that lasts 23 hours</t>
  <t>This continues until 24 hours pass from the initial authorization</t>
  <t>At this point, when the application attempts to use the refresh token after 24 hours, the request will fail and the application will have to involve the user in a new authorization request</t>
</list></t>

<t>By limiting the overall refresh token lifetime to the lifetime of the initial refresh token, this ensures a stolen refresh token cannot be used indefinitely.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs, preventing the use of wildcard domains, wildcard paths, or wildcard query string components, 
this exact match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Clients MUST prevent Cross-Site Request Forgery (CSRF) attacks against their redirect URI.
Clients can accomplish this by either ensuring the authorization server supports
PKCE and relying on the CSRF protection that PKCE provides, or using the "state"
parameter to carry one-time-use CSRF tokens as described in <xref target="auth_code_request"/>, 
or if the client is also an OpenID Connect client, using the OpenID Connect "nonce" parameter.</t>

<t>See Section 2.1 of <xref target="oauth-security-topics"/> for additional details.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>The security considerations around the authorization server mix-up that
are referenced in Section 8.10 of <xref target="RFC8252"/> also apply to browser-based apps.</t>

<t>Clients MUST use a unique redirect URI for each authorization server used by the
application. The client MUST store the redirect URI along with the session data
(e.g. along with "state") and MUST verify that the URI on which the authorization
response was received exactly matches.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the authorization code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing.</t>

</section>
<section anchor="csp" title="Content-Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Flow">

<t>The OAuth 2.0 Implicit flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by receiving an access token in the HTTP redirect
(front-channel) immediately without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token.</t>

<section anchor="attacks-on-the-implicit-flow" title="Attacks on the Implicit Flow">

<t>Many attacks on the implicit flow described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>
do not have sufficient mitigation strategies. The following sections describe the specific
attacks that cannot be mitigated while continuing to use the implicit flow.</t>

<section anchor="threat-interception-of-the-redirect-uri" title="Threat: Interception of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
their control, they will directly get access to the fragment carrying the access token.
Several methods of performing this attack are described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

<t>This is discussed in more detail in Section 4.3.2 of <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser through various
means, including when the browser's HTTPS connection is being man-in-the-middled
by, for example, a corporate network. While this type of attack is typically out of
scope of basic security recommendations to prevent, in the case of browser-based
apps it is much easier to perform this kind of attack, where an injected script
can suddenly have access to everything on the page.</t>

<t>The risk of a malicious script running on the page may be amplified when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the <spanx style="verb">window.location</spanx> variable to find an access token. This threat profile
is different from an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the authorization code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the authorization code with PKCE extension prevents the attacks described above by
avoiding returning the access token in the redirect URI at all.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that an access token was
issued to it, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front channel redirect gives the authorization
server no assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the authorization code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the authorization code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally
signed. Returning an id_token using the Implicit flow (response_type=id_token) requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent id_tokens. Performing OpenID Connect using the authorization code flow provides
the benefit of the client not needing to verify the JWT signature, as the ID token will 
have been fetched over an HTTPS connection directly from the authorization server. Additionally,
in many cases an application will request both an ID token and an access token, so it is
simplier and provides fewer attack vectors to obtain both via the authorization code flow.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to single-page apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. This was necessary in order to remove the
access token from the URL after it was obtained by the app.</t>

<t>Modern browsers now have the Session History API (described in "Session history and
navigation" of <xref target="HTML"/>), which provides a mechanism to modify the path and query string
component of the URL without triggering a page reload. This means modern browser-based apps can
use the unmodified OAuth 2.0 authorization code flow, since they have the ability to
remove the authorization code from the query string without triggering a page reload
thanks to the Session History API.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6750;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <date year="2018" month="October"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2019" month="July"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2020"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth authorization servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching of registered redirect URIs.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
  <t>Not support the Resource Owner Password grant for browser-based clients.</t>
  <t>Follow the <xref target="oauth-security-topics"/> recommendations on refresh tokens, as well
as the additional requirements described in <xref target="refresh_tokens"/>.</t>
</list></t>

</section>
<section anchor="document-history" title="Document History">

<t>[[ To be removed from the final specification ]]</t>

<t>-05</t>

<t><list style="symbols">
  <t>Incorporated editorial and substantive feedback from Mike Jones</t>
  <t>Added references to "nonce" as another way to prevent CSRF attacks</t>
  <t>Updated headers in the Implicit Flow section to better represent the relationship between the paragraphs</t>
</list></t>

<t>-04</t>

<t><list style="symbols">
  <t>Disallow the use of the Password Grant</t>
  <t>Add PKCE support to summary list for authorization server requirements</t>
  <t>Rewrote refresh token section to allow refresh tokens if they are time-limited, rotated on each use, and requiring that the rotated refresh token lifetimes do not extend past the lifetime of the initial refresh token, and to bring it in line with the Security BCP</t>
  <t>Updated recommendations on using state to reflect the Security BCP</t>
  <t>Updated server support checklist to reflect latest changes</t>
  <t>Updated the same-domain JS architecture section to emphasize the architecture rather than domain</t>
  <t>Editorial clarifications in the section that talks about OpenID Connect ID tokens</t>
</list></t>

<t>-03</t>

<t><list style="symbols">
  <t>Updated the historic note about the fragment URL clarifying that the Session History API means browsers can use the unmodified authorization code flow</t>
  <t>Rephrased "Authorization Code Flow" intro paragraph to better lead into the next two sections</t>
  <t>Softened "is likely a better decision to avoid using OAuth entirely" to "it may be&#8230;" for common-domain deployments</t>
  <t>Updated abstract to not be limited to public clients, since the later sections talk about confidential clients</t>
  <t>Removed references to avoiding OpenID Connect for same-domain architectures</t>
  <t>Updated headers to better describe architectures (Apps Served from a Static Web Server -&gt; JavaScript Applications without a Backend)</t>
  <t>Expanded "same-domain architecture" section to better explain the problems that OAuth has in this scenario</t>
  <t>Referenced Security BCP in implicit flow attacks where possible</t>
  <t>Minor typo corrections</t>
</list></t>

<t>-02</t>

<t><list style="symbols">
  <t>Rewrote overview section incorporating feedback from Leo Tohill</t>
  <t>Updated summary recommendation bullet points to split out application and server requirements</t>
  <t>Removed the allowance on hostname-only redirect URI matching, now requiring exact redirect URI matching</t>
  <t>Updated section 6.2 to drop reference of SPA with a backend component being a public client</t>
  <t>Expanded the architecture section to explicitly mention three architectural patterns available to JS apps</t>
</list></t>

<t>-01</t>

<t><list style="symbols">
  <t>Incorporated feedback from Torsten Lodderstedt</t>
  <t>Updated abstract</t>
  <t>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</t>
  <t>Clarified use of the state parameter for CSRF protection</t>
  <t>Added background information about the original reason the implicit flow was created due to lack of CORS support</t>
  <t>Clarified the same-domain use case where the SPA and API share a cookie domain</t>
  <t>Moved historic note about the fragment URL into the Overview</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, Janak Amarasena, John Bradley, Joseph Heenan,
Justin Richer, Karl McGuinness, Leo Tohill, Mike Jones, Tomek Stojecki, 
Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAPGkWV4AA7192XLcRpboe35FBv1garqqLFG2261ZYihKsqiWLF6SuoqO
ibkaFJDFQhMF1CABlmpk//ucLTcUQNHjG8PolkksuZw8+4b5fK66sqvMM/3+
tO/W+mTxWK+aVj9vm5017fx5Zk2hT7dbq4omr7MNPFm02aqbl6ZbzZsMXpov
5eElPjzP4OH54x9UkXXw8Mnjk8fzxyfzk5+UKrftM921ve1OHj/+y+MTlbUm
k5nV7e6ZPq8709amm7/AKVSedc/0Mt8qlTdFWd88072dZzYvS7UtnymtuyZ/
pvfGwq+2abvWrKz/e78JfypcZtPiK3P4v9ZlDXdOF/oCVpDflnSNN3eatU2d
XG9amPj9bZfRX2aTldUzneFj/7rlxxZ5s6GbfVs+0+uu29pn331Hj6RPRJO/
WOiPWdmZaOoX2V1ZRFdp4gvYtz4vTA3HtI9XUODT/5pVt1lV1mZum6rvyqa2
NJWqm3aTdeWdwT1fvjo7efLkL/Lrj3/+Pvz6w2P360/+gT//+PRH+fWnkx9O
8Nezqwv6L4CcseWsgaOqO31lcth0t9cXTVXmvMAAbNix7O1deWv0R2M7uiow
eLeIL9F2f26am8rMABNyusxI9D7vmqVpAZme/CSArgKgd7vdYvd0Ae9/d335
HSz16Xfw0CvT5etkzXTlYIUO+rt11u1u4uVFVxwuj02/wmEXdmvyBb9BK4Hn
mDisQGjeNdsyt8mKAs15OD4HgOizvm0RuhdtlndlbibBet20Fs5Bv22KwuCv
RQLg68XIHYIzUIXHWjfYm2ZdA+FnRWX28ShvFoOrNMLf+mWZN8kAp3XRmr1+
my17IGIbjwG0NrhMg7zKcrNsmttkmBdZXZoKjyvZDFBMdOlgF3xEb/pqj+f0
l8Nz6pqmsgtkW3RA625TfXfAyganpcp6FVPS6+t3b5MTxAt/DKVOHh8uFdd2
iFFqPp/rbGk7xAqlrtel1fhQuSqBUwLt68J0wBus7tZGu53oHJhCCThAj1id
1YVeIpJtBbnw8azTG2DLcEN12S0gVFl3jc7yvOkBDXdrg2PfmQqAAuwo4fca
+H0lC5ChemsCai943ZuyAAxSClh82xR9Tuv98k0Z/fmb+ufoZ2KDNm/LpeEt
5kImg+2g/Co328pskGvCev1aRA6U/8WjrSrYB2w13YL5DJCj9/CO2yxs4xWM
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
74gAAA==

-->

</rfc>

