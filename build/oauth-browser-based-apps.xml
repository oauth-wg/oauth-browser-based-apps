<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-04" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2019" month="September" day="22"/>

    <area>Security Area</area>
    <workgroup>Open Authentication Protocol</workgroup>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification details the security considerations and best practices that must be
taken into account when developing browser-based applications that use OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications running entirely in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices.</t>

<t><xref target="RFC8252"/> makes specific recommendations for how to securely implement OAuth in native
applications, including incorporating additional OAuth extensions where needed.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps as well as browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText='&quot;OAuth&quot;:'>
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/>.</t>
  <t hangText='&quot;Browser-based application&quot;:'>
  An application that is dynamically downloaded and executed in a web browser,
usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>At the time that OAuth 2.0 RFC 6749 was created, browser-based JavaScript applications needed a solution that strictly complied with the same-origin policy. Common deployments of OAuth 2.0 involved an application running on a different domain than the authorization server, so it was historically not possible to use the authorization code flow which would require a cross-origin POST request. This was the principal motivation for the definition of the implicit flow, which returns the access token in the front channel via the fragment part of the URL, bypassing the need for a cross-origin POST request.</t>

<t>However, there are several drawbacks to the implicit flow, generally involving vulnerabilities associated with the exposure of the access token in the URL. See <xref target="implicit_flow"/> for an analysis of these attacks and the drawbacks of using the implicit flow in browsers. Additional attacks and security considerations can be found in <xref target="oauth-security-topics"/>.</t>

<t>In recent years, widespread adoption of Cross-Origin Resource Sharing (CORS), which enables exceptions to the same-origin policy, allows browser-based apps to use the OAuth 2.0 authorization code flow and make a POST request to exchange the authorization code for an access token at the token endpoint. In this flow, the access token is never exposed in the less secure front-channel. Furthermore, adding PKCE to the flow assures that even if an authorization code is intercepted, it is unusable by an attacker.</t>

<t>For this reason, and from other lessons learned, the current best practice for browser-based applications is to use the OAuth 2.0 authorization code flow with PKCE.</t>

<t>Browser-based applications MUST:</t>

<t><list style="symbols">
  <t>Use the OAuth 2.0 authorization code flow with the PKCE extension</t>
  <t>Protect themselves against CSRF attacks by using the OAuth 2.0 state parameter to carry one-time use CSRF tokens, or by ensuring the authorization server supports PKCE</t>
  <t>Register one or more redirect URIs, and not vary the redirect URI per authorization request</t>
</list></t>

<t>OAuth 2.0 authorization servers MUST:</t>

<t><list style="symbols">
  <t>Require exact matching of registered redirect URIs</t>
  <t>Support the PKCE extension</t>
</list></t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth was initially created to allow third-party
applications to access an API on behalf of a user, it has proven to be
useful in a first-party scenario as well. First-party apps are applications where
the same organization provides both the API and the application.</t>

<t>For example, a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use the OAuth Authorization Code flow as described later in this document.</t>

<t>The Resource Owner Password Grant MUST NOT be used, as described in 
<xref target="oauth-security-topics"/> section 3.4.</t>

<t>By using the Authorization Code flow and redirecting the user to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single-sign-on sessions,
or use third-party identity providers. In contrast, the Password grant does not
provide any built-in mechanism for these, and would instead be extended with custom code.</t>

</section>
<section anchor="application-architecture-patterns" title="Application Architecture Patterns">

<t>There are three primary architectural patterns available when building browser-based
applications.</t>

<t><list style="symbols">
  <t>a JavaScript application with no backend, accessing resource servers directly</t>
  <t>a JavaScript application with a backend</t>
  <t>a JavaScript application that has methods of sharing data with resource servers, such as using common-domain cookies</t>
</list></t>

<t>These three architectures have different use cases and considerations.</t>

<section anchor="browser-based-apps-that-can-share-data-with-the-resource-server" title="Browser-Based Apps that Can Share Data with the Resource Server">

<t>For simple system architectures, such as when the JavaScript application is served
from a domain that can share cookies with the domain of the API (resource server), 
OAuth adds additional attack vectors that could be avoided with a different solution.</t>

<t>In particular, using any redirect-based mechanism of obtaining an access token
enables the redirect-based attacks described in <xref target="oauth-security-topics"/>, but if 
the application, AS and API share a domain, then it is unnecessary to use a redirect
mechanism to communicate between them.</t>

<t>An additional concern with handling access tokens in a browser is that there is no
secure storage mechanism where JavaScript code can keep the access token to be later
used in an API request. Using an OAuth flow results in the JavaScript code getting an 
access token, needing to store it somewhere, and then retrieve it to make an API request. 
Instead, a more secure design is to use an HTTP-only cookie between the JavaScript application 
and API so that the JavaScript code can't access the cookie value itself.</t>

<t>OAuth was originally created for third-party or federated access to APIs, so it may not be
the best solution in a common-domain deployment. That said, using OAuth even in a common-domain
architecture does mean you can more easily rearchitect things later, such as if you were 
to later add a new domain to the system.</t>

</section>
<section anchor="javascript-applications-with-a-backend" title="JavaScript Applications with a Backend">

<figure><artwork><![CDATA[
+-------------+
|             |
|Authorization|
|   Server    |
|             |
+-------------+

   ^     +
   |(A)  |(B)
   |     |
   +     v

+-------------+             +--------------+
|             | +---------> |              |
| Application |   (C)       |   Resource   |
|   Server    |             |    Server    |
|             | <---------+ |              |
+-------------+   (D)       +--------------+

    ^    +
    |    |
    |    | browser
    |    | cookie
    |    |
    +    v

+-------------+
|             |
|   Browser   |
|             |
+-------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is loaded from a dynamic Application Server
that also has the ability to execute code itself. This enables the ability to keep
all of the steps involved in obtaining an access token outside of the JavaScript
application.</t>

<t>(Common examples of this architecture are an Angular front-end with a .NET backend, or
a React front-end with a Spring Boot backend.)</t>

<t>The Application Server SHOULD be considered a confidential client, and issued its own client
secret. The Application Server SHOULD use the OAuth 2.0 authorization code grant to initiate
a request for an access token. Upon handling the redirect from the Authorization
Server, the Application Server will request an access token using the authorization code
returned (A), which will be returned to the Application Server (B). The Application Server
utilizes its own session with the browser to store the access token.</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it MUST instead make the request to the Application Server, and the Application Server will
make the request with the access token to the Resource Server (C), and forward the response (D)
back to the browser.</t>

<t>Security of the connection between code running in the browser and this Application Server is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found at the OWASP Foundation (https://www.owasp.org/),
such as setting an HTTP-only and Secure cookie to authenticate the session between the
browser and Application Server.</t>

<t>In this scenario, the session between the browser and Application Server MAY be either a
session cookie provided by the Application Server, OR the access token itself. Note that
if the access token is used as the session identifier, this exposes the access token
to the end user even if it is not available to the JavaScript application, so some
authorization servers may wish to limit the capabilities of these clients to mitigate risk.</t>

</section>
<section anchor="javascript-applications-without-a-backend" title="JavaScript Applications without a Backend">

<figure><artwork><![CDATA[
                      +---------------+           +--------------+
                      |               |           |              |
                      | Authorization |           |   Resource   |
                      |    Server     |           |    Server    |
                      |               |           |              |
                      +---------------+           +--------------+

                             ^     +                 ^     +
                             |     |                 |     |
                             |(B)  |(C)              |(D)  |(E)
                             |     |                 |     |
                             |     |                 |     |
                             +     v                 +     v

+-----------------+         +-------------------------------+
|                 |   (A)   |                               |
| Static Web Host | +-----> |           Browser             |
|                 |         |                               |
+-----------------+         +-------------------------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is first loaded from a static web host into
the browser (A). The application then runs in the browser, and is considered a public
client since it has no ability to be issued a client secret.</t>

<t>The code in the browser then initiates the authorization code flow with the PKCE
extension (described in <xref target="authorization_code_flow"/>) (B) above, and obtains an
access token via a POST request (C). The JavaScript app is then responsible for storing
the access token securely using appropriate browser APIs.</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it can include the access token in the request (D) and make the request directly.</t>

<t>In this scenario, the Authorization Server and Resource Server MUST support
the necessary CORS headers to enable the JavaScript code to make this POST request
from the domain on which the script is executing. (See <xref target="cors"/> for additional details.)</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Public browser-based apps that use the authorization code grant type described in
Section 4.1 of OAuth 2.0 <xref target="RFC6749"/> MUST also follow these additional requirements
described in this section.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Public browser-based apps MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension to OAuth, and authorization servers MUST support
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the same client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based apps MUST use a unique value for the the OAuth 2.0 "state" parameter 
on each request, and MUST verify the returned state in the authorization response
matches the original state the app created.</t>

<t>Browser-based apps MUST follow the recommendations in <xref target="oauth-security-topics"/> 
section 3.1 to protect themselves during redirect flows.</t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers MUST require an exact match of a registered redirect URI.</t>

</section>
</section>
<section anchor="refresh_tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. With public clients, the risk of a leaked refresh token 
is greater than leaked access tokens, since an attacker may be able to 
continue using the stolen refresh token to obtain new access tokens potentially without being 
detectable by the authorization server.</t>

<t>Browser-based applications provide an attacker with several opportunities by which a
refresh token can be leaked, just as with access tokens. As such, these applications 
are considered a higher risk for handling refresh tokens.</t>

<t><xref target="oauth-security-topics"/> describes some additional requirements around refresh tokens 
on top of the recommendations of <xref target="RFC6749"/>. Applications and authorization servers 
conforming to this BCP MUST also follow the recommendations in <xref target="oauth-security-topics"/> 
around refresh tokens.</t>

<t>In particular, authorization servers:</t>

<t><list style="symbols">
  <t>MUST rotate refresh tokens on each use, in order to be able to detect a stolen refresh token if one is replayed (described in <xref target="oauth-security-topics"/> section 4.12)</t>
  <t>MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time</t>
  <t>upon issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token if the refresh token has a preestablished expiration time</t>
</list></t>

<t>For example:</t>

<t><list style="symbols">
  <t>A user authorizes an application, issuing an access token that lasts 1 hour, and a refresh token that lasts 24 hours</t>
  <t>After 1 hour, the initial access token expires, so the application uses the refresh token to get a new access token</t>
  <t>The authorization server returns a new access token that lasts 1 hour, and a new refresh token that lasts 23 hours</t>
  <t>This continues until 24 hours pass from the initial authorization</t>
  <t>At this point, when the application attempts to use the refresh token after 24 hours, the request will fail and the application will have to involve the user in a new authorization request</t>
</list></t>

<t>By limiting the overall refresh token lifetime to the lifetime of the initial refresh token, this ensures a stolen refresh token cannot be used indefinitely.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured. Even when the user has previously approved an
authorization request for a given client_id, the request SHOULD be
processed as if no previous request had been approved, unless the identity of
the client can be proven.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs without wildcard domains, paths, or query string components, this exact
match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Section 5.3.5 of <xref target="RFC6819"/> recommends using the "state" parameter to
link client requests and responses to prevent CSRF (Cross-Site Request Forgery)
attacks. To conform to this best practice, use of the "state" parameter is
REQUIRED, as described in <xref target="auth_code_request"/>, unless the application has
a method of ensuring the authorization server supports PKCE, since PKCE also
prevents CSRF attacks.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>The security considerations around the authorization server mix-up that
are referenced in Section 8.10 of <xref target="RFC8252"/> also apply to browser-based apps.</t>

<t>Clients MUST use a unique redirect URI for each authorization server used by the
application. The client MUST store the redirect URI along with the session data
(e.g. along with "state") and MUST verify that the URI on which the authorization
response was received exactly matches.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the authorization code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing.</t>

</section>
<section anchor="csp" title="Content-Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Grant Authorization Flow">

<t>The OAuth 2.0 Implicit grant authorization flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by receiving an access token in the HTTP redirect
(front-channel) immediately without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token. Several attacks
on the implicit flow are described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
not all of which have sufficient mitigation strategies.</t>

<section anchor="threat-interception-of-the-redirect-uri" title="Threat: Interception of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
his control, he will directly get access to the fragment carrying the access token.
A method of performing this attack is described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

<t>This is discussed in more detail in Section 4.3.2 of <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser via various
means, including when the browser's HTTPS connection is being man-in-the-middled
by for example a corporate network. While this type of attack is typically out of
scope of basic security recommendations to prevent, in the case of browser-based
apps it is much easier to perform this kind of attack, where an injected script
can suddenly have access to everything on the page.</t>

<t>The risk of a malicious script running on the page is far greater when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the window.location to find an access token. This threat profile is
very different compared to an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the authorization code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the authorization code with PKCE avoids these attacks.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that an access token was
issued to it, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front channel redirect gives the authorization
server no assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the authorization code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the authorization code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally
signed. Returning an id_token using the Implicit flow (response_type=id_token) requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent id_tokens. Performing OpenID Connect using the authorization code flow provides
the benefit of the client not needing to verify the JWT signature, as the ID token will 
have been fetched over an HTTPS connection directly from the authorization server. Additionally,
in many cases an application will request both an ID token and an access token, so it is
simplier and provides fewer attack vectors to obtain both via the authorization code flow.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to single-page apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. This was necessary in order to remove the
access token from the URL after it was obtained by the app.</t>

<t>Modern browsers now have the Session History API (described in "Session history and
navigation" of <xref target="HTML"/>), which provides a mechanism to modify the path and query string
component of the URL without triggering a page reload. This means modern browser-based apps can
use the unmodified OAuth 2.0 authorization code flow, since they have the ability to
remove the authorization code from the query string without triggering a page reload
thanks to the Session History API.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization>Google, Inc</organization>
    </author>
    <author initials="D." surname="Veditz" fullname="Dan Veditz">
      <organization>Mozilla Corporation</organization>
    </author>
    <date year="2016" month="December"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2019" month="July"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth authorization servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching of registered redirect URIs.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
  <t>Not support the Resource Owner Password grant for browser-based clients.</t>
  <t>Follow the <xref target="oauth-security-topics"/> recommendations on refresh tokens, as well
as the additional requirements described in <xref target="refresh_tokens"/>.</t>
</list></t>

</section>
<section anchor="document-history" title="Document History">

<t>[[ To be removed from the final specification ]]</t>

<t>-04</t>

<t><list style="symbols">
  <t>Disallow the use of the Password Grant</t>
  <t>Add PKCE support to summary list for authorization server requirements</t>
  <t>Rewrote refresh token section to allow refresh tokens if they are time-limited, rotated on each use, and requiring that the rotated refresh token lifetimes do not extend past the lifetime of the initial refresh token, and to bring it in line with the Security BCP</t>
  <t>Updated recommendations on using state to reflect the Security BCP</t>
  <t>Updated server support checklist to reflect latest changes</t>
  <t>Updated the same-domain JS architecture section to emphasize the architecture rather than domain</t>
  <t>Editorial clarifications in the section that talks about OpenID Connect ID tokens</t>
</list></t>

<t>-03</t>

<t><list style="symbols">
  <t>Updated the historic note about the fragment URL clarifying that the Session History API means browsers can use the unmodified authorization code flow</t>
  <t>Rephrased "Authorization Code Flow" intro paragraph to better lead into the next two sections</t>
  <t>Softened "is likely a better decision to avoid using OAuth entirely" to "it may be&#8230;" for common-domain deployments</t>
  <t>Updated abstract to not be limited to public clients, since the later sections talk about confidential clients</t>
  <t>Removed references to avoiding OpenID Connect for same-domain architectures</t>
  <t>Updated headers to better describe architectures (Apps Served from a Static Web Server -&gt; JavaScript Applications without a Backend)</t>
  <t>Expanded "same-domain architecture" section to better explain the problems that OAuth has in this scenario</t>
  <t>Referenced Security BCP in implicit flow attacks where possible</t>
  <t>Minor typo corrections</t>
</list></t>

<t>-02</t>

<t><list style="symbols">
  <t>Rewrote overview section incorporating feedback from Leo Tohill</t>
  <t>Updated summary recommendation bullet points to split out application and server requirements</t>
  <t>Removed the allowance on hostname-only redirect URI matching, now requiring exact redirect URI matching</t>
  <t>Updated section 6.2 to drop reference of SPA with a backend component being a public client</t>
  <t>Expanded the architecture section to explicitly mention three architectural patterns available to JS apps</t>
</list></t>

<t>-01</t>

<t><list style="symbols">
  <t>Incorporated feedback from Torsten Lodderstedt</t>
  <t>Updated abstract</t>
  <t>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</t>
  <t>Clarified use of the state parameter for CSRF protection</t>
  <t>Added background information about the original reason the implicit flow was created due to lack of CORS support</t>
  <t>Clarified the same-domain use case where the SPA and API share a cookie domain</t>
  <t>Moved historic note about the fragment URL into the Overview</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, Janak Amarasena, John Bradley, Joseph Heenan,
Justin Richer, Karl McGuinness, Leo Tohill, Tomek Stojecki, Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIABUUh10AA709bXPbRnrf91fsKB8i90iereRyObfXqSw5sXJ2rEpyPTed
qwcEliJOIMBiAdE8x/+9z9u+gYCsNJ16ElsigcXu8/6O+XyuurKrzHP99rTv
1vpk8VSvmla/aJudNe38RWZNoU+3W6uKJq+zDVxZtNmqm5emW82bDG6aL+Xi
JV48z+Di+dNvVZF1cPHJ02d/mj/90/zkRKly2z7XXdvb7uTp0z89PVFZazJ5
srrbPdcXdWfa2nTzc3yEyrPuuV7mW6Xypijr2+e6t/PM5mWptuVzpXXX5M/1
3lj40TZt15qV9b/vN+FXhdtsWrxlDv9rXdbwzelCX8IO8ruSPuPDnWZtUyef
Ny08+O1dl9FvZpOV1XOd4WX/tuXLFnmzoS/7tnyu1123tc9//3u6JL0ievj5
Qr/Pys5Ejz7P7ssi+pQefAnn1heFqQFN+3gHBV79b1l1l1Vlbea2qfqubGpL
j1J1026yrrw3eOarH85Onj37k/z43R+/9T9+7z/943fffCc/fn/yhxP88ez6
kv4FODOJnDWAn7rT1yaHk3Z7fdlUZc67ChCGY8qB3pR3Rr83tqNP5eBvFvFH
dMYfm+a2MjNAf57cf1pkG/0ia4E6ogUAbfFnD65wntX6P0xRdv+IVwDYJx/S
Em+af5RVlcEh223TZghL+prJ+NzkZrM0LdLzd/D5D6bL1wlw6JMDUDjc7tZZ
t7uNNxF94jnle/iVWcoKiOddsy1zmzwpcKpHxAuAqD7r2xbRc9lmeVfmZhIv
N01rAZH6dVMUBn8sEgzdLEa+IRgBL3lad4v91KxrEBdZUZl9vMpPi8GntMJf
+2WZNymW66I1e/06W/bA+naA6sHHtMgPWW6WTXM3RHVpKkRDN8B19NHBKRj0
P/XVniQVyKh6FbPOq5s3rxPg4we/GctqPp/rbGk7xJRSN+vSars1ebkqc6I8
XZgOuNzqbm20owWdA3uXgBe6xOqsLvQSEb8VhOPlWac3IGDhC9Vld4Dksu4a
neV50wNp7NYG1743FZAVCJZEcmuQ3JVsQJbqrQnktuB9b8oCsKoUCOu2Kfqc
9vvpqzL69bP6c/Rn4oA2b8ul4SPmQrqD46AmKjfbymxQ/sF+/V5Eopf/4NVW
FZwDjpoeoe3rGu/Cm1sDKMYL3JnhND/A8jWhOr7PwQfoH86fPJVA/nZr6otz
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
gByDAAA=

-->

</rfc>

