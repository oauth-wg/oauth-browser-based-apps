<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.9 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-00" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2019" month="January" day="29"/>

    <area>Security Area</area>
    <workgroup>Open Authentication Protocol</workgroup>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>OAuth 2.0 authorization requests from apps running entirely in a browser are unable
to use a Client Secret during the process, since they have no way to keep a secret
confidential. This specification details the security considerations that must be
taken into account when developing browser-based applications, as well as best
practices for how they can securely implement OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications running entirely in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices.</t>

<t>AppAuth steers developers away from performing user authorization via embedding user
agents such as browser controls into native apps, instead insisting that an external
agent (such as the system browser) be used. The RFC continues on to promote
capabilities and supplemental specifications beyond the base OAuth 2.0 and
OpenID Connect specifications to improve baseline security, such as <xref target="RFC7636"/>,
also known as PKCE.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps as well as browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText='&quot;OAuth&quot;:'>
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/>.</t>
  <t hangText='&quot;Browser-based application&quot;:'>
  An application that runs entirely in a web browser, usually written in
JavaScript, where the source code is downloaded from a domain prior to execution.
Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>For authorizing users within a browser-based application, the best current practice is to</t>

<t><list style="symbols">
  <t>Use the OAuth 2.0 authorization code flow with the PKCE extension</t>
  <t>Require the OAuth 2.0 state parameter</t>
  <t>Recommend exact matching of redirect URIs, and require the hostname of the redirect URI match the hostname of the URL the app was served from</t>
  <t>Do not return access tokens in the front channel</t>
</list></t>

<t>Previously it was recommended that browser-based applications use the OAuth 2.0 Implicit
flow. That approach has several drawbacks, including the fact that access tokens are
returned in the front-channel via the fragment part of the redirect URI, and as such
are vulnerable to a variety of attacks where the access token can be intercepted or
stolen. See <xref target="implicit_flow"/> for a deeper analysis of these attacks and the drawbacks
of using the Implicit flow in browsers, many of which are described by <xref target="oauth-security-topics"/>.</t>

<t>Instead, browser-based apps can perform the OAuth 2.0 authorization code flow
and make a POST request to the token endpoint to exchange an authorization code
for an access token, just like other OAuth clients. This ensures that access tokens
are not sent via the less secure front-channel, and are only returned over an HTTPS
connection initiated from the application. Combined with PKCE, this enables the
authorization server to ensure that authorization codes are useless even if
intercepted in transport.</t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth and OpenID Connect were initially created to allow third-party
applications to access an API on behalf of a user, they have both proven to be
useful in a first-party scenario as well. First-party apps are applications created
by the same organization that provides the API being accessed by the application.</t>

<t>For example, a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use an OAuth Authorization Code flow as described later in this
document or use the OAuth Password grant.</t>

<t>It is strongly RECOMMENDED that applications use the Authorization Code flow over
the Password grant for several reasons. By redirecting to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single-sign-on sessions,
or use third-party identity providers. In contrast, the Password grant does not
provide any built-in mechanism for these, and must be extended with custom code.</t>

</section>
<section anchor="architectural-considerations" title="Architectural Considerations">

<t>In some cases, it may make sense to avoid the use of a strictly browser-based OAuth
application entirely, instead using an architecture that can provide better security.</t>

<section anchor="apps-served-from-the-same-domain-as-the-api" title="Apps Served from the Same Domain as the API">

<t>For simple system architectures, such as when the JavaScript application is served
from the same domain as the API (resource server) being accessed, it is likely a
better decision to avoid using OAuth entirely, and just use session authentication
to communicate with the API.</t>

<t>OAuth and OpenID Connect provide very little benefit in this deployment scenario,
so it is recommended to reconsider whether you need OAuth or OpenID Connect at all
in this case. Session authentication has the benefit of having fewer moving parts
and fewer attack vectors. OAuth and OpenID Connect were created primarily for
third-party or federated access to APIs, so may not be the best solution in a
same-domain scenario.</t>

</section>
<section anchor="browser-based-app-with-a-backend-component" title="Browser-Based App with a Backend Component">

<t>To avoid the risks inherent in handling OAuth access tokens from a purely browser-based
application, implementations may wish to move the authorization code exchange and
handling of access and refresh tokens into a backend component.</t>

<t>The backend component essentially becomes a new authorization server for the code
running in the browser, issuing its own tokens (e.g. a session cookie). Security of
the connection between code running in the browser and this backend component is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found at the OWASP Foundation (https://www.owasp.org/).</t>

<t>In this scenario, the backend component may be a confidential client which is issued
its own client secret. Despite this, there are still some ways in which this application
is effectively a public client, as the end result is the application's code is still
running in the browser and visible to the user. Some authorization servers may have
different policies for public and confidential clients, and this type of hybrid
approach does not provide all the assurances of confidential clients that an
authorization server is expecting. Authorization servers may wish to treat this type
of deployment as a public client.</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Public browser-based apps needing user authorization create an authorization
request URI with the authorization code grant type per Section 4.1 of
OAuth 2.0 <xref target="RFC6749"/>, using a redirect URI capable of being received by the app.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Public browser-based apps MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension to OAuth, and authorization servers MUST support
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the same client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based apps MUST use the OAuth 2.0 "state" parameter to protect themselves
against Cross-Site Request Forgery and authorization code swap attacks and MUST use
a unique value for each authorization request, and MUST verify the returned state
in the authorization response matches the original state the app created.</t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers SHOULD require an exact match of a registered redirect URI.</t>

<t>If an authorization server wishes to provide some flexibility in redirect URI usage
to clients, it MAY require that only the hostname component of the redirect URI match
the hostname of the URL the application is served from.</t>

<t>Authorization servers MUST support one of the two redirect URI validation mechanisms
as described above.</t>

</section>
</section>
<section anchor="refresh-tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. <xref target="oauth-security-topics"/> describes some additional
requirements around refresh tokens on top of the recommendations of <xref target="RFC6749"/>.</t>

<t>For public clients, the risk of a leaked refresh token is much greater than leaked
access tokens, since an attacker can potentially continue using the stoken refresh
token to obtain new access without being detectable by the authorization server.
Additionally, browser-based applications provide many attack vectors by which a
refresh token can be leaked. As such, these applications are considered a higher risk
for handling refresh tokens.</t>

<t>Authorization servers SHOULD NOT issue refresh tokens to browser-based applications.</t>

<t>If an authorization server does choose to issue refresh tokens to browser-based
applications, then it MUST issue a new refresh token with every access token refresh
response. Doing this mitigates the risk of a leaked refresh token, as a
leaked refresh token can be detected if both the attacker and the legitimate client
attempt to use the same refresh token. Authorization servers MUST follow the
additional refresh token replay mitigation techniques described in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured. Even when the user has previously approved an
authorization request for a given client_id, the request SHOULD be
processed as if no previous request had been approved, unless the identity of
the client can be proven.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs without wildcard domains, paths, or query string components, this exact
match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Section 5.3.5 of <xref target="RFC6819"/> recommends using the "state" parameter to
link client requests and responses to prevent CSRF (Cross-Site Request Forgery)
attacks. To conform to this best practice, use of the "state" parameter is
REQUIRED, as described in <xref target="auth_code_request"/>.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>The security considerations around the authorization server mix-up that
are referenced in Section 8.10 of <xref target="RFC8252"/> also apply to browser-based apps.</t>

<t>Clients MUST use a unique redirect URI for each authorization server used by the
application. The client MUST store the redirect URI along with the session data
(e.g. along with "state") and MUST verify that the URI on which the authorization
response was received exactly matches.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the authorization code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing. If POSTs in particular from
unsupported single-page applications are to be rejected as errors per authorization
server security policy, such rejection is typically done based on the Origin
request header.</t>

</section>
<section anchor="csp" title="Content-Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Grant Authorization Flow">

<t>The OAuth 2.0 Implicit grant authorization flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by receiving an access token in the HTTP redirect
(front-channel) immediately without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token. Several attacks
on the implicit flow are described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
not all of which have sufficient mitigation strategies.</t>

<section anchor="threat-interception-of-the-redirect-uri" title="Threat: Interception of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
his control, he will directly get access to the fragment carrying the access token.
A method of performing this attack is described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser via various
means, including when the browser's HTTPS connection is being man-in-the-middled
by for example a corporate network. While this type of attack is typically out of
scope of basic security recommendations to prevent, in the case of browser-based
apps it is much easier to perform this kind of attack, where an injected script
can suddenly have access to everything on the page.</t>

<t>The risk of a malicious script running on the page is far greater when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the window.location to find an access token. This threat profile is
very different compared to an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the authorization code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the authorization code with PKCE avoids these attacks.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that an access token was
issued to it, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front channel redirect gives the authorization
server little assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the authorization code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the authorization code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the id_token is sent in a known format (as a JWT), and digitally
signed. Performing OpenID Connect using the authorization code flow also provides
the additional benefit of the client not needing to verify the JWT signature, as the
token will have been fetched over an HTTPS connection directly from the authorization
server. However, returning an id_token using the Implicit flow requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent id_tokens.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to single-page apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. Now with the Session History API (described in
"Session history and navigation" of <xref target="HTML"/>), browsers have a mechanism to modify
the path component of the URL without triggering a page reload, so this overloaded
use of the fragment portion is no longer needed.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization>Google, Inc</organization>
    </author>
    <author initials="D." surname="Veditz" fullname="Dan Veditz">
      <organization>Mozilla Corporation</organization>
    </author>
    <date year="2016" month="December"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2018" month="November"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author>
      <organization>whatwg</organization>
    </author>
    <date year="2018"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching on redirect URIs or matching the hostname the application
is served from.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, John Bradley, Joseph Heenan, Justin Richer,
Karl McGuinness, Tomek Stojecki, Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIACPiUFwAA6Vc63PbuLX/jr8C4/2wSUdSE7e73XXnztRxko23efjaTjP9
lIFISMKaIngJ0oo2k//9ngcAAhTlde/daScWHyBwcB6/88J8Phed6Sp9Jj+c
991Gni6eyZVt5YvW7pxu5y+U06U8bxonSlvUagtPlq1adXOju9XcKnhpvvQP
L/HhuYKH58+eiVJ18PDps+c/z589n5/+LIRp2jPZtb3rTp89+/nZqVCtVv7L
4m53Ji/rTre17uYv8ROiUN2ZXBaNEIUtTb0+k72bK1cYIxpzJqTsbHEm99rB
n862XatXLv7eb4efAqdpW3xlDv+X0tRw53whr2AGxZ2ha7y4c9XaOrtuW/jw
h7tO0S+9VaY6kwof+0fDjy0Ku6WbfWvO5KbrGnf25z/TI/kTycdfLuQnZTqd
fPqlujdlcpU+fAXrlpelrmGb9ukMSnz6H6q6U5Wp9dzZqu+MrR19StS23arO
3Gtc8/Xri9Pnz3/2f/74t7/GP3+KV//2419+9H/+dPrDKf55cXNF/wKdmUUu
LOxP3ckbXcBKu728spUpeFYDhWGZfkHvzJ2Wn7Tr6Kpf+LtFeonW+Iu160rP
YPuL7P3zUm3lC9UCdyQDwLal1x4c4aWq5b90abrf0xGA9tlFGuKd/d1UlYJF
to1tFdKSbjMbv9SF3i51i/z8I1x/rbtikxGHrhyQIuztbqO63TqdRHIlSspP
8JNFynkSzzvbmMJlXxokNW7EC6CovOjbFrfnqlVFZwp9dF9ubetgI+VbW5Ya
/yyzHbpdTNwhGoEsRV4Pg/1qNzWoC1VWep+O8utidJVG+He/NIXNd7kuW72X
b9WyB9F3o60eXaZBXqtCL629G2+10RVuQzfa6+TSwSqY9O/tfdzdn0BP1atU
fN7cvnubbQBe+H/vtJjP51ItXYe7JcSwqTyo+Z1YULb6f3rYXCdXrd1K1K2y
7esatQLqhFZXe/iKVNIrYQkKR/a1WlZadBYUpoZ7F5XxctvqTpbAM/B6t9Gy
aW2hnZtJZ+pC46W93Kh7LWsrd2oPClbead3AEI7eBUVcrwxpI1Ut5O3GOOka
XZiVKXi+pe5APTkaPTCxhLccvMVShfdUJ7dgBuQSJqnugBVNDZ9SRWF7mOdu
o3Gge10B88NMM/uCNKj812Diysmdrir8d4lqpfHM78iMbeyOF1WAIqDpEL22
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

-->

</rfc>

