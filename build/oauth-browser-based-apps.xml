<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.4.3 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6749 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7636 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml">
<!ENTITY RFC8252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-browser-based-apps-09" category="bcp">

  <front>
    <title>OAuth 2.0 for Browser-Based Apps</title>

    <author initials="A." surname="Parecki" fullname="Aaron Parecki">
      <organization>Okta</organization>
      <address>
        <email>aaron@parecki.com</email>
        <uri>https://aaronparecki.com</uri>
      </address>
    </author>
    <author initials="D." surname="Waite" fullname="David Waite">
      <organization>Ping Identity</organization>
      <address>
        <email>david@alkaline-solutions.com</email>
      </address>
    </author>

    <date year="2022" month="March" day="07"/>

    <area>Security</area>
    <workgroup>Web Authorization Protocol</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification details the security considerations and best practices that must be
taken into account when developing browser-based applications that use OAuth 2.0.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This specification describes the current best practices for implementing OAuth 2.0
authorization flows in applications executing in a browser.</t>

<t>For native application developers using OAuth 2.0 and OpenID Connect, an IETF BCP
(best current practice) was published that guides integration of these technologies.
This document is formally known as <xref target="RFC8252"/> or BCP 212, but nicknamed "AppAuth" after
the OpenID Foundation-sponsored set of libraries that assist developers in adopting
these practices. <xref target="RFC8252"/> makes specific recommendations for how to securely implement OAuth in native
applications, including incorporating additional OAuth extensions where needed.</t>

<t>OAuth 2.0 for Browser-Based Apps addresses the similarities between implementing
OAuth for native apps and browser-based apps, and includes additional
considerations when running in a browser. This is primarily focused on OAuth,
except where OpenID Connect provides additional considerations.</t>

<t>Many of these recommendations are derived from the OAuth 2.0 Security Best Current Practice
<xref target="oauth-security-topics"/> and browser-based apps are expected to follow those recommendations
as well. This draft expands on and further restricts various recommendations in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>In addition to the terms defined in referenced specifications, this document uses
the following terms:</t>

<t><list style="hanging">
  <t hangText="&quot;OAuth&quot;:">
  In this document, "OAuth" refers to OAuth 2.0, <xref target="RFC6749"/> and <xref target="RFC6750"/>.</t>
  <t hangText="&quot;Browser-based application&quot;:">
  An application that is dynamically downloaded and executed in a web browser,
usually written in JavaScript. Also sometimes referred to as a "single-page application", or "SPA".</t>
</list></t>

</section>
<section anchor="overview" title="Overview">

<t>At the time that OAuth 2.0 <xref target="RFC6749"/> and <xref target="RFC6750"/> were created, browser-based JavaScript applications needed a solution that strictly complied with the same-origin policy. Common deployments of OAuth 2.0 involved an application running on a different domain than the authorization server, so it was historically not possible to use the Authorization Code flow which would require a cross-origin POST request. This was one of the motivations for the definition of the Implicit flow, which returns the access token in the front channel via the fragment part of the URL, bypassing the need for a cross-origin POST request.</t>

<t>However, there are several drawbacks to the Implicit flow, generally involving vulnerabilities associated with the exposure of the access token in the URL. See <xref target="implicit_flow"/> for an analysis of these attacks and the drawbacks of using the Implicit flow in browsers. Additional attacks and security considerations can be found in <xref target="oauth-security-topics"/>.</t>

<t>In recent years, widespread adoption of Cross-Origin Resource Sharing (CORS), which enables exceptions to the same-origin policy, allows browser-based apps to use the OAuth 2.0 Authorization Code flow and make a POST request to exchange the authorization code for an access token at the token endpoint. In this flow, the access token is never exposed in the less secure front channel. Furthermore, adding PKCE to the flow ensures that even if an authorization code is intercepted, it is unusable by an attacker.</t>

<t>For this reason, and from other lessons learned, the current best practice for browser-based applications is to use the OAuth 2.0 Authorization Code flow with PKCE.</t>

<t>Browser-based applications:</t>

<t><list style="symbols">
  <t>MUST use the OAuth 2.0 Authorization Code flow with the PKCE extension when obtaining an access token</t>
  <t>MUST Protect themselves against CSRF attacks by either:
  <list style="symbols">
      <t>ensuring the authorization server supports PKCE, or</t>
      <t>by using the OAuth 2.0 "state" parameter or the OpenID Connect "nonce" parameter to carry one-time use CSRF tokens</t>
    </list></t>
  <t>MUST Register one or more redirect URIs, and use only exact registered redirect URIs in authorization requests</t>
</list></t>

<t>OAuth 2.0 authorization servers supporting browser-based applications:</t>

<t><list style="symbols">
  <t>MUST Require exact matching of registered redirect URIs</t>
  <t>MUST Support the PKCE extension</t>
  <t>MUST NOT issue access tokens in the authorization response</t>
  <t>If issuing refresh tokens to browser-based applications, then:
  <list style="symbols">
      <t>MUST rotate refresh tokens on each use or use sender-constrained refresh tokens, and</t>
      <t>MUST set a maximum lifetime on refresh tokens or expire if they are not used in some amount of time</t>
    </list></t>
</list></t>

</section>
<section anchor="first-party-applications" title="First-Party Applications">

<t>While OAuth was initially created to allow third-party
applications to access an API on behalf of a user, it has proven to be
useful in a first-party scenario as well. First-party apps are applications where
the same organization provides both the API and the application.</t>

<t>Examples of first-party applications are a web email client provided by the operator of the email account,
or a mobile banking application created by bank itself. (Note that there is no
requirement that the application actually be developed by the same company; a mobile
banking application developed by a contractor that is branded as the bank's
application is still considered a first-party application.) The first-party app
consideration is about the user's relationship to the application and the service.</t>

<t>To conform to this best practice, first-party applications using OAuth or OpenID
Connect MUST use a redirect-based flow (such as the OAuth Authorization Code flow)
as described later in this document.</t>

<t>The resource owner password credentials grant MUST NOT be used, as described in
<xref target="oauth-security-topics"/> Section 2.4. Instead, by using the Authorization Code flow
and redirecting the user to the authorization server,
this provides the authorization server the opportunity to prompt the user for
multi-factor authentication options, take advantage of single sign-on sessions,
or use third-party identity providers. In contrast, the resource owner password credentials grant does not
provide any built-in mechanism for these, and would instead be extended with custom code.</t>

</section>
<section anchor="application-architecture-patterns" title="Application Architecture Patterns">

<t>There are three primary architectural patterns available when building browser-based
applications.</t>

<t><list style="symbols">
  <t>a JavaScript application that has methods of sharing data with resource servers, such as using common-domain cookies</t>
  <t>a JavaScript application with a backend component</t>
  <t>a JavaScript application with no backend, accessing resource servers directly</t>
</list></t>

<t>These three architectures have different use cases and considerations.</t>

<section anchor="browser-based-apps-that-can-share-data-with-the-resource-server" title="Browser-Based Apps that Can Share Data with the Resource Server">

<t>For simple system architectures, such as when the JavaScript application is served
from a domain that can share cookies with the domain of the API (resource server),
OAuth adds additional attack vectors that could be avoided with a different solution.</t>

<t>In particular, using any redirect-based mechanism of obtaining an access token
enables the redirect-based attacks described in <xref target="oauth-security-topics"/> Section 4, but if
the application, authorization server and resource server share a domain, then it is
unnecessary to use a redirect mechanism to communicate between them.</t>

<t>An additional concern with handling access tokens in a browser is that as of the date of this publication, there is no
secure storage mechanism where JavaScript code can keep the access token to be later
used in an API request. Using an OAuth flow results in the JavaScript code getting an
access token, needing to store it somewhere, and then retrieve it to make an API request.</t>

<t>Instead, a more secure design is to use an HTTP-only cookie between the JavaScript application
and API so that the JavaScript code can't access the cookie value itself. The <spanx style="verb">Secure</spanx> cookie attribute should be used to ensure the cookie is not included in unencrypted HTTP requests. Additionally, the <spanx style="verb">SameSite</spanx> cookie attribute can be used to counter CSRF attacks,
but should not be considered the extent of the CSRF protection, as described in <xref target="draft-ietf-httpbis-rfc6265bis"/></t>

<t>OAuth was originally created for third-party or federated access to APIs, so it may not be
the best solution in a common-domain deployment. That said, there are still some advantages
in using OAuth even in a common-domain architecture:</t>

<t><list style="symbols">
  <t>Allows more flexibility in the future, such as if you were to later add a new domain to the system. With OAuth already in place, adding a new domain wouldn't require any additional rearchitecting.</t>
  <t>Being able to take advantage of existing library support rather than writing bespoke code for the integration.</t>
  <t>Centralizing login and multifactor support, account management, and recovery at the OAuth server, rather than making it part of the application logic.</t>
</list></t>

<t>Using OAuth for browser-based apps in a first-party same-domain scenario provides these advantages, and can be accomplished by either of the two architectural patterns described below.</t>

</section>
<section anchor="javascript-applications-with-a-backend" title="JavaScript Applications with a Backend">

<figure><artwork><![CDATA[
+-------------+  +--------------+ +---------------+
|             |  |              | |               |
|Authorization|  |    Token     | |   Resource    |
|  Endpoint   |  |   Endpoint   | |    Server     |
|             |  |              | |               |
+-------------+  +--------------+ +---------------+

       ^                ^                   ^
       |             (D)|                (G)|
       |                v                   v
       |
       |         +--------------------------------+
       |         |                                |
       |         |          Application           |
    (B)|         |            Server              |
       |         |                                |
       |         +--------------------------------+
       |
       |           ^     ^     +          ^    +
       |        (A)|  (C)|  (E)|       (F)|    |(H)
       v           v     +     v          +    v

+-------------------------------------------------+
|                                                 |
|                   Browser                       |
|                                                 |
+-------------------------------------------------+
]]></artwork></figure>

<t>In this architecture, commonly referred to as "backend for frontend" or "BFF", the JavaScript code is loaded from a dynamic Application Server (A) that also has the ability to execute code itself. This enables the ability to keep
all of the steps involved in obtaining an access token outside of the JavaScript
application.</t>

<t>Note that this application backend is not the Resource Server, it is still considered part of the OAuth client and would be accessing data at a separate resource server.</t>

<t>In this case, the Application Server initiates the OAuth flow itself, by redirecting the browser to the authorization endpoint (B). When the user is redirected back, the browser delivers the authorization code to the application server (C), where it can then exchange it for an access token at the token endpoint (D) using its client secret. The application server then keeps the access token and refresh token stored internally, and creates a separate session with the browser-based app via a
traditional browser cookie (E).</t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it instead makes the request to the Application Server (F), and the Application Server will
make the request with the access token to the Resource Server (G), and forward the response (H)
back to the browser.</t>

<t>(Common examples of this architecture are an Angular front-end with a .NET backend, or
a React front-end with a Spring Boot backend.)</t>

<t>The Application Server SHOULD be considered a confidential client, and issued its own client secret. The Application Server SHOULD use the OAuth 2.0 Authorization Code grant with PKCE to initiate a request for an access token. Detailed recommendations for confidential clients can be found in <xref target="oauth-security-topics"/> Section 2.1.1.</t>

<t>In this scenario, the connection between the browser and Application Server SHOULD be a
session cookie provided by the Application Server.</t>

<t>Security of the connection between code running in the browser and this Application Server is
assumed to utilize browser-level protection mechanisms. Details are out of scope of
this document, but many recommendations can be found in the OWASP Cheat Sheet series (https://cheatsheetseries.owasp.org/),
such as setting an HTTP-only and <spanx style="verb">Secure</spanx> cookie to authenticate the session between the
browser and Application Server.</t>

<!--
TODO: security considerations around things like Server Side Request Forgery or logging the cookies

TODO: Add another description of the alternative architecture where access tokens are passed to JS and the JS app makes API calls directly. https://mailarchive.ietf.org/arch/msg/oauth/sl-g6zYSpJW3sYqrR0peadUw54U/
-->

</section>
<section anchor="javascript-applications-without-a-backend" title="JavaScript Applications without a Backend">

<figure><artwork><![CDATA[
                      +---------------+           +--------------+
                      |               |           |              |
                      | Authorization |           |   Resource   |
                      |    Server     |           |    Server    |
                      |               |           |              |
                      +---------------+           +--------------+

                             ^     ^                 ^     +
                             |     |                 |     |
                             |(B)  |(C)              |(D)  |(E)
                             |     |                 |     |
                             |     |                 |     |
                             +     v                 +     v

+-----------------+         +-------------------------------+
|                 |   (A)   |                               |
| Static Web Host | +-----> |           Browser             |
|                 |         |                               |
+-----------------+         +-------------------------------+
]]></artwork></figure>

<t>In this architecture, the JavaScript code is first loaded from a static web host into
the browser (A), and the application then runs in the browser. This application is considered a public
client, since there is no way to issue it a client secret and there is no other secure
client authentication mechanism available in the browser.</t>

<t>The code in the browser initiates the Authorization Code flow with the PKCE
extension (described in <xref target="authorization_code_flow"/>) (B) above, and obtains an
access token via a POST request (C). The JavaScript application is then responsible for storing
the access token (and optional refresh token) as securely as possible using appropriate browser APIs.
As of the date of this publication there is no browser API that allows to store tokens in a completely
secure way.
<!--
TODO: Add sentence referencing the section about service worker pattern in a future draft?
--></t>

<t>When the JavaScript application in the browser wants to make a request to the Resource Server,
it can interact with the Resource Server directly. It includes the access token in the request (D)
and receives the Resource Server's response (E).</t>

<t>In this scenario, the Authorization Server and Resource Server MUST support
the necessary CORS headers to enable the JavaScript code to make this POST request
from the domain on which the script is executing. (See <xref target="cors"/> for additional details.)</t>

</section>
</section>
<section anchor="authorization_code_flow" title="Authorization Code Flow">

<t>Browser-based applications that are public clients and use the Authorization Code grant type described in
Section 4.1 of OAuth 2.0 <xref target="RFC6749"/> MUST also follow these additional requirements
described in this section.</t>

<section anchor="auth_code_request" title="Initiating the Authorization Request from a Browser-Based Application">

<t>Browser-based applications that are public clients MUST implement the Proof Key for Code Exchange
(PKCE <xref target="RFC7636"/>) extension when obtaining an access token, and authorization servers MUST support and enforce
PKCE for such clients.</t>

<t>The PKCE extension prevents an attack where the authorization code is intercepted
and exchanged for an access token by a malicious client, by providing the
authorization server with a way to verify the client instance that exchanges
the authorization code is the same one that initiated the flow.</t>

<t>Browser-based applications MUST prevent CSRF attacks against their redirect URI. This can be
accomplished by any of the below:</t>

<t><list style="symbols">
  <t>using PKCE, and confirming that the authorization server supports PKCE</t>
  <t>using a unique value for the OAuth 2.0 "state" parameter</t>
  <t>if the application is using OpenID Connect, by using the OpenID Connect "nonce" parameter</t>
</list></t>

</section>
<section anchor="auth_code_redirect" title="Handling the Authorization Code Redirect">

<t>Authorization servers MUST require an exact match of a registered redirect URI.
As described in <xref target="oauth-security-topics"/> Section 4.1.1. this helps to prevent attacks targeting the authorization code.</t>

</section>
</section>
<section anchor="refresh_tokens" title="Refresh Tokens">

<t>Refresh tokens provide a way for applications to obtain a new access token when the
initial access token expires. With public clients, the risk of a leaked refresh token
is greater than leaked access tokens, since an attacker may be able to
continue using the stolen refresh token to obtain new access tokens potentially without being
detectable by the authorization server.</t>

<t>Browser-based applications provide an attacker with several opportunities by which a
refresh token can be leaked, just as with access tokens. As such, these applications
are considered a higher risk for handling refresh tokens.</t>

<t>Authorization servers may choose whether or not to issue refresh tokens to browser-based
applications. <xref target="oauth-security-topics"/> describes some additional requirements around refresh tokens
on top of the recommendations of <xref target="RFC6749"/>. Applications and authorization servers
conforming to this BCP MUST also follow the recommendations in <xref target="oauth-security-topics"/>
around refresh tokens if refresh tokens are issued to browser-based applications.</t>

<t>In particular, authorization servers:</t>

<t><list style="symbols">
  <t>MUST either rotate refresh tokens on each use OR use sender-constrained refresh tokens as described in <xref target="oauth-security-topics"/> Section 4.13.2</t>
  <t>MUST either set a maximum lifetime on refresh tokens OR expire if the refresh token has not been used within some amount of time</t>
  <t>MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token</t>
  <t>upon issuing a rotated refresh token, MUST NOT extend the lifetime of the new refresh token beyond the lifetime of the initial refresh token if the refresh token has a preestablished expiration time</t>
</list></t>

<t>For example:</t>

<t><list style="symbols">
  <t>A user authorizes an application, issuing an access token that lasts 1 hour, and a refresh token that lasts 24 hours</t>
  <t>After 1 hour, the initial access token expires, so the application uses the refresh token to get a new access token</t>
  <t>The authorization server returns a new access token that lasts 1 hour, and a new refresh token that lasts 23 hours</t>
  <t>This continues until 24 hours pass from the initial authorization</t>
  <t>At this point, when the application attempts to use the refresh token after 24 hours, the request will fail and the application will have to involve the user in a new authorization request</t>
</list></t>

<t>By limiting the overall refresh token lifetime to the lifetime of the initial refresh token, this ensures a stolen refresh token cannot be used indefinitely.</t>

<t>Authorization servers MAY set different policies around refresh token issuance, lifetime and expiration for browser-based applications compared to other public clients.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="client_registration" title="Registration of Browser-Based Apps">

<t>Browser-based applications are considered public clients as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>, and MUST be registered with the authorization server as
such. Authorization servers MUST record the client type in the client registration
details in order to identify and process requests accordingly.</t>

<t>Authorization servers MUST require that browser-based applications register
one or more redirect URIs.</t>

</section>
<section anchor="client_authentication" title="Client Authentication">

<t>Since a browser-based application's source code is delivered to the end-user's
browser, it cannot contain provisioned secrets. As such, a browser-based app
with native OAuth support is considered a public client as defined by Section 2.1
of OAuth 2.0 <xref target="RFC6749"/>.</t>

<t>Secrets that are statically included as part of an app distributed to
multiple users should not be treated as confidential secrets, as one
user may inspect their copy and learn the shared secret.  For this
reason, and those stated in Section 5.3.1 of <xref target="RFC6819"/>, it is NOT RECOMMENDED
for authorization servers to require client authentication of browser-based
applications using a shared secret, as this serves little value beyond
client identification which is already provided by the client_id request parameter.</t>

<t>Authorization servers that still require a statically included shared
secret for SPA clients MUST treat the client as a public
client, and not accept the secret as proof of the client's identity. Without
additional measures, such clients are subject to client impersonation
(see <xref target="client_impersonation"/> below).</t>

</section>
<section anchor="client_impersonation" title="Client Impersonation">

<t>As stated in Section 10.2 of OAuth 2.0 <xref target="RFC6749"/>, the authorization
server SHOULD NOT process authorization requests automatically
without user consent or interaction, except when the identity of the
client can be assured.</t>

<t>If authorization servers restrict redirect URIs to a fixed set of absolute
HTTPS URIs, preventing the use of wildcard domains, wildcard paths, or wildcard query string components,
this exact match of registered absolute HTTPS URIs MAY be accepted by authorization servers as
proof of identity of the client for the purpose of deciding whether to automatically
process an authorization request when a previous request for the client_id
has already been approved.</t>

</section>
<section anchor="csrf_protection" title="Cross-Site Request Forgery Protections">

<t>Clients MUST prevent Cross-Site Request Forgery (CSRF) attacks against their redirect URI.
Clients can accomplish this by either ensuring the authorization server supports
PKCE and relying on the CSRF protection that PKCE provides, or if the client is also an
OpenID Connect client, using the OpenID Connect "nonce" parameter, or by using the
"state" parameter to carry one-time-use CSRF tokens as described in <xref target="auth_code_request"/>.</t>

<t>See Section 2.1 of <xref target="oauth-security-topics"/> for additional details.</t>

</section>
<section anchor="auth_server_mixup" title="Authorization Server Mix-Up Mitigation">

<t>Authorization server mix-up attacks mark a severe threat to every client that supports
at least two authorization servers. To conform to this BCP such clients MUST apply
countermeasures to defend against mix-up attacks.</t>

<t>It is RECOMMENDED to defend against mix-up attacks by identifying and validating the issuer
of the authorization response. This can be achieved either by using the "iss" response
parameter, as defined in <xref target="oauth-iss-auth-resp"/>, or by using the "iss" Claim of the ID token
when OpenID Connect is used.</t>

<t>Alternative countermeasures, such as using distinct redirect URIs for each issuer, SHOULD
only be used if identifying the issuer as described is not possible.</t>

<t>Section 4.4 of <xref target="oauth-security-topics"/> provides additional details about mix-up attacks
and the countermeasures mentioned above.</t>

</section>
<section anchor="cors" title="Cross-Domain Requests">

<t>To complete the Authorization Code flow, the browser-based application will
need to exchange the authorization code for an access token at the token endpoint.
If the authorization server provides additional endpoints to the application, such
as metadata URLs, dynamic client registration, revocation, introspection, discovery or
user info endpoints, these endpoints may also be accessed by the browser-based app.
Since these requests will be made from a browser, authorization servers MUST support
the necessary CORS headers (defined in <xref target="Fetch"/>) to allow the browser to make the
request.</t>

<t>This specification does not include guidelines for deciding whether a CORS policy
for the token endpoint should be a wildcard origin or more restrictive. Note,
however, that the browser will attempt to GET or POST to the API endpoint before
knowing any CORS policy; it simply hides the succeeding or failing result from
JavaScript if the policy does not allow sharing.</t>

</section>
<section anchor="csp" title="Content Security Policy">

<t>A browser-based application that wishes to use either long-lived refresh tokens or
privileged scopes SHOULD restrict its JavaScript execution to a set of statically
hosted scripts via a Content Security Policy (<xref target="CSP2"/>) or similar mechanism. A
strong Content Security Policy can limit the potential attack vectors for malicious
JavaScript to be executed on the page.</t>

</section>
<section anchor="implicit_flow" title="OAuth Implicit Flow">

<t>The OAuth 2.0 Implicit flow (defined in Section 4.2 of
OAuth 2.0 <xref target="RFC6749"/>) works by the authorization server issuing an access token in the
authorization response (front channel) without the code exchange step. In this case, the access
token is returned in the fragment part of the redirect URI, providing an attacker
with several opportunities to intercept and steal the access token.</t>

<t>Authorization servers MUST NOT issue access tokens in the authorization response, and MUST issue
access tokens only from the token endpoint.</t>

<section anchor="attacks-on-the-implicit-flow" title="Attacks on the Implicit Flow">

<t>Many attacks on the Implicit flow described by <xref target="RFC6819"/> and Section 4.1.2 of <xref target="oauth-security-topics"/>
do not have sufficient mitigation strategies. The following sections describe the specific
attacks that cannot be mitigated while continuing to use the Implicit flow.</t>

<section anchor="threat-manipulation-of-the-redirect-uri" title="Threat: Manipulation of the Redirect URI">

<t>If an attacker is able to cause the authorization response to be sent to a URI under
their control, they will directly get access to the authorization response including the access token.
Several methods of performing this attack are described in detail in <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-access-token-leak-in-browser-history" title="Threat: Access Token Leak in Browser History">

<t>An attacker could obtain the access token from the browser's history.
The countermeasures recommended by <xref target="RFC6819"/> are limited to using short expiration
times for tokens, and indicating that browsers should not cache the response.
Neither of these fully prevent this attack, they only reduce the potential damage.</t>

<t>Additionally, many browsers now also sync browser history to cloud services and to
multiple devices, providing an even wider attack surface to extract access tokens
out of the URL.</t>

<t>This is discussed in more detail in Section 4.3.2 of <xref target="oauth-security-topics"/>.</t>

</section>
<section anchor="threat-manipulation-of-scripts" title="Threat: Manipulation of Scripts">

<t>An attacker could modify the page or inject scripts into the browser through various
means, including when the browser's HTTPS connection is being intercepted by, for
example, a corporate network. While man-in-the-middle attacks are typically out of scope
of basic security recommendations to prevent, in the case of browser-based apps they are
much easier to perform. An injected script can enable an attacker to have access to everything
on the page.</t>

<t>The risk of a malicious script running on the page may be amplified when the application
uses a known standard way of obtaining access tokens, namely that the attacker can
always look at the <spanx style="verb">window.location</spanx> variable to find an access token. This threat profile
is different from an attacker specifically targeting an individual application
by knowing where or how an access token obtained via the Authorization Code flow may
end up being stored.</t>

</section>
<section anchor="threat-access-token-leak-to-third-party-scripts" title="Threat: Access Token Leak to Third-Party Scripts">

<t>It is relatively common to use third-party scripts in browser-based apps, such as
analytics tools, crash reporting, and even things like a Facebook or Twitter "like" button.
In these situations, the author of the application may not be able to be fully aware
of the entirety of the code running in the application. When an access token is
returned in the fragment, it is visible to any third-party scripts on the page.</t>

</section>
</section>
<section anchor="countermeasures" title="Countermeasures">

<t>In addition to the countermeasures described by <xref target="RFC6819"/> and <xref target="oauth-security-topics"/>,
using the Authorization Code flow with PKCE extension prevents the attacks described above by
avoiding returning the access token in the redirect response at all.</t>

<t>When PKCE is used, if an authorization code is stolen in transport, the attacker is
unable to do anything with the authorization code.</t>

</section>
<section anchor="disadvantages-of-the-implicit-flow" title="Disadvantages of the Implicit Flow">

<t>There are several additional reasons the Implicit flow is disadvantageous compared to
using the standard Authorization Code flow.</t>

<t><list style="symbols">
  <t>OAuth 2.0 provides no mechanism for a client to verify that a particular access token was
intended for that client, which could lead to misuse and possible impersonation attacks if
a malicious party hands off an access token it retrieved through some other means
to the client.</t>
  <t>Returning an access token in the front-channel redirect gives the authorization
server no assurance that the access token will actually end up at the
application, since there are many ways this redirect may fail or be intercepted.</t>
  <t>Supporting the Implicit flow requires additional code, more upkeep and
understanding of the related security considerations, while limiting the
authorization server to just the Authorization Code flow reduces the attack surface
of the implementation.</t>
  <t>If the JavaScript application gets wrapped into a native app, then <xref target="RFC8252"/>
also requires the use of the Authorization Code flow with PKCE anyway.</t>
</list></t>

<t>In OpenID Connect, the ID Token is sent in a known format (as a JWT), and digitally
signed. Returning an ID token using the Implicit flow (<spanx style="verb">response_type=id_token</spanx>) requires the client
validate the JWT signature, as malicious parties could otherwise craft and supply
fraudulent ID tokens. Performing OpenID Connect using the Authorization Code flow provides
the benefit of the client not needing to verify the JWT signature, as the ID token will
have been fetched over an HTTPS connection directly from the authorization server. Additionally,
in many cases an application will request both an ID token and an access token, so it is
simplier and provides fewer attack vectors to obtain both via the Authorization Code flow.</t>

</section>
<section anchor="historic-note" title="Historic Note">

<t>Historically, the Implicit flow provided an advantage to browser-based apps since
JavaScript could always arbitrarily read and manipulate the fragment portion of the
URL without triggering a page reload. This was necessary in order to remove the
access token from the URL after it was obtained by the app.</t>

<t>Modern browsers now have the Session History API (described in "Session history and
navigation" of <xref target="HTML"/>), which provides a mechanism to modify the path and query string
component of the URL without triggering a page reload. This means modern browser-based apps can
use the unmodified OAuth 2.0 Authorization Code flow, since they have the ability to
remove the authorization code from the query string without triggering a page reload
thanks to the Session History API.</t>

</section>
</section>
<section anchor="additional-security-considerations" title="Additional Security Considerations">

<t>The OWASP Foundation (https://www.owasp.org/) maintains a set of security
recommendations and best practices for web applications, and it is RECOMMENDED
to follow these best practices when creating an OAuth 2.0 Browser-Based application.</t>

</section>
</section>
<section anchor="iana" title="IANA Considerations">

<t>This document does not require any IANA actions.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC2119;
&RFC6749;
&RFC6750;
&RFC6819;
&RFC7636;
&RFC8252;
<reference anchor="draft-ietf-httpbis-rfc6265bis" >
  <front>
    <title>Cookies: HTTP State Management Mechanism</title>
    <author initials="L." surname="Chen" fullname="L. Chen">
      <organization>Google LLC</organization>
    </author>
    <author initials="S." surname="Englehardt" fullname="S. Englehardt">
      <organization>Mozilla</organization>
    </author>
    <author initials="M." surname="West" fullname="M. West">
      <organization>Google LLC</organization>
    </author>
    <author initials="J." surname="Wilander" fullname="J. Wilander">
      <organization>Apple, Inc</organization>
    </author>
    <date year="2021" month="October"/>
  </front>
</reference>
<reference anchor="CSP2" >
  <front>
    <title>Content Security Policy</title>
    <author initials="M." surname="West" fullname="Mike West">
      <organization>Google, Inc</organization>
    </author>
    <date year="2018" month="October"/>
  </front>
</reference>
<reference anchor="Fetch" >
  <front>
    <title>Fetch</title>
    <author initials="." surname="whatwg" fullname="whatwg">
      <organization></organization>
    </author>
    <date year="2018"/>
  </front>
</reference>
<reference anchor="oauth-security-topics" >
  <front>
    <title>OAuth 2.0 Security Best Current Practice</title>
    <author initials="T." surname="Lodderstedt" fullname="Torsten Lodderstedt">
      <organization>yes.com</organization>
    </author>
    <author initials="J." surname="Bradley" fullname="John Bradley">
      <organization>Yubico</organization>
    </author>
    <author initials="A." surname="Labunets" fullname="Andrey Labunets">
      <organization>Facebook</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2021" month="April"/>
  </front>
</reference>
<reference anchor="oauth-iss-auth-resp" >
  <front>
    <title>OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response</title>
    <author initials="K." surname="Meyer zu Selhausen" fullname="Karsten Meyer zu Selhausen">
      <organization>Hackmanit</organization>
    </author>
    <author initials="D." surname="Fett" fullname="Daniel Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2021" month="January"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

<reference anchor="HTML" >
  <front>
    <title>HTML</title>
    <author initials="." surname="whatwg" fullname="whatwg">
      <organization></organization>
    </author>
    <date year="2020"/>
  </front>
</reference>


    </references>


<section anchor="server-support-checklist" title="Server Support Checklist">

<t>OAuth authorization servers that support browser-based apps MUST:</t>

<t><list style="numbers">
  <t>Require "https" scheme redirect URIs.</t>
  <t>Require exact matching of registered redirect URIs.</t>
  <t>Support PKCE <xref target="RFC7636"/>. Required to protect authorization code
grants sent to public clients. See <xref target="auth_code_request"/></t>
  <t>Support cross-domain requests at the token endpoint in order to allow browsers
to make the authorization code exchange request. See <xref target="cors"/></t>
  <t>Not assume that browser-based clients can keep a secret, and SHOULD NOT issue
secrets to applications of this type.</t>
  <t>Not support the Resource Owner Password grant for browser-based clients.</t>
  <t>Follow the <xref target="oauth-security-topics"/> recommendations on refresh tokens, as well
as the additional requirements described in <xref target="refresh_tokens"/>.</t>
</list></t>

</section>
<section anchor="document-history" title="Document History">

<t>[[ To be removed from the final specification ]]</t>

<t>-09</t>

<t><list style="symbols">
  <t>Provide additional context for the same-domain architecture pattern</t>
  <t>Added reference to draft-ietf-httpbis-rfc6265bis to clarify that SameSite is not the only CSRF protection measure needed</t>
  <t>Editorial improvements</t>
</list></t>

<t>-08</t>

<t><list style="symbols">
  <t>Added a note to use the "Secure" cookie attribute in addition to SameSite etc</t>
  <t>Updates to bring this draft in sync with the latest Security BCP</t>
  <t>Updated text for mix-up countermeasures to reference the new "iss" extension</t>
  <t>Changed "SHOULD" for refresh token rotation to MUST either use rotation or sender-constraining to match the Security BCP</t>
  <t>Fixed references to other specs and extensions</t>
  <t>Editorial improvements in descriptions of the different architectures</t>
</list></t>

<t>-07</t>

<t><list style="symbols">
  <t>Clarify PKCE requirements apply only to issuing access tokens</t>
  <t>Change "MUST" to "SHOULD" for refresh token rotation</t>
  <t>Editorial clarifications</t>
</list></t>

<t>-06</t>

<t><list style="symbols">
  <t>Added refresh token requirements to AS summary</t>
  <t>Editorial clarifications</t>
</list></t>

<t>-05</t>

<t><list style="symbols">
  <t>Incorporated editorial and substantive feedback from Mike Jones</t>
  <t>Added references to "nonce" as another way to prevent CSRF attacks</t>
  <t>Updated headers in the Implicit Flow section to better represent the relationship between the paragraphs</t>
</list></t>

<t>-04</t>

<t><list style="symbols">
  <t>Disallow the use of the Password Grant</t>
  <t>Add PKCE support to summary list for authorization server requirements</t>
  <t>Rewrote refresh token section to allow refresh tokens if they are time-limited, rotated on each use, and requiring that the rotated refresh token lifetimes do not extend past the lifetime of the initial refresh token, and to bring it in line with the Security BCP</t>
  <t>Updated recommendations on using state to reflect the Security BCP</t>
  <t>Updated server support checklist to reflect latest changes</t>
  <t>Updated the same-domain JS architecture section to emphasize the architecture rather than domain</t>
  <t>Editorial clarifications in the section that talks about OpenID Connect ID tokens</t>
</list></t>

<t>-03</t>

<t><list style="symbols">
  <t>Updated the historic note about the fragment URL clarifying that the Session History API means browsers can use the unmodified authorization code flow</t>
  <t>Rephrased "Authorization Code Flow" intro paragraph to better lead into the next two sections</t>
  <t>Softened "is likely a better decision to avoid using OAuth entirely" to "it may be..." for common-domain deployments</t>
  <t>Updated abstract to not be limited to public clients, since the later sections talk about confidential clients</t>
  <t>Removed references to avoiding OpenID Connect for same-domain architectures</t>
  <t>Updated headers to better describe architectures (Apps Served from a Static Web Server -&gt; JavaScript Applications without a Backend)</t>
  <t>Expanded "same-domain architecture" section to better explain the problems that OAuth has in this scenario</t>
  <t>Referenced Security BCP in implicit flow attacks where possible</t>
  <t>Minor typo corrections</t>
</list></t>

<t>-02</t>

<t><list style="symbols">
  <t>Rewrote overview section incorporating feedback from Leo Tohill</t>
  <t>Updated summary recommendation bullet points to split out application and server requirements</t>
  <t>Removed the allowance on hostname-only redirect URI matching, now requiring exact redirect URI matching</t>
  <t>Updated Section 6.2 to drop reference of SPA with a backend component being a public client</t>
  <t>Expanded the architecture section to explicitly mention three architectural patterns available to JS apps</t>
</list></t>

<t>-01</t>

<t><list style="symbols">
  <t>Incorporated feedback from Torsten Lodderstedt</t>
  <t>Updated abstract</t>
  <t>Clarified the definition of browser-based apps to not exclude applications cached in the browser, e.g. via Service Workers</t>
  <t>Clarified use of the state parameter for CSRF protection</t>
  <t>Added background information about the original reason the implicit flow was created due to lack of CORS support</t>
  <t>Clarified the same-domain use case where the SPA and API share a cookie domain</t>
  <t>Moved historic note about the fragment URL into the Overview</t>
</list></t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to acknowledge the work of William Denniss and John Bradley,
whose recommendation for native apps informed many of the best practices for
browser-based applications. The authors would also like to thank Hannes Tschofenig
and Torsten Lodderstedt, the attendees of the Internet Identity Workshop 27
session at which this BCP was originally proposed, and the following individuals
who contributed ideas, feedback, and wording that shaped and formed the final specification:</t>

<t>Annabelle Backman, Brian Campbell, Brock Allen, Christian Mainka, Daniel Fett,
George Fletcher, Hannes Tschofenig, Janak Amarasena, John Bradley, Joseph Heenan,
Justin Richer, Karl McGuinness, Karsten Meyer zu Selhausen, Leo Tohill, Mike Jones,
Tomek Stojecki, Torsten Lodderstedt, and Vittorio Bertocci.</t>

</section>


  </back>

<!-- ##markdown-source:
H4sIAPWQJmIAA719aXfbRpbo9/oVeMqHSB2StuVs7Xndb2TZjpXYsZ4lv5w+
c2aSIlAU0QIBDgqQzCz/fe5WGwhIcve80UzHEgnUcuvuW83nc9WVXWWeZe9O
+m6dHS8eZ6umzZ63za017fy5tqbITrZbq4omr/UGnixavermpelW80bDS/Ol
PLzEh+caHp4//rMqdAcPHz8+Pp4/fjp//I1S5bZ9lnVtb7vjx4///PhY6dbo
Z9mFyfu27Hbqtmmvr9qm3z7LfjLLDBfUtOWvuiubOjtvm67Jm0pd3z7LzurO
tLXp5i9wLSrX3bNsmW+VypuirK+eZb2da5uXpdqWz1SWwZvPsp2x8Ktt2q41
K+v/3m3Cn0rTnPjKHP6XZWUN35wssnNYan5d0mcMhRPd4qqiz5sWJn533Wn6
y2x0WT3LND72r1t+bJE3G/oS9vssW3fd1j579IgeSZ+IJn+xyH7SZWeiqV/o
m7KIPqWJz2Hf2Vlh6g5BGa2gwKf/VVfXuiprM7dN1SNALU2l6qbdAIBvDO75
/avT4ydP/iy/fv3Nl+HXrx67X7/1D3zz9dOv5ddvj786xl8j3MDtLUs7b1f5
18dffwW/PqNlCb4dnDbNdWlgh68vL8+ziw7QJXura31lNrCJ7K3J17ou7eaA
3mJsepd3zdK0iFVPBJBVAGTXNJVd4OQLAMmjsnh053IASRfrblPRQOHgAfoC
5zeL7HRtavpMoPxd01xVJnvz5jR58mKRvazhi7Vuiy5+/m3za1lVOnn4LZyo
sd0Dhv0eniwrXRemjZ8GcqzMDIggh09PL86PE8CeNkAcAEBHVtl5U5X5bnKX
b8trEy+IsG5yjW7a/RN58u3+idze3i5un9JpXL5/BEt9+ggeemW6fJ2smT7Z
W6HD99u17m6v4uVFnzg2Mzb9Codd2K3JF/wGrQSeY75lBULzrtmWeYqegR16
OD4HgGSnfdsidM9bnXdlbibBetm0Fs4he9MUcHzwa5EA+HIx8g3BGfiQ5xMe
EZp1DTxZF5XZxaMAgqSf0gh/65dl3iQDnNRFa3bZG73sgW3aeAzgboOPaZBX
OjdLINFkmBdAkabC40o2Azwq+mhvF3xEJ9u2rB5GuUiVj/bEzOC4/DGWFpg9
/tIau504xFSWXJj2BnD2zNoe/yGmuSrh17IePPkehgReOX3MP2g+5rdmB+//
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

-->

</rfc>

